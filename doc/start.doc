@comment -*-texinfo-*-
@comment $Id: start.doc,v 1.17 1998-05-19 18:53:49 schmidt Exp $
@comment this file contains the "Introduction" chapter.

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').
@ignore
%**start
\input texinfo.tex
@setfilename general.info
@node Top, Introduction
@menu
* Introduction::
@end menu
@node Introduction, General concepts, Preface, Top
@chapter Introduction
%**end
@end ignore


@menu
* Background::                  
* How to use this manual::      
* Getting started::             
@end menu

@c ------------------------------------------------------------------
@node Background, How to use this manual, Introduction, Introduction
@section Background
@cindex Background

@sc{Singular} is a Computer Algebra system for polynomial
computations with emphasize on the special needs of commutative
algebra, algebraic geometry, and singularity theory.  

@sc{Singular}'s main computational objects are ideals and
modules over a large variety of baserings. The baserings are polynomial
rings or localizations thereof over a field (e.g., finite fields, the
rationals, floats, algebraic extensions, transcendental extensions) or
quotient rings with respect to an ideal.

@sc{Singular} features one of the fastest and most general
implementation of various algorithms for computing Groebner
resp.@: standard bases. The implementation includes Buchberger's algorithm
(if the ordering is a wellordering) and Mora's algorithm (if the
ordering is a tangent cone ordering) as special cases.  Furthermore, it
provides polynomial factorizations, resultant, characteristic set and
gcd computations, syzygy and free-resolution computations, and many more
related functionalities.

Based on an easy-to-use interactive shell and a C-like programming
language, @sc{Singular}'s internal functionality is augmented and
user-extendible by libraries written in the @sc{Singular} programming
language. A general and efficient implementation of communication links
allows @sc{Singular} to make its functionality available to other
programs.

@sc{Singular}'s development started in 1984 with an implementation of
Mora's Tangent Cone algorithms in Modula-2 on an Atari computer (K.P.
Neuendorf, G. Pfister,
@ifinfo
H.@: Schoenemann; Humboldt-Universitaet
@end ifinfo
@tex
H.@: Sch\"onemann; Humboldt-Universit\"at
@end tex
zu Berlin).  The need for a new system arose from the investigation of
mathematical problems coming from singularity theory which none of the
existing systems was able to compute.

In the early 1990s @sc{Singular}'s "home-town" moved to
Kaiserslautern, a general standard basis algorithm was implemented in C
and @sc{Singular} was ported to Unix, MS-DOS, Windows NT, and MacOS. 

Continuous extensions (like polynomial factorization, gcd computations,
links) and refinements led in 1997 to the release of @sc{Singular}
version 1.0.

The highlights of the new @sc{Singular} version 1.2. include: much
faster standard and Groebner bases computations based on Hilbert series
and on improved implementations of the algorithms and the addition of
libraries for primary decomposition, ring normalization, etc.

@c Thus, we hope to offer a useful system
@c for dealing with local and global computational aspects
@c of systems of polynomial equations.

@c ------------------------------------------------------------------
@node How to use this manual, Getting started, Background, Introduction
@section How to use this manual
@cindex How to use this manual

@subsubheading For the impatient user
In @ref{Getting started}, some simple examples are explained in a
step-by-step manner to introduce into @sc{Singular}.

@ref{Examples} should come next for real learning-by-doing or to quickly
solve some given mathematical problems without dwelling to deeply into
@sc{Singular}.  This chapter contains a lot of real-life examples and
detailed instructions and explanations on how to solve mathematical
problems using @sc{Singular}.

@subsubheading For the systematic user
In @ref{General concepts}, all basic concepts which are important to use
and understand @sc{Singular} are developed.  But even for users
preferring the systematic approach it will be helpful to have a look at
the examples in @ref{Getting started}, every now and then. The topics in
the chapter are organized more or less in the order the novice user has
to deal with them.

@itemize @bullet
@item
In @ref{Interactive use}, and its subsections there are some words on
entering and exiting @sc{Singular}, followed by a number of other
aspects concerning the interactive user-interface.

@item
To do anything more than trivial integer computations, one needs to
define a basering in @sc{Singular}.  This is explained in detail in
@ref{Rings and orderings}.

@item
An overview of the algorithms implemented in the kernel of @sc{Singular}
is given in @ref{Implemented algorithms}.

@item
In @ref{The SINGULAR language}, language specific concepts are
introduced such as the notions of names and objects, data types and
conversion between them, etc.

@item
The more complex concepts of procedures and libraries as
well as tools to debug them are considered in the following sections:
@ref{Procedures}, @ref{Libraries}, and @ref{Debugging tools}.

@item
Finally, in @ref{Input and output},  @sc{Singular}'s mechanisms to
store and retrieve data are discussed.

@end itemize

@ref{Data types}, is a complete treatment for @sc{Singular}'s data types
where each section corresponds to one data type, alphabetically sorted.
For each data type, its purpose is explained, the syntax of its
declaration is given, and related operations and functions are
listed. Examples illustrate its usage.

@ref{Functions and system variables}, is an alphabetically ordered
reference list of all of @sc{Singular}'s functions, control structures,
and system variables.  Each entry includes a description of the syntax
and semantics of the item being explained as well as one or more
examples on how to use it.

@subsubheading Miscellay
@ref{Tricks and pitfalls}, is a loose collection of limitations and
features which may be unexpected by those who expect to be the
@sc{Singular} language an exact copy of the C programming language or of
some Computer Algebra system languages.  But some mathematical tips are
collected there ase well.

@ref{Mathematical background} introduces some of the mathematical
notions and definitions used throughout this manual.  For example, if in
doubt what exactly @sc{Singular} means by a ``negative degree reverse
lexicographical ordering'' one should refer to this chapter.

@ref{SINGULAR libraries}, and @ref{Library function index} lists the
libraries which come with @sc{Singular} and the functions contained in
them, resp.

@subsubheading Typograhpical conventions
Throughout this manual, the following typographical conventions are
adopted:

@itemize @bullet
@item 
text in @code{typewriter} denotes @sc{Singular} input and output as well 
as reserved names:
@itemize @asis
@item The basering can be set using the command @code{setring}.
@end itemize
@item
the arrow @expansion{} denotes @sc{Singular} output:
@itemize @asis
@item @code{poly p=x+y+z;}
@item @code{p*p;}
@item @code{@expansion{} x2+2xy+y2+2xz+2yz+z2}
@end itemize
@item
square brackets are used to denote parts of syntax descriptions which
are optional: 
@itemize @asis
[optional_text] required_text
@end itemize
@item 
keys are denoted using typewriter: 
@itemize @asis
@item @code{N}
@item @code{RETURN}
@item @code{CTRL-P} (press control key together with the key @code{P})
@end itemize
@end itemize

@c ------------------------------------------------------------------
@node Getting started,  , How to use this manual, Introduction
@section Getting started
@cindex Getting started

@menu
* Generalities::                
* Rings and standard bases::    
* Procedures and libraries::    
* Change of rings::             
* Modules and their annihilator::  
* Resolution and Ext groups::   
@end menu

@c ------------------------------------------------------------------
@node Generalities, Rings and standard bases, Getting started, Getting started
@subsection Generalities
@cindex Generalities

@c {{{ subsection Generalities }}}
Once @sc{Singular} is started, it attends input after the promt @code{>}.
Every statement has to be closed by an @code{;}
@example
1+1;
@expansion{} 2
@end example
All objects have a type, e.g.
integer variables are defined by the word @code{int}.
An assignement is done by the symbol @code{=}.
@example
int k =2;
@end example
The value of an object is display simply by typing its name
@example
k;
@expansion{} 2
@end example
On the other hand output is only subpressed if an assignement is made.
@example
int j;
j = k+1;
@end example
The last displayed result is always available with the special symbol
@code{_}.
@example
2*_;   // the value from k displayed three lines above
@expansion{} 4
@end example
Furthermore @sc{Singular} maintains a history of the last input, which
may be  accessed by @code{CTRL-P} and @code{CTRL-N} or the arrows on the
keyboard. This simplifies to redo examples with minor changements.

Text starting with @code{//}denotes a comment and is ignored in 
calculations, as seen in the previous example.
@c Comments are marked with @code{//} as seen  
The whole manual is online available under the command @code{help;} 
Explanation on single topics  e.g. on @code{intmat} which defines a matrix 
of integers are
obtained by 
@example
help intmat;
@end example  
This showss the text from @ref{intmat} in the printed maual. 
Define a @code{3 x 3} matrix of integers, and initialize it with some values.
@example
@c  intmat m[3][3] = 1..9; // bug here, converts the 3x3 intmat into 9x1, hence
intmat m[3][3] = 1,2,3,4,5,6,7,8,9;
@end example  
A single entry is selected with the square brackets @code{[,]}.
@example
m[2,2]=0;
m;
@expansion{} 1, 2, 3,
@expansion{} 4, 0, 6,
@expansion{} 5, 6, 7
@end example  
To calculate the fourth power of this integer matrix, use a @code{for} loop,
the curly brackets @code{@{} and @code{@}} benote a begin and end of a block.
@example
intmat mm = m;
for (j = 1; j<= 3; j++)
@{
 mm = mm * m;
@}
mm;
@expansion{} 6380,5848,9276,
@expansion{} 10688,10008,15528,
@expansion{} 22316,20368,32460 
@end example  

@c ------------------------------------------------------------------
@node Rings and standard bases, Procedures and libraries, Generalities, Getting started
@subsection Rings and standard bases
@cindex Rings and standard bases
To calculate with objects as ideals, matrices, modules and vectors based on 
polynomials a ring has to be defined first.
@example
ring r1 = 0,(x,y,z),dp;
@end example   
This gives a polynomial ring called @code{r} in characteristic zero and 
ring variables @code{x,y,z}. The @code{dp} at the end determines the termorder
of the polynomials and hence the standard basis calculation.
The @code{p} stands for @code{p}olynomial, so decreasing order of 
exponents, whereas an @code{s} means power@code{s}eries and increasing order 
of exponents.
@* Define some polynomials
@example
poly f =  x3+y3+(x-y)*x2y2+z2;
poly g =  f^2 *(2x-y);
f;
@expansion{} x3y2-x2y3+x3+y3+z2
@end example

@code{size} determines in general the number of single entries in an object.
@example
size(g);
@expansion{25}
@end example
A natural question is to ask if a point e.g. @code{(x,y,z)=(1,2,0)} lies on the
variety defined by the polynomials @code{f} and @code{g}.
@example
ideal I = f,g;
@end example
So substitute 1 for the first variable, 2 for the second and 3 for the last.
@example
ideal J= subst(I,var(1),1);
J = subst(J,var(2),2);
J = subst(J,var(3),0);
@end example
In an ideal @code{size} counts only the nonzero generators.
@example
J;
@expansion{J[1]=5}
@expansion{J[2]=0}
size(J);
@expansion{1}
@end example
Hence the point @code{(1,2,0)} is not lying on the variety @code{V(f,g)}.

A second question is, to decide if some function vanishes on a variety,
or in algebraic terms if a polynomial is included in a given ideal.
This need a standard basis calculatation  with the command 
@code{std}, then calculate the normalform of the asked polynomial with respect
to the standard basis.
@example
ideal sI = std(f);
reduce(g,sI);
@expansion{0}
@end example
As the result is @code{0} the polynom @code{f} belongs to the ideal defined by 
@code{g}, as it was clear in at advance.

The command @code{kbase} calculates a basis of the polynomial ring modulo an
ideal. As application calculate the Milnor number
of a  hypersurface singularity in the global and local case. This is
the vectorspace dimension of the polynomial ring modulo the Jacobian ideal
in the global case resp.@: of the powerseries ring modulo the Jacobian ideal.

The Jacobian ideal is obtained with the command @code{jacob}.
@example
ideal J = jacob(f);
J;
@expansion{J[1]=3x2y2-2xy3+3x2}
@expansion{J[2]=2x3y-3x2y2+3y2}
@expansion{J[3]=2z} 
@end example
To get a representing set of the quotient vectorspace 
a standard basis has to be calculated first.
@example
J = std(J);
J;
@expansion{J[1]=z}
@expansion{J[2]=3x2y2-2xy3+3x2}
@expansion{J[3]=2x3y-2xy3+3x2+3y2}
@expansion{J[4]=4x4-12xy3+4y4+9x2+9y2}
@expansion{J[5]=20y5+54x3-45x2y-30xy2-81y3}
@expansion{J[6]=10xy4+18x3-15x2y-27y3}
@end example
Then 
@example
ideal I = kbase(J);
I;
@expansion{_[1]=y4}
@expansion{_[2]=xy3}
@expansion{_[3]=y3}
@expansion{_[4]=xy2}
@expansion{_[5]=y2}
@expansion{_[6]=x2y}
@expansion{_[7]=xy}
@expansion{_[8]=y}
@expansion{_[9]=x3}
@expansion{_[10]=x2}
@expansion{_[11]=x}
@expansion{_[12]=1}
@end example
and
@example
size(I);
@expansion{12}
@end example
gives the desired vectorspace dimension.
As in @sc{Singular} the functions may take directly the input from 
earlier calculations, all may be written together in one single statement.
@example
size(kbase(std(jacob(f))));
@expansion{12}
@end example

Because we are not interested in the elements of the quotient vectorspace,
but only in the resulting deimension we may even use the command @code{vdim}
and write
@example
vdim(std(jacob(f)));
@expansion{12}
@end example

@c ------------------------------------------------------------------
@node Procedures and libraries, Change of rings, Rings and standard bases, Getting started
@subsection Procedures and libraries
@cindex Procedures and libraries

@sc{Singular} offers a comfortable programming language, with syntax close 
to C. 
So it is possible to 
define procedures which collect several commands to a new one. 
Procedures are defined with the keyword @code{proc} followed by a name
and an optional parameterlist with specified types.
Finally, a procedure may return values with the command @code{return}.

Define the following procedure called @code{Milnor}

@example
proc Milnor(poly h)
@{
 return(vdim(std(jacob(h))));
@}
@end example


Then call
@example
Milnor(f);
@expansion{12}
@end example

With @sc{Singular} come several libraries, collections of useful procedures
based on the implemented commands, which extends now the facilities of 
@sc{Singular}. One of these  is e.g. @code{sing.lib}
which contains already a procedure 
called @code{milnor} to calculate the Milnor number not only for hypersurfaces
but more generally for complete intersection singularties.

Libraries are loaded with the command @code{LIB}. Some additional information
during the process of loading is displayed on the screen, which we omitt here.

@example
LIB "sing.lib";
@end example

As all input in @sc{Singular} is case sensitiv, there is no conflict with
the previous  defined @code{proc Milnor} but the result is the same.
@example
milnor(f);
@expansion{}
@end example

The procedures in a library have a help part 
which is shown with 
@example
help milnor;
@expansion{// proc milnor from lib sing.lib}
@expansion{proc milnor (ideal i)}
@expansion{USAGE:   milnor(i); i ideal or poly}
@expansion{RETURN:  Milnor number of i, if i is ICIS (isolated complete intersection}
@expansion{         singularity) in generic form, resp. -1 if not}
@expansion{NOTE:    use proc nf_icis to put generators in generic form}
@expansion{         printlevel >=0: display comments (default)}
@expansion{EXAMPLE: example milnor; shows an example}
@end example
as well as some examples, which are executed with
@example
example milnor;
@expansion{12}
@end example

Likewise the library itself posses a help part, to show all the functions
available for the user defined in the library.
@example
help sing.lib;
@end example

@c ------------------------------------------------------------------
@node Change of rings, Modules and their annihilator, Procedures and libraries, Getting started
@subsection Change of rings
@cindex Change of rings

To calculate the local Milnor number we have to do the calculation with the
same commands in a ring with local ordering.  Define
@example
ring r2 = 0,(x,y,z),ds;
@end example
This ordering determines the standard basis which will be calculated.
Fetch the polynomial definded in the ring @code{r1} into this new ring,
thus avoiding retyping the input.
@example
poly f = fetch(r1,f);
f;
@expansion{z2+x3+y3+x3y2-x2y3}
@end example
Here the terms are orderd by increasing exponents. The local Milnor number is
now 
@example
Milnor(f);
@expansion{4}
@end example

The command @code{jacob} applied twice 
givess the Hessian of @code{f} a @code{3x3} matrix.
@example
matrix H = jacob(jacob(f));
H;
@expansion{H[1,1]=6x+6xy2-2y3} 
@expansion{H[1,2]=6x2y-6xy2}
@expansion{H[1,3]=0}
@expansion{H[2,1]=6x2y-6xy2}
@expansion{H[2,2]=6y+2x3-6x2y}
@expansion{H[2,3]=0}
@expansion{H[3,1]=0}
@expansion{H[3,2]=0}
@expansion{H[3,3]=2}
@end example

The @code{print} command displays the matrix in a nicer form.
@example
print(H);
@expansion{6x+6xy2-2y3,6x2y-6xy2,  0,}
@expansion{6x2y-6xy2,  6y+2x3-6x2y,0,}
@expansion{0,          0,          2}
@end example

We may calculate the determinat and minors of differents size.
@example
det(H);
@expansion{72xy+24x4-72x3y+72xy3-24y4-48x4y2+64x3y3-48x2y4}
minor(H,1);
@expansion{}
@end example

The variety defined by the one dimensional minors is empty.
With the command @code{option} the algortihm of the standard basis 
may be affected. For instance a reduced standard basis is obtained 
in the following way  
@example
option(redSB);
std(_);
@expansion{}
@end example

@c Coming back to some mathematical considerations, we study the problem how
@c to calculate some ....

@c ------------------------------------------------------------------
@c REMEMBER TO EDIT NEXT AND PREVEIOUS NODE IF YOU UNCOMMENT THIS NODE!
@c @node Maps and elimination, Modules and their annihilator, Change of rings, Getting started
@c @subsection Maps and elimination
@c @cindex Maps and elimination


@c ------------------------------------------------------------------
@node Modules and their annihilator, Resolution and Ext groups, Change of rings, Getting started
@subsection Modules and their annihilator
@cindex Modules and and their annihilator
@sc{Singular} is able to calculate with modules over all the rings,
which can be defined as @code{basering}. A free module of rank @code{n}
is defined as follows:
@example
ring rr;
int n = 4;
freemodule(4);
@expansion{} _[1]=1*gen(1)
@expansion{} _[2]=1*gen(2)
@expansion{} _[3]=1*gen(3)
@expansion{} _[4]=1*gen(4)
typeof(_);
@expansion{} module
print(freemodule(4));
@expansion{} 1,0,0,0,
@expansion{} 0,1,0,0,
@expansion{} 0,0,1,0,
  @expansion{} 0,0,0,1 
@end example

There are two possibilities to define a module. First a submodule can be
defined by a generating set of vectors. Then this set of vectors, and the
module itself may be identified with the columns of matrix.
For that reason in @sc{Singular} matrices and modules may be interchanged.
@example
ring r =0,(x,y,z),dp;
module MD = [x,0,x],[y,z,-y];
matrix MM = MD;
print(MM);
@expansion{} x,-y,
@expansion{} 0,z, 
@expansion{} x,-y 
@end example
 
The second possibility, and this is what @sc{Singular} means when 
a @code{module} is defined, is to describe the module by the relations 
of the generators of a free module. To pass from  the first description
to the second is done with the command @code{syz}.
@example
syz(MD);
@expansion{} _[1]=x*gen(2)+y*gen(1)
@end example

We want to calculate as application the annihilator  of a given module.
Let M = Rk/U,  where U is our defining module of relations. 
@example
module U = [z3,xy2,x3],[yz2,1,xy5z+z3],[y2z,0,x3],[xyz+x2,y2,0],[xyz,x2y,1];
print(U);
@expansion{}
@end example

Then by definition
the annihilator of M is the ideal ann(M) = @{a | aM = 0 @} which is by the 
description of M the same as @{ a | aRk contained in U @}.
Hence we have to calculate using the command @code{quotient} the
quotient @{ a | a in U:Rk@}. 
@* The rank of the freemodule is determined by the 
choice of @code{U} and is the number of rows of the corresponding matrix.
This may be determined by the @code{nrows}. All we have to do now is to
apply the following statement.
@example
quotient(U,freemodule(nrows(U)));
typeof(_);
@expansion{} ideal
@end example

As this calculation may take a while, let us mesure the time. Reset
the timer and redo the example.
@example
timer =0;
ideal I = quotient(U,freemodule(nrows(U)));
timer;
@expansion{} 16
@end example
 

Therefore it is useful to simplify the input. In the case of a module the
command @code{prune} may be used first, which tries to find an isomorphic
module with smaller rank, i.e. the matrix has less rows.

@example
prune(U);
@expansion{}
timer=0;
I =  quotient(prune(U),freemodule(nrows(prune(U))));
timer;
@expansion{}  
@end example


@c ------------------------------------------------------------------
@node Resolution and Ext groups,  , Modules and their annihilator, Getting started
@subsection Resolution and Ext groups
@cindex Resolution and Ext groups
This final example in the introduction shows how to calculate the @code{n-th Ext} group of an ideal.
The ingredients to do this, are by the definition of @code{Ext} the following: calculate a (minimal) resolution
at least up to length @code{n}, apply the @code{Hom}-functor, and calculate the
@code{n-th} Homology group, so form the quotient of @code{ker} and @code{Im}
in the sequenze.
@* The corresponding commands in @sc{Singular} are first
the command @code{mres( ,n)} which calculates a minimal free resolution
with the standard basis method.

Here we mention that @sc{Singular} gives the possibility to inspect 
its calculation process. This can be enabled with the @code{option} command.
@example

  ring rr;      // the default ring in char 32003
  rr;
  @expansion{} //   characteristic : 32003
  @expansion{} //   number of vars : 3
  @expansion{} //        block   1 : ordering dp
  @expansion{} //                  : names    x y z 
  @expansion{} //        block   2 : ordering C
  ideal I = x4+x3y+x2yz,x2y2+xy2z+y2z2,x2z2+2xz3,2x2z2+xyz2;
  option(prot);
  resolution rs = mres(I,0);
  @expansion{} v4(3)s-s.s.s5(3)s6-s.s-s7(2)s-s-s
  @expansion{} product criterion:0 chain criterion:8
  @expansion{} (6)(5).(4).(3)..(2)..(1).[1]
  @expansion{} (7)(6)(5)(4).(3)(2).(1)[2]
  @expansion{}  // ....
@end example
Disable this protocol with
@example
option(prot);
@end example

When we enter the name of the calculated resolution, we get a pictorial
description of the resolution where the exponents denote the rank of the
free modules.
@example
rs;
@expansion{}   1       4       5       2       0
@expansion{} rr  <-- rr  <-- rr  <-- rr  <-- rr
@expansion{}  
@expansion{} 0       1       2       3       4
@end example


A single module in this resolution is obtained as usual with the brackets
@code{[ ]}.
@example
print(rs[3]);
@expansion{} y2z,  y3,    
@expansion{} -y2,  -y2,   
@expansion{} x+y-z,x+y-z, 
@expansion{} -2z,  x-y+4z,
@expansion{} -z,   -y+3z  
@end example


We continue with the translation into @sc{Singular} commands.
The @code{Hom} functor is given simply by transposing (hence dualizing)
the module or the corresponding matrix with the command @code{transpose}.
The image of the @code{n-1-th} map is generated by the columns themself. 
To calculate the kernel apply the command @code{syz} at the  @code{n-1-th}
transposed entry of the resolution.
Finally, the quotient is obtained by the command @code{modulo}, which
gives for two modules A= ker, B = im  a representing module of 
A/(A intersect B) in the usual way. 
As we have a chain complex this is obviously the
same as ker/im.
@* We collect these statements in this short procedure.
@example
proc Ext(int n, ideal I)
@{
  resolution rs = mres(I,n+1);
  module tAn    = transpose(rs[n+1]);
  module tAn_1  = transpose(rs[n]);
  module ext_n  = modulo(syz(tAn),tAn_1); 
  return(ext_n);
@}
@end example  

Now consider the following example:

@example
ring r5 = 32003,(a,b,c,d,e),dp;
ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
print(Ext(2,I));
@expansion{} 1,0,0,0,0,0,0,
@expansion{} 0,1,0,0,0,0,0,
@expansion{} 0,0,1,0,0,0,0,
@expansion{} 0,0,0,1,0,0,0,
@expansion{} 0,0,0,0,1,0,0,
@expansion{} 0,0,0,0,0,1,0,
@expansion{} 0,0,0,0,0,0,1 
Ext(3,I);   // too big to display here
@end example

Finally we mention, that  more general procs to calculate 
Ext groups are implemented in the library @code{homolog.lib}.
