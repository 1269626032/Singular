\input texinfo    @c -*-texinfo-*-
@comment %**start of header
@c ------------------------
@setfilename singular.hlp
@settitle Singular Reference Manual
@iftex
@afourpaper
@finalout
@end iftex
@comment %**end of header
@c redirect funtion index:
@c @syncodeindex fn cp
@c ------------------------
@set singularmanual 1
@set VERSION 1.2
@c ------------------------
@ifinfo
this is the texinfo file describing Singular (version @value{VERSION})
@end ifinfo
@c
@titlepage
@sp 2
@center @titlefont{Singular}
@sp 2
@center A Computer Algebra System for Commutative Algebra, Algebraic Geometry
@center and Singularity Theory
@sp 5
@center @titlefont{Reference Manual}
@center Version @value{VERSION}
@sp 2
@center Singular is created and its development is directed and coordinated by
@center G.-M. Greuel, G. Pfister and H. Schoenemann
@sp 2
@center with contributions by
@center O. Bachmann, W. Decker, H. Grassmann, B. Martin, M. Messollen,
@center W. Neumann, T. Nuessler, W. Pohl, T. Siebert, R. Stobbe, T. Wichmann
@sp 2
@author Fachbereich Mathematik
@author und
@author Zentrum fuer Computeralgebra
@author Universitaet Kaiserslautern
@author D-67653 Kaiserslautern
@end titlepage
@c ----------------------------------------------------------------------------
@node Top, Preface, (dir), (dir)
@ifinfo
q:quit, m:menu item, n:next node, p:previous node, u:up, g:goto node
@sp 1
@center Singular - Reference Manual
@center Version @value{VERSION}
@center A Computer Algebra System for Singularity Theory, Algebraic Geometry
@center  and Commutative Algebra
@sp 2
@center University of Kaiserslautern
@center Department of Mathematics
@center and
@center Centre for Computer Algebra
@end ifinfo
@menu
* Preface::
* Introduction::
* Getting started::
* Command Syntax::
* Expressions::
* Commands::
* procedures and Libraries::
* Tricks and Pitfalls::
* Examples::
* Library Index::
* Library Function Index::
* Index::
@end menu
@c ----------------------------------------------------------------------------
@node Preface, Introduction, Top, Top
@chapter Preface
@cindex Preface

@include copyright.tex
@c ---------------------------------------
@node Introduction, Getting started, Preface, Top
@chapter Introduction
@cindex Introduction


@sc{Singular} is a computer algebra system designed for special needs
in commutative algebra and algebraic geometry, with special features for
singularity theory.
@sc{Singular} can compute with ideals and modules
generated by polynomials or polynomial vectors over polynomial
rings or, more generally, over the localization of a
polynomial ring with respect to any ordering on the set of monomials
which is compatible with the semigroup structure.
There is also the possibility to do standard basis calculations and
hence computations of resolutions in modules over
supercommutative superalgebras
and Weyl algebras if @sc{Singular} is compiled with the appropriate options.
Hence, there is a wide range of applications in local and global algebraic
geometry (but @sc{Singular} is not limited to these areas).

We tried to set up the user interface as a consistent and flexible
language:
@enumerate
@item commands end with a semicolon (@code{;}), they are not
bound to one line
@item types of objects are numbers, polynomials, ideals, vectors, modules,
(polynomial) matrices, maps and integers, integer vectors and matrices, strings, lists,
(communication) links
@item there is an automatic type conversion whenever it is useful
@item the system is capable of executing procedures
with parameters, local variables
and return values
@item there are libraries of useful functions from several areas
@item this manual (and other documenation)
is also available as online information
@c @item @dots{} and much more documentation
@end enumerate
@c --------------------------------------
@section Background

@sc{Singular} performs algebraic manipulations on numbers, polynomials, ideals,
rings, modules, matrices and maps between rings.
The baserings are polynomial rings or localizations hereof over a field
(e.g finite fields, the rationals, reals, algebraic extensions,
transcendental extensions) or quotient rings with respect to an ideal.
The main objects in @sc{Singular} are ideals and modules,
one of the main algorithms is a general standard basis
algorithm with respect to
any semigroup ordering. This includes Buchberger's algorithm
(if the ordering is a wellordering) and Mora's algorithm (if the ordering is
a tangent cone ordering) as special cases.
Other algorithms include computing modules of syzygies,
finite free resolutions, Hilbert-Poincare series, etc.
The first implementation of the tangent cone algorithm
was done in Modula 2 at the Humboldt
University of Berlin by Gerhard Pfister and Hans
@tex
 Sch\"onemann
@end tex
@ifinfo
 Schoenemann
@end ifinfo
 in 1986.
@c It was mainly able to compute certain special invariants of singularities.
In September 1991 it became a joint project of the Humboldt University of
Berlin and the University of Kaiserslautern.
Since 1994 the development of @sc{Singular} is continued at Kaiserslautern.
@c The goal was to have all the
@c well known algorithms for computing in
@c nonhomogeneous ideals in polynomial and powers series rings.
The need for a new system arose from
the investigation of mathematical problems
coming from singularity theory which none of the existing systems
were able to compute.
Later we included an algorithm for multivariate polynomial factorization
in order to perform efficiently primary decomposition of ideals.
The need for solving big systems of polynomial equations, orginating
from practical problems in microelectronics, let us implement FGLM-techniques;
further algorithms for this purpose are to be implemented.
Thus, we hope to offer a useful system
for dealing with local and global computational aspects
of systems of polynomial equations.

For a description of the basic algorithms, together with many examples
and comparisons, cf. Grassmann, H.; Greuel, G.-M.; Martin, B.; Neumann,
W.; Pfister, G.; Pohl, W.;
@tex
Sch\"onemann,
@end tex
@ifinfo
 Schoenemann
@end ifinfo
 H.; Siebert, T.:  On an
implementation of standard bases and syzygies in  @sc{Singular},
Proceedings of the Workshop  Computational Methods in Lie theory in AAECC (1995).

For a mathematical background, in particular for general (global, local
or mixed) orderings and resolutions, cf. Greuel, G.-M.; Pfister, G.:
Advances and improvements in the theory of standard bases and
syzygies, Arch. d. Math. 63(1995)

@c Both papers are available as Latex files via  anonymous ftp from
@c @code{ftp://www.mathematik.uni-kl.de/pub/Math/Singular}.

@c ---------------------------------------
@section Notations

@code{Typewriter style} is used for @sc{Singular}  input and output,
@expansion{} in front of a line indicates output. @code{//} makes
the rest of the line a comment.
@c ---------------------------------------
@node Getting started,Command Syntax,Introduction, Top
@include start.tex
@c ---------------------------------------
@node Command Syntax,Expressions,Getting started, Top
@chapter Command Syntax
@cindex Command Syntax

@menu
* How to enter and exit::
* General syntax::
* Singular prompt and error recovery::
* Special characters::
* Usage of Names::
* Monomial orderings::
@end menu
@c -------------------------------------------------------------------------
@c @node How to enter and exit -- command line options,General syntax,,Command Syntax
@node How to enter and exit ,General syntax,,Command Syntax
@section How to enter and exit

@*To start @sc{Singular}, enter @code{Singular} at the system prompt.
@*You will get a header with the version name, the compilation date
and a short remark how to get help on
@sc{Singular}.
Enter @code{help;} to get the online manual at the @sc{Singular} prompt
@code{>}.
Commands are always ended with a @code{;} (semicolon) and @code{<ENTER>}.
Spaces and commas are always considered as separators. 
@*To exit @sc{Singular} enter @code{quit;}, @code{exit;} or @code{$}.


@sc{Singular} may also be started with command-line options and with 
filenames as arguments. More generally, the synopsis of @sc{Singular} is
@*@code{  Singular  [options] [file1 [file2 ...]] }
@*with the options (which can be given in both, their long and
short format):
@table @asis

@item @code{-b},@code{--batch} 
Run in MP batch mode. Opens a TCP/IP connection with host specified by
@code{--MPhost} at the port specified by @code{--MPport}. Input is read
from and output is written to this connection in the MP format.

@item @code{-h},@code{--help} 
Print a short help message and exit.

@item @code{-q},@code{--quiet}
Do not print start-up banner and warnings and redirect stderr (all error
messages)  to stdout (normal output channel).

@item @code{-t},@code{--no-tty} 
Do not redefine the terminal characteristics (useful for batch
processes, see @ref{Editing input}).  

@item @code{-v},@code{--version}             
Print extended information about the version and configuration of
@sc{Singular}  (used optional parts, compilation date, start of random
generator etc.). This information should be included if a user reports
an error to the authors.

@item @code{-e},@code{--echo[=VAL]} 
Set value of variable @code{echo} to @code{VAL} (integer in the range 0
.. 9). Without an argument, @code{echo} is set to 1, which echoes all
input coming from a file. By default, the value of @code{echo} is 0. See
also @ref{System variables}.

@item @code{-c},@code{--execute=STRING} 
Execute @code{STRING} as a (sequence) of @sc{Singular} commands on
start-up after the @code{.singularrc} file is executed, but prior to
executing the files given on the command line.

@item @code{-r},@code{--random=SEED}         
Seed (i.e., set initial value of) pseudo random generator with integer
(integer) @code{SEED} (integer). If this option is not given, then the
random generated is seeded with a time-based @code{SEED} (e.g., the
number of seconds since January, 1, 1970, on Unix systems).

@item @code{-u},@code{--user-option=STRING}
Returns @code{STRING} on @code{system("--user-option")}. This is useful
for passing arbitrary arguments (like filenames) from the command line to 
the @sc{Singular} interpreter (i.e. top-level of @sc{Singular}).

@item @code{--no-stdlib}
Do not load the library @code{standard.lib} on start-up. By default,
this library is loaded on start-up.

@item @code{--no-rc}               
Do not execute the @code{.singularrc} file on start-up. By default,
@sc{Singular} searches first in the current directory and then in the
home directory of the user for a file named @code{.singularrc}. If it is 
found, then it is executed after the library @code{standard.lib} is
loaded and prior to executing the string specified by
@code{--user-option}.

@item @code{--min-time=SECS}
If the @code{timer} variables is set, do only report times larger than
@code{SECS} seconds (@code{SECS} needs to be a floating point number
greater than 0). By default, this value is set to 0.5 (i.e., half a
second).

@item @code{--MPport=PORT} 
Use @code{PORT} as default port number for MP connections (whenever not
further specified) . This option is mandatory when the @code{--batch}
option is given. See also @ref{MPtcp links}.

@item @code{--MPhost=HOST}
Use @code{HOST} as default host for MP connections (whenever not
further specified) . This option is mandatory when the @code{--batch}
option is given. See also @ref{MPtcp links}.

@item @code{--ticks-per-sec=TICKS} 
Sets unit of timer to @code{TICKS} per second (i.e. the value reported by 
the @code{timer} variable multiplied by @code{TICKS} gives the time in
seconds.By default, this value is 1.

@end table
@*On start-up, @sc{Singular} 
@enumerate
@item 
loads the library @code{standard.lib} (provided the @code{--no-stdlib}
was not given)

@item
searches the current directory and then the
home directory of the user for a file named @code{.singularrc} and
executes it, if found (provided the @code{--no-rc} options was not
given)

@item 
executes the files @code{file1}, @code{file2} ...  (given on the command
line) in that order. 
@end enumerate

Unless otherwise specified, @sc{Singular} locates all (data) files and
libraries by first searching for them in the current working directory,
and then by searching through all the directories specified by the
environment variable @code{SINGULARPATH} (@code{SPATH} on DOS-based
systems) and finally by searching through some default directories
(e.g., @code{/usr/local/share/Singular}).

@c --------------------------------------------------------------------------
@node General syntax,Singular prompt and error recovery,How to enter and exit,Command Syntax
@section General syntax
@cindex General syntax
@cindex =
Every object in @sc{Singular} has a type, a value, a (possibly empty) name
and a (possibly empty) attribute list
(see @ref{typeof}; @ref{nameof}; @ref{attrib}).

@sc{Singular} output in examples is indicated with the sign @expansion{}
in front of it.

@strong{Example:}
@example
@c example
  int i=3;
  typeof(i); // type
  nameof(i); // name
  i;         // value
  attrib(i); //attributes
@c example
@end example
@*All input is case-sensitive.
@*Everything is built around expressions.
@*The general form of a command is (with optional parts in square brackets):
@itemize @bullet
@item
a @strong{definition}:
@*   type_name name [ @code{=} expression ] @code{;}
@* @strong{Example:}
@example
  ring r;              // creates the default ring
  poly f = x^2 + y^3 ; // define polynomial f=x^2+y^3
  poly g=xy+z2;        // define polynomial g=x*y+z^2
  ideal I = f,g;       // ideal generated by f and g
  matrix m[3][3];      // creates a 3 x 3 zero matrix
  int i=2;             // define the integer i and set i to 2
@end example
@item
an @strong{assignment}:
@*   name  @code{=} expression @code{;}
@*   name @code{=} expression_list @code{;}
@* @strong{Example:}
@example
  f = x^2 + y^2 ;      //overwrites the old value of f
  I = jacob(f);
  f,g = I[1],x^2+y^2 ; //overwrites the old values of f and g
@end example
@item
a @strong{command}:
@*   command_name [ @code{(} argument_list @code{)} ] @code{.}
@* @strong{Example:}
@example
  degree(I);
@end example
@item
a @strong{print command}:
@*   expression @code{;}
@*   @code{type} name @code{;}
@*   @code{print(} expression @code{);}
@* @strong{Example:}
@example
@c example
  int i=2; i;
  type i;              // name [ level ] type value
  print(i);
@c example
@end example
@end itemize
@c ---------------------------------------
@node Singular prompt and error recovery,Special characters,General syntax,Command Syntax
@section Singular prompt and error recovery
@cindex Singular prompt and error recovery
@cindex prompt
@cindex error recovery
The @sc{Singular} prompt @code{>}
asks the user for input of a command, while the prompt @code{.}
asks the user for input of missing parts of a command (remember the
semicolon @code{;} at the end of every command). If your input
is erroneous @sc{Singular} may miss the semicolon.
(It may be missed because @code{Singular} needs first a @code{"} or @code{@}}.)
On the other hand additional @code{;} will not harm @sc{Singular}:
extra semicolons are interpreted as empty statements.
@c -----------------------------------------
@node Special characters,Usage of Names,Singular prompt and error recovery,Command Syntax
@section Special characters
@cindex Special characters
The following characters/operators have special meanings:
@table @asis
@item @code{!}
synonymous to @code{not}
@item @code{&&}
synonymous to @code{and}
@item @code{||}
synonymous to @code{or}
@item @code{<>},@code{!=}
not equal: e.g. @code{if (i<>j)...}
@item @code{>=}
bigger or equal
@item @code{>}
bigger
@item @code{<=}
smaller or equal
@item @code{<}
smaller, but also used for file input (@ref{filecmd})
@item @code{=}
assignment: e.g. @code{int i=4711;}
@item @code{==}
equal: e.g. @code{if (i==j)...}
@item  @code{[}, @code{]}
indices in strings, integer vectors, ideals, matrices, polynomials and lists
and to build (poly) vectors: e.g. @code{ s[3], m[1,3], i[1..3],[f,g+x,0,0,1]}
@item  @code{(}, @code{)}
in expressions, for indexed names and for argument lists
@item  @code{+}
addition
@item  @code{-}
subtraction
@item  @code{*}
multiplication
@item  @code{/}
division for numbers (coefficients of polynomials) and polynomials
@item  @code{%}
integer modulo
@item  @code{^}, @code{**}
power, exponentiation
@item  @code{@@}
is a letter
@item  @code{#}
the reserved name of a list of not specified parameters in procedures
(see @ref{procedures and Libraries}).
@item  @code{"}
to start and end string constants
@item  @code{`}
to start and end name substitution
@item  @code{?}
is equivalent to @code{help}
@item  @code{;}
the separator for statements
@item  @code{,}
the separator for expression lists and function arguments
@item  @code{//}
makes the rest of the line a comment
@item  @code{\}
escape character for @code{"} within strings (see @ref{string expression})
@item  @code{..}
construct an intvec from start and end (see @ref{intvec expression})
@item  @code{::}
access identifiers within packages (complete name is package_name::identifier)
@item  @code{$}
ends @code{Singular}
@end table
@c ---------------------------------------
@node  Usage of Names, Monomial orderings, Special characters, Command Syntax
@section Usage of Names
@menu
* Reserved names::
* User defined names::
* Names in proc::
@end menu
@c ---------------------------------------
@node Reserved names, User defined names, ,Usage of Names
@subsection Reserved names

The following names are predefined commands or variables
and cannot be used otherwise:@*
@code{alternating},
@code{and},
@code{attrib},
@code{bareiss},
@code{basering},
@code{break},
@code{char},
@code{char_series},
@code{charstr},
@code{cleardenom},
@code{close},
@code{continue},
@code{contract},
@code{coef},
@code{coeffs},
@code{dbprint},
@code{def},
@code{defined},
@code{deg},
@code{degBound},
@code{degree},
@code{delete},
@code{det},
@code{diff},
@code{dim},
@code{div},
@code{dring},
@code{dump},
@code{echo},
@code{else},
@code{eval},
@code{exit},
@code{execute},
@code{export},
@code{extgcd},
@code{facstd},
@code{factorize},
@code{fetch},
@code{fglm},
@code{find},
@code{finduni},
@code{for},
@code{forif},
@code{freemodule},
@code{gcd},
@code{gen},
@code{getdump},
@code{help},
@code{hilb},
@code{homog},
@code{ideal},
@code{if},
@code{imap},
@code{indepSet},
@code{insert},
@code{int},
@code{interred},
@code{intersect},
@code{intmat},
@code{intvec},
@code{jacob},
@code{jet},
@code{kbase},
@code{keepring},
@code{kill},
@code{killattrib},
@code{koszul},
@code{lead},
@code{leadcoef},
@code{leadexp},
@code{LIB},
@code{lift},
@code{liftstd},
@code{link},
@code{list},
@code{listvar},
@code{map},
@code{matrix},
@code{maxideal},
@code{memory},
@code{minbase},
@code{minor},
@code{minpoly},
@code{minres},
@code{mod},
@code{module},
@code{monitor},
@code{mres},
@code{mstd},
@code{mult},
@code{multBound},
@code{nameof},
@code{names},
@code{ncols},
@code{newline},
@code{NF},
@code{noether},
@c @code{NOT},
@code{not},
@code{npars},
@code{nrows},
@code{number},
@code{nvars},
@code{open},
@code{or},
@code{ord},
@code{ordstr},
@code{option},
@code{package},
@code{pagelength},
@code{pagewidth},
@code{par},
@code{parameter},
@code{pardeg},
@code{parstr},
@code{pause},
@code{poly},
@code{preimage},
@code{prime},
@code{print},
@code{printlevel},
@code{proc},
@code{prune},
@code{qhweight},
@code{qring},
@code{quit},
@code{quote},
@code{quotient},
@code{random},
@c @code{rank},
@code{read},
@code{reduce},
@code{regularity},
@code{res},
@code{reservedName},
@code{resolution},
@code{resultant},
@code{return},
@code{ring},
@code{rtimer},
@code{rvar},
@code{setring},
@code{short},
@code{simplify},
@code{size},
@code{sortvec},
@code{sres},
@code{status},
@code{std},
@code{string},
@code{subst},
@code{system},
@code{syz},
@code{test},
@code{timer},
@code{TRACE},
@code{trace},
@code{transpose},
@code{type},
@code{typeof},
@code{var},
@code{varstr},
@code{vdim},
@code{vector},
@code{verbose},
@code{voice},
@code{wedge},
@code{weight},
@code{while},
@code{whileif},
@code{write}.

You  get a list of the reserved names by @code{reservedName();},
see @ref{reservedName}.
@c ---------------------------------------
@node User defined names, Names in proc, Reserved names, Usage of Names
@subsection User defined names

User defined global names start with a letter and consist only of letters and
digits.
They must not coincide with reserved names (keywords) and should not interfere
with monomials. All names are case sensitive.
Indexed names are built as
name followed by @code{(} int_expression @code{)}.
A list of indexed names can be built as a name followed by
@code{(} int_expression @code{)}.
@example
@c example
  ring R;
  int jindex=3;
  ideal j(3);
  ideal j(jindex);     // is equivalent with the above
  ideal j(2)=x;
  j(2..3);
@c example
@end example
@c ---------------------------------------
@node Names in proc, , User defined names, Usage of Names
@subsection Names in proc
@cindex Names in proc
@cindex local names

All variables are local to the procedure they are defined in.
These names cannot interfere with names in other
proc and are automatically deleted after having executed
the proc.
Names can be made global by @code{export} (see @ref{export}).
These global names will not be deleted automatically.
@example
  proc xxx
  @{
    int k=4;        //defines a local variable k
    int result=k+2;
    export result;  //defines the global variable "result".
  @}
@end example
If you type @code{listvar(all);} after having executed a proc you will
see that the variable @code{result} is still there while @code{k}
has been deleted.

The parameters of a proc can be accessed by their position, i.e.
@code{#[1]} for parameter 1 up
to the number of arguments.
Procedures can define argument lists, see @ref{procedures and Libraries}.
While interpreting a proc without a parameter list
there is a special variable:
@code{#} (of type list) holds all arguments,
@code{size(#)} is the number of arguments the proc was called with.
@example
  if (size(#) > 0)  @{ int i=#[size(#)]; @}
  //assign the last argument to the local variable i
@end example
Internally parameters and local variables are stored using
the nesting level,
you will see the nesting level
if you do a @code{listvar();} command inside a proc.
@c ---------------------------------------------------------------------------
@node Monomial orderings, , Usage of Names, Command Syntax
@section Monomial orderings
@cindex Monomial orderings
@tex
A monomial ordering (term ordering) on $K[x_1, \ldots, x_n]$ is
a total ordering $<$ on the
set of monomials (power products) $\{x^\alpha|\alpha \in \bf{N}^n\}$
which is compatible with the
natural semigroup structure, i.e.\ $x^\alpha < x^\beta$ implies $x^\gamma
x^\alpha < x^\gamma x^\beta$ for any $\gamma \in \bf{N}^n$.
We do not require
$<$ to be  a wellordering.
@end tex
@ifinfo
A monomial ordering (term ordering) on $[x_1, ..., x_n] is
a total ordering < on the
set of monomials (power products) @{x^a | a in N^n@}
which is compatible with the
natural semigroup structure, i.e. x^a < x^b implies x^c*x^a < x^c*x^b for any
c in N^n.
We do not require
< to be  a wellordering.
@end ifinfo
See the literature cited in @ref{Introduction}, (section 'Background').

@sc{Singular} offers the following monomial orderings which are implemented
in an effective way:
@menu
* global orderings:: lp, dp, wp, Dp, Wp.
* local orderings:: ls, ds, ws, Ds, Ws.
* module orderings:: c, C.
* matrix orderings:: M.
* product orderings::
* extra weight vector:: a.
@end menu
@iftex
@itemize @bullet
@item
global orderings or p-orderings: @code{lp, dp, Dp, wp, Wp} (p refers to polynomial ring)
@item
local orderings or s-orderings: @code{ls, ds, Ds, ws, Ws} (s refers to series ring)
@item
module orderings @code{c, C} (ordering of the components of a vector)
@item
matrix orderings @code{M} (may be used to define any allowed ordering)
@item
any of the above orderings may be combined to yield product or
block orderings.
@item
ordering @code{a} (inserting an extra weight vector)
@end itemize
@end iftex

@tex
Global orderings are wellorderings (i.e.\ $1 < x_i$ for each variable
$x_i$), local orderings satisfy $1 > x_i$ for each variable.   If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not wellorderings.

If $K$ is the groundfield, $x = (x_1, \ldots, x_n)$ the
variables and $<$ a monomial ordering, then {\bf Loc K}$[x]$ denotes the
localization of $K[x]$ with respect to the multiplicatively closed set $\{1 +
g \mid g = 0$ or $g \in K[x]\backslash \{0\}$ and $L(g) < 1\}$.   $L(g)$
denotes the leading monomial of $g$, i.e.\ the biggest monomial of $g$ with
respect to $<$.   The result of any computation which uses standard basis
computations has to be interpreted in {\bf Loc K}$[x]$ (like @code{std, syz, res,
mres, sres, mult, degree, dim, hilb, mstd}, etc.).
@end tex
@ifinfo
Global orderings are wellorderings (i.e.1 < x_i for each variable
x_i), local orderings satisfy 1 > x_i for each variable.
If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not wellorderings.

If K is the groundfield, x = (x_1, @dots{}, x_n) the
variables and < a monomial ordering, then Loc K[x] denotes the
localization of K[x] with respect to the multiplicatively closed set @{1 +
g | g = 0 or g in K[x]\@{0@} and L(g) < 1@}.   L(g)
denotes the leading monomial of g, i.e. the biggest monomial of g with
respect to <.   The result of any computation which uses standard basis
computations has to be interpreted in Loc K[x] (like @code{std, syz, res,
mres, sres, mult, degree, dim, hilb, mstd}, etc.).
@end ifinfo
@c --------------------------------------------------------------------------
@node global orderings, local orderings, , Monomial orderings
@subsection global orderings
@cindex global orderings

For all these orderings: Loc K[x] = K[x]

@table @asis
@item lp:
lexicographical ordering.
@*
@ifinfo
x^a < x^b  <==> there is an i,  1 <= i <= n :
@* a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@end ifinfo
@tex
$x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
\alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i <
\beta_i$.
@end tex
@item dp:
degree reverse lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) < deg(x^b), where deg(x^a) = a_1 + @dots{} + a_n,
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_n = b_n, @dots{}, a_(i+1) = b_(i+1), a_i > b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{$x^\alpha < x^\beta \Leftrightarrow $}$ \deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{$x^\alpha < x^\beta \Leftrightarrow$}$\alpha_n = \beta_n,
    \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i$.
@end tex
@item Dp:
degree lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) < deg(x^b)
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\alpha_1 = \beta_1,
    \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i$.
@end tex
@item wp:
weighted reverse lexicographical ordering.
@*
@ifinfo
 wp(w_1, @dots{}, w_n), w_i
@end ifinfo
@tex
${\tt wp}(w_1, \ldots, w_n),\; w_i$
@end tex
 positive integers,
 is defined as @code{dp}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@item Wp:
weighted lexicographical ordering.
@*
@ifinfo
 Wp(w_1, @dots{}, w_n), w_i
@end ifinfo
@tex
${\tt Wp}(w_1, \ldots, w_n),\; w_i$
@end tex
 positive integers,
 is defined as @code{Dp}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@end table
@c --------------------------------------------------------------------------
@node local orderings, module orderings, global orderings, Monomial orderings
@subsection local orderings
@cindex local orderings

For ls, ds, Ds and, if the weights are positive integers, also for ws and
Ws,  we have
@ifinfo
Loc K[x] = K[x]_(x),
@end ifinfo
@tex
$Loc\, K[x] = K[x]_{(x)}$,
@end tex
 the localization of K[x] at the
maximal ideal
@ifinfo
 (x_1, @dots{}, x_n).
@end ifinfo
@tex
\ $(x_1, ..., x_n)$.
@end tex

@table @asis
@item ls:
negative lexicographical ordering.
@*
@ifinfo
x^a < x^b  <==> there is an i,  1 <= i <= n :
@* a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i > b_i.
@end ifinfo
@tex
$x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
\alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i >
\beta_i$.
@end tex
@item ds:
negative degree reverse lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) > deg(x^b), where deg(x^a) = a_1 + @dots{} + a_n,
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_n = b_n, @dots{}, a_(i+1) = b_(i+1), a_i > b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow$ } $\deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\alpha_n = \beta_n,
    \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i$.
@end tex
@item Ds:
negative degree lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) > deg(x^b)
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{$ x^\alpha < x^\beta \Leftrightarrow$ }$ \deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{$ x^\alpha < x^\beta \Leftrightarrow$ } $\alpha_1 = \beta_1,
    \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i$.
@end tex
@item ws:
(general) weighted reverse lexicographical ordering.
@*
@ifinfo
 ws(w_1, @dots{}, w_n), w_1
@end ifinfo
@tex
${\tt ws}(w_1, \ldots, w_n),\; w_1$
@end tex
 a nonzero integer,
@ifinfo
w_2,@dots{},w_n
@end ifinfo
@tex
$w_2,\ldots,w_n$
@end tex
 any integer (including 0),
 is defined as @code{ds}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@item Ws:
(general) weighted lexicographical ordering.
@*
@ifinfo
 Ws(w_1, @dots{}, w_n), w_1
@end ifinfo
@tex
${\tt Ws}(w_1, \ldots, w_n),\; w_1$
@end tex
 a nonzero integer,
@ifinfo
w_2,@dots{},w_n
@end ifinfo
@tex
$w_2,\ldots,w_n$
@end tex
 any integer (including 0),
 is defined as @code{Ds}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@end table

@c --------------------------------------------------------------------------
@node module orderings, matrix orderings, local orderings, Monomial orderings
@subsection module orderings
@cindex module orderings

@sc{Singular} offers also orderings on the set of ``monomials''
@ifinfo
@{ x^a*gen(i) | a in N^n, 1 <= i <= r @} on Loc K[x]^r = Loc K[x]gen(1)
+ @dots{} + Loc K[x]gen(r), where gen(1), @dots{}, gen(r) denote the canonical
generators of Loc K[x]^r, the r-fold direct sum of Loc K[x].
@end ifinfo
@tex
$\{ x^a gen(i) | a \in N^n, 1 \leq i \leq r \}$ on Loc K$[x]^r$ = Loc K[x]$gen(1)
+ \ldots +$Loc K[x]$gen(r)$, where $gen(1), \ldots, gen(r)$ denote the canonical
generators of Loc K[x]$^r$, the r-fold direct sum of Loc K[x].
@end tex

We have two possibilities, either to give priority to the component of a
vector of
@ifinfo
Loc K[x]^r
@end ifinfo
@tex
\ $Loc K[x]^r$\
@end tex
or (which is the default in @sc{Singular}) to give priority
to the coefficients.
The orderings @code{(<,c)} and @code{(<,C)} give priority to the coefficients;
@code{(c,<)} and @code{(C,<)} give priority to the components.
@*Let < be any of the monomial orderings of Loc K[x] as above.

@table @asis
@item (<,C):
@ifinfo
<_m = (<,C) denotes the module ordering (giving priority to the coefficients):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* x^a < x^b
@* or
@* x^a = x^b  and  i < j.
@end ifinfo
@tex
$<_m = (<,C)$ denotes the module ordering (giving priority to the coefficients):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow x^\alpha < x^\beta$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $x^\alpha = x^\beta $ and $ i < j$.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), ds;
  // the same as ring r = 0, (x,y,z), (ds, C);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example

@item (C,<):
@ifinfo
<_m = (C, <) denotes the module ordering (giving priority to the
component):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* i<j
@* or
@* i = j and x^a < x^b.
@end ifinfo
@tex
$<_m = (C, <)$ denotes the module ordering (giving priority to the component):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad   $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow i < j$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{$\quad \quad x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $ i = j $ and $ x^\alpha < x^\beta $.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), (C,lp);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example

@item (<,c):
@ifinfo
<_m = (<,c) denotes the module ordering (giving priority to the coefficients):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* x^a < x^b
@* or
@* x^a = x^b  and  i > j.
@end ifinfo
@tex
$<_m = (<,c)$ denotes the module ordering (giving priority to the coefficients):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow x^\alpha < x^\beta$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $x^\alpha = x^\beta $ and $ i > j$.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), (lp,c);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example

@item (c,<):
@ifinfo
<_m = (c, <) denotes the module ordering (giving priority to the
component):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* i>j
@* or
@* i = j and x^a < x^b.
@end ifinfo
@tex
$<_m = (c, <)$ denotes the module ordering (giving priority to the component):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad   $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow i > j$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{$\quad \quad x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $ i = j $ and $ x^\alpha < x^\beta $.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), (c,lp);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example
@end table

@ifinfo
The output of a vector v in K[x]^r with components v_1,
@dots{}, v_r has the format v_1 * gen(1) + @dots{} + v_r * gen(r)
@end ifinfo
@tex
The output of a vector $v$ in $K[x]^r$ with components $v_1,
\ldots, v_r$ has the format $v_1 * gen(1) + \ldots + v_r * gen(r)$
@end tex
unless the ordering starts with @code{c}.
@ifinfo
In this case a vector will be written as [v_1, @dots{}, v_r].
@end ifinfo
@tex
In this case a vector will be written as $[v_1, \ldots, v_r]$.
@end tex
In all cases @sc{Singular} can read the
input in both formats.

@c --------------------------------------------------------------------------
@node matrix orderings, product orderings, module orderings,Monomial orderings
@subsection matrix orderings
@cindex matrix orderings

Let M be an invertible n x n matrix with integer coefficients and
@ifinfo
M_1, @dots{}, M_n
@end ifinfo
@tex
M$_1, \ldots,$ M$_n$
@end tex
 the rows of M.

The M-ordering < is the following:
@ifinfo
x^a < x^b <==> there exists an i: 1 <= i <= n :
M_1*a = M_1*b, @dots{}, M_(i-1)*a = M_(i-1)*b, M_i*a < M_i*b.
@end ifinfo
@tex
$x^a < x^b \Leftrightarrow$  there exists an $i: 1 <= i <= n :$
M$_1*a = $M$_1*b, \ldots, $M$_{i-1}*a = $M$_{i-1}*b$ and M$_i*a < $M$_i*b$.
@end tex

Thus,
@ifinfo
x^a < x^b
@end ifinfo
@tex
$x^a < x^b$
@end tex
if and only if M*a is smaller than M*b
with respect to the lexicographical ordering.

It is known that any monomial ordering can be represented by a matrix M in
GL(n,R), but, of course, only integer coefficients are of relevance in
practice.

The following matrices represent (for 3 variables) the global and
local orderings defined above (note that the matrix is not uniquely determined
by the ordering):

@ifinfo
@table @asis
@item lp:
 1   0   0
@* 0   1   0
@* 0   0   1
@item dp:
 1   1   1
@* 0   0  -1
@* 0  -1   0
@item Dp:
 1   1   1
@* 1   0   0
@* 0   1   0
@item wp(1,2,3):
 1   2   3
@* 0   0  -1
@* 0  -1   0
@item Wp(1,2,3):
 1   2   3
@* 1   0   0
@* 0   1   0
@item ls:
-1   0   0
@* 0  -1   0
@* 0   0  -1
@item ds:
-1  -1  -1
@* 0   0  -1
@* 0  -1   0
@item Ds:
-1  -1  -1
@* 1   0   0
@* 0   1   0
@item ws(1,2,3):
-1  -2  -3
@* 0   0  -1
@* 0  -1   0
@item Ws(1,2,3):
-1  -2  -3
@* 1   0   0
@* 0   1   0
@end table
@end ifinfo
@tex

lp:
$\left(\matrix{
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 0 & 0 & 1 \cr
 }\right)$
\quad dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

ls:
$\left(\matrix{
-1 & 0 & 0 \cr
 0 &-1 & 0 \cr
 0 & 0 &-1 \cr
 }\right)$
\quad ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$
@end tex

Product orderings represented by  a matrix:

@ifinfo
@table @asis
@item (dp(3), wp(1,2,3)):
1  1  1  0  0  0
@*0  0  -1  0  0  0
@*0  -1  0  0  0  0
@*0  0  0  1  2  3
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@item (Dp(3), ds(3)):
1  1  1  0  0  0
@*1  0  0  0  0  0
@*0  1  0  0  0  0
@*0  0  0  -1  -1  -1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@end table
@end ifinfo
@tex
@table @asis
@item (dp(3), wp(1,2,3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@item (Dp(3), ds(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@end table
@end tex

Orderings with extra weight vector (see below) represented by  a matrix:

@ifinfo
@table @asis
@item (dp(3), a(1,2,3),dp(3)):
1  1  1  0  0  0
@*0  0  -1  0  0  0
@*0  -1  0  0  0  0
@*0  0  0  1  2  3
@*0  0  0  1  1  1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@item (a(1,2,3,4,5),Dp(3), ds(3)):
1  2  3  4  5  0
@*1  1  1  0  0  0
@*1  0  0  0  0  0
@*0  1  0  0  0  0
@*0  0  0  -1  -1  -1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@end table
@end ifinfo
@tex
@table @asis
@item (dp(3), a(1,2,3),dp(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  1&  1&  1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@item (a(1,2,3,4,5),Dp(3), ds(3)):
$\left(\matrix{
1&  2&  3&  4&  5&  0 \cr
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0 & -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@end table
@end tex

@*@strong{Example}:
@example
@c example
  ring r = 0, (x,y,z), M(1, 0, 0,
                         0, 1, 0,
                         0, 0, 1);
@c example
@end example
@*which may also be written as:
@example
@c example
  intmat m[3][3]=1, 0, 0, 0, 1, 0, 0, 0, 1;
  m;
  ring r = 0, (x,y,z), M(m);
  r;
@c example
@end example

If the ring has n variables and the matrix contains less than n x n entries
an error message is given, if there are more entries,
the last ones will be ignored.

@strong{WARNING:} @sc{Singular}
does not check whether the matrix has full rank.   In such a case some
computations might not terminate, others might give a nonsense result.

Having these matrix orderings @sc{Singular} can compute standard bases for
any monomial ordering which is compatible with the natural semigroup structure.
In practice the global and local orderings together with block orderings should be
sufficient in most cases. These orderings are faster than the corresponding
matrix orderings, since evaluating a matrix product is time consuming.

@c --------------------------------------------------------------------------
@node product orderings, extra weight vector, matrix orderings, Monomial orderings
@subsection product orderings
@cindex product orderings

Let
@ifinfo
x = (x_1, @dots{}, x_n) = x(1..n) and y = (y_1, @dots{}, y_m) =
y(1..m)
@end ifinfo
@tex
$x = (x_1, \ldots, x_n) = x(1..n)$ and $y = (y_1, \ldots, y_m) =
y(1..m)$
@end tex
 be two ordered sets of variables,
@ifinfo
<_1 a monomial
ordering on Loc K[x] and <_2 a monomial ordering on Loc K[y].   The product
ordering (or block ordering) < = (<_1,<_2) on Loc K[x,y] is the following:
@*x^a y^b < x^A y^B <==>
@*x^a <_1 x^A
@*or
@*x^a = x^A  and  y^b <_2 y^B.
@end ifinfo
@iftex
@tex
$<_1$ a monomial
ordering on $Loc K[x]$ and $<_2$ a monomial ordering on $Loc K[y]$.   The product
ordering (or block ordering) $<\ := (<_1,<_2)$ on $Loc K[x,y]$ is the following:
@end tex
@*@tex
\quad \quad $x^a y^b < x^A y^B \Leftrightarrow x^a <_1 x^A$
@end tex
@*@tex
\phantom{\quad \quad $x^a y^b < x^A y^B \Leftrightarrow$}
or $x^a = x^A$ and $y^b <_2 y^B$.
@end tex
@end iftex

Inductively one defines the product ordering of more than two monomial
orderings.

In @sc{Singular}, any of the above global orderings, local orderings or matrix
ordering may be combined (in an arbitrary manner and length) to a product
ordering.   E.g. @code{(lp(3), M(1, 2, 3, 1, 1, 1, 1, 0, 0), ds(4), ws(1,2,3))}
defines: @code{lp} on the first 3 variables, the matrix ordering
@code{M(1, 2, 3, 1, 1, 1, 1, 0, 0)} on the next 3 variables,
@code{ds} on the next 4 variables and
@code{ws(1,2,3)} on the last 3 variables.

@c --------------------------------------------------------------
@node extra weight vector, , product orderings, Monomial orderings
@subsection extra weight vector
@cindex extra weight vector

@ifinfo
a: a(w_1, @dots{}, w_n),
@end ifinfo
@tex
a:\quad ${\tt a}(w_1, \ldots, w_n),\; $
@end tex
@ifinfo
w_1,@dots{},w_n
@end ifinfo
@tex
$w_1,\ldots,w_n$
@end tex
 any integer (including 0), defines
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@*
@ifinfo
x^a < x^b <== deg(x^a) < deg(x^b)
@end ifinfo
@tex
    $$x^\alpha < x^\beta \Leftarrow \deg(x^\alpha) < \deg(x^\beta),$$
@end tex
@ifinfo
@*
x^a > x^b <== deg(x^a) > deg(x^b)
@end ifinfo
@tex
    $$x^\alpha > x^\beta \Leftarrow \deg(x^\alpha) > \deg(x^\beta)$$
@end tex
@*An extra weight vector does not define a monomial ordering by itself:
it can only be used in combination with other orderings
to insert an extra line of weights into the ordering
matrix.
@*@strong{Example}:
@example
  ring r = 0, (x,y,z), (a(1,2,3),
                       wp(4,5,2));
  ring s = 0, (x,y,z), (a(1,2,3),dp);
  ring q=  0, (a,b,c,d),(lp(1),a(1,2,3),ds);
@end example
@c ---------------------------------------------------------------------------
@node Expressions, Commands, Command Syntax, Top
@chapter Expressions
@cindex Expressions
@menu
* string expression::
* int expression::
* boolean expression::
* intvec expression::
* intmat expression::
* rings::
* poly expression::
* number expression::
* ideal expression::
* vector expression::
* module expression::
* matrix expression::
* list expression::
* links::
* procedures::
* maps::
* untyped definitions::
* expression list::
* block::
@* operations
* implicit type conversions::
* type casting::
@end menu
@c @* operations between expression T.B.C.
@c @* implicit casts of expressions T.B.C.
@c @* defaults of expressions T.B.C.
@c --------------------------------------
@node string expression, int expression, Expressions, Expressions
@section string expession
@cindex string expression
@cindex newline

Variables of type @code{string} are used for output (almost every type can be
"converted"
to @code{string}) and for building your own commands at runtime
(see @ref{execute}).
They are also return values of certain interpreter related functions
(see @ref{Functions}).
String constants consist of a sequence of ANY characters
(including newline!) between a starting @code{"} and a closing @code{"}.
There is also a string constant @code{newline}, which is the newline character.
The @code{+} sign "adds" strings, @code{""} is the empty string
(hence strings form a semigroup). Strings may be used to comment
the output of a computation or to give it a nice format.
Strings may also be used
to convert one type into another.
@example
@c example
  string s="Hi";
  string s1="a string with new line at the end"+newline;
  string s2="another string with new line at the end
  ";
  s;s1;s2;
  ring r; ideal i=std(ideal(x,y^3));
  "dimension of i =",dim(i),", multiplicity of i =",mult(i);
  "dimension of i = "+string(dim(i))+", multiplicity of i = "+string(mult(i));
  "a"+"b","c";
@c example
@end example
A comma between two expressions makes an expression list out of them
(such a list is printed with as a separating blank between),
while a @code{+} concatenates strings.

A string expression is:
@enumerate
@item
a sequence of characters between two quotes (@code{"})
@item
an identifier of type string
@item
a function returning string
@item
a substring
@item
a typecast to string (from any type)
@item
string expressions combined by the operation @code{+}.
@end enumerate
@*@strong{Example:}
@example
  // a string constant
  "@dots{}";
  // a typecast from name
  string(name)
  // concatenation
  string_expression + string_expression
  //string_expression[start, length] : a substring
  //(possibly filled up with blanks)
  string s="123456";
  s[2,4];// the substring of s starting at position 2
         // with a length of 4
  @expansion{} 2345
  "abcd"[2,2];
  @expansion{} bc
  //string_expression[position] : a character from a string
  s[3];
  @expansion{} 3
  //a function returning a string
  typeof(s);
  @expansion{} string
@end example
@menu
* implicit type conversions::
* type casting::
* string functions::
@end menu
@iftex
See @ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node string functions, ,string expression, string expression
@subsection string functions
@cindex string functions
There are the following operations and functions for strings:
@table @asis
@item @code{+}
concatenation
@item @code{<=}, @code{>=}, @code{==}, @code{<>}
comparison (lexicographic with respect to the ASCII coding)
@item @code{nameof}
name of an object (see @ref{nameof})
@item @code{read}
read a file (see @ref{read})
@item @code{size}
length of a string (see @ref{size})
@item @code{find}
position of a substring in a string (see @ref{find})
@item @code{typeof}
type of an object (see @ref{typeof})
@item @code{ordstr}
monomial ordering of a ring (see @ref{ordstr})
@item @code{charstr}
description of the coeffinet field of a ring (see @ref{charstr})
@item @code{parstr}
names of all ring parameters or the
name of the n-th ring parameter (see @ref{parstr})
@item @code{varstr}
names of all ring variables or the
name of the n-th ring variable (see @ref{varstr})
@end table
@*
Brackets may be used to access parts of a string:
@emph{string expression} @code{[} @emph{position} @code{]} is a character of the string,
@emph{string expression} @code{[} @emph{position}@code{,} @emph{length} @code{]} is a substring
and @emph{string expression} @code{[} @emph{intvec} @code{]} ist a list of characters
from the string.
@*
@*@strong{Example}
@example
@c example
  string s="abcde";
  s[2];
  s[3,2];
  ">>"+s[1,10]+"<<";
  s[2]="BC"; s;
  intvec v=1,3,5;
  s=s[v]; s;
  s="123456"; s=s[3..5]; s;
@c example
@end example
@c ------------------------------
@node int expression, boolean expression,string expression,Expressions
@section int expression
@cindex int expression
Variables of type int represent the compiler integers  and are, therefore,
limited  in their range (i.e. the range is between
-2147483647 and 2147483647 for 32-bit mchines). They are used
to count things (dimension, rank, etc., see @ref{dim}),
in loops (see @ref{for}) and
to represent boolean values
(FALSE is represented by 0, every other value means TRUE).
They consist of a sequence of digits, possibly preceded by a sign.
A space is considered as a separator, so it is not allowed between digits.
A sequence of digits outside the allowed range will be converted to the type
poly if possible.
@example
@c example
  int j=1;
  ring r;
  int i=dim(std(ideal(x,y)));// dimension of factor ring defined by (x,y)
                 // (i.e. R/(x,y)) if it is given by a standard basis
  int compare = i<j;
  compare;      // 0 (FALSE) if i >= j, 1 (TRUE) if i<j
@c example
@end example
Integers may be converted to polynomials by an assignment,
e.g.
@example
  poly g=j;
  // define the constant polynomial g equal to the image of
  // the integer j in the actual coefficient field
@end example

An int expression is:
@enumerate
@item
a sequence of digits (if the number represented by this sequence is too
large to fit into the range of integers it is automatically
converted to the type number, if a basering is defined)
@item
an identifier of type int
@item
an element of an intvec or an intmat
@item
a function returning int
@item
a typecast to int
@item
int expressions combined by arithmetic operations
@code{+},@code{-},@code{*},@code{/},@code{%} or @code{^}.
@end enumerate
Variables of type int represent the compiler integers  and are, therefore,
limited  in their range. If this range is too small the expression
must be converted to the type number over a ring with characteristic 0.

@strong{Example:}
@example
@c example
  ring r=0,x,dp;
  // using the type cast number for a greater allowed range
  number(11)*13*17*100*200*2000*503*1111*222222;
  // Note: 11*13*17*100*200*2000*503*1111*222222
  // would return a machine integer:
  11*13*17*100*200*2000*503*1111*222222;
  int i;
  i+2;
  intvec v=i..i+3;
  v;
@c example
@end example
@menu
* implicit type conversions::
* type casting::
* int operations::
* int functions::
@end menu
@iftex
See @ref{implicit type conversions}; @ref{type casting}; @ref{int functions}.
@end iftex
@c ------------------------------
@node int operations, int functions, int expression, int expression
@subsection int operations
@cindex int operations
@cindex mod
@cindex div
There are the following operations for objects of type int:
@table @asis
@item @code{++}
will change its operand to its successor, is itself no int expression
@item @code{--}
will change its operand to its predecessor, is itself no int expression
@item @code{+}
addition
@item @code{-}
negation or subtraction
@item @code{*}
multiplication
@item @code{div}
division in the integers (omitting the remainder)
@item @code{%}, @code{mod}
modulo (the remainder of the division)
@item @code{^,**}
power, exponentiation
@item @code{<}, @code{>}, @code{<=}, @code{>=}, @code{==}, @code{<>}
comparison
@end table
@*
@*@strong{Example}
@example
@c example
  int i=1;
  i++; i ; i--; i; // ++ and -- will not return a value as in C
  i+2, 2-i, 5^2, 5 div 2, 8%3, 1<2, 2<=2;
@c example
@end example
@c ------------------------------
@node int functions, , int operations, int expression
@subsection int functions
@cindex int functions
There are the following functions concerning int:
@table @asis
@item @code{char}
characteristic of the coefficient field of a ring (see @ref{char})
@item @code{deg}
degree of a poly resp. vector (see @ref{deg})
@item @code{det}
determinant (see @ref{det})
@item @code{dim}
Krull dimension of base ring modulo ideal resp. module (see @ref{dim})
@item @code{find}
position of a substring in a string (see @ref{find})
@item @code{gcd}
greatest common divisor (see @ref{gcd})
@item @code{memory}
memory usage (see @ref{memory})
@item @code{mult}
multiplicity of an ideal resp. module (see @ref{mult})
@item @code{ncols}
number of columns (see @ref{ncols})
@item @code{npars}
number of ring parameters (see @ref{npars})
@item @code{nrows}
number of rows of a matrix resp.
the rank of the free module where the vector / module lives
(see @ref{nrows})
@item @code{nvars}
number of ring variables (see @ref{nvars})
@item @code{ord}
degree of the leading term of a poly resp. vector (see @ref{ord})
@item @code{pardeg}
degree of a number considered as a polynomial in the ring parameters (see @ref{pardeg})
@item @code{prime}
the next lower prime (see @ref{prime})
@item @code{random}
a pseudo random integer between the given limits (see @ref{random})
@item @code{regularity}
regularity of a resolution (see @ref{regularity})
@item @code{rvar}
test, if the given expression or string is a ring variable (see @ref{rvar})
@item @code{size}
number of elements in an object (see @ref{size})
@item @code{trace}
trace of an integer matrix (see @ref{trace})
@item @code{vdim}
vector space dimension of base ring modulo ideal resp. of freemodule modulo
module (see @ref{vdim})
@end table
@c ------------------------------
@node boolean expression, intvec expression,int expression,Expressions
@section boolean expression
@cindex boolean expression
@cindex ==
@cindex !=
@cindex <>
@cindex <=
@cindex >=
@cindex and
@cindex &&
@cindex or
@cindex ||
@cindex not
A boolean expression is really an int expression used in a logical context:
@enumerate
@item
an int expression (<> 0 evaluates to @emph{TRUE}, 0 evaluates to @emph{FALSE})
@item
an integer comparison:
@example
  i == j
  i != j    //or     i <> j
  i <= j
  i >= j
  i > j
  i < j
@end example
@item
a number comparison:
@example
  m == n
  m != n    //or     m <> n
  m < n
  m > n
  m <= n
  m >= n
@end example
For numbers from Z/p or from field extensions not all operations are useful:
@* - 0 ist always the smallest element,
@* - in Z/p the representatives in the range -p/2..p/2 are used for comparisons
@* - in field extensions the last two operations
(@code{>=,<=}) yield always TRUE (1) and
the @code{<} and @code{>} are equivalent to @code{!=}.
@item
a polynomial comparison:
@example
  f == g
  f != g    //or     f <> g
  f <= g    //comparing the leading term w.r.t. the monomial order
  f >= g
@end example
@item
an intvec or intmat comparison:
@example
  v == w
  v != w    //or     v <> w
@end example
@item
a string comparison:
@example
  f == g
  f != g    //or     f <> g
  f <= g    // comparing lexicographically
            // w.r.t. the order specified by ASCII
  f >= g
  f >  g
  f <  g
@end example
@item
boolean expressions combined by boolean operations:
@code{and}, @code{or}, @code{not}.
@*@code{and} may also be written as @code{&&}, @code{or} as @code{||},
@code{not} as @code{!}
(see @ref{Evaluation of logical expressions}).
@*strong{Remark:} All arguments of a logical expressions are first
evaluated and then the value of the logical expression is
determined. For example, the logical expressions @code{(1 || a)} is
evaluated by first evaluating @code{a}, even though the value of
@code{a} has no influence on the value of @code{(1 || a)}. Note that
this is different from the left-to-right evaluation of logical
expressions (as found in most programming languages like C) which, for
example, determine the @code{(1 || a)} without evaluating @code{a}.
@end enumerate
@c ------------------------------
@node intvec expression, intmat expression, boolean expression,Expressions
@section intvec expression
@cindex intvec expression

Variables of type intvec are lists of integers.
For the range of integers see @ref{int expression}.
They can be used for simulating integers sets
(and other sets if the intvec entry is used as an index for other objects).
They are also return values of certain interpreter related functions
(see @ref{Functions}).
@example
@c example
  intvec iv=1,2,5,7;
  iv;
  iv[3];
  iv[7]=1;
  iv;
@c example
@end example

An intvec expression is:
@enumerate
@item
a list of int expressions and of intvec expressions
@item
a range: int expression @code{..} int expression
@item
a function returning intvec (see @ref{intvec functions})
@item
intvec operations with int: @code{+}, @code{-}, @code{*}, @code{/}, @code{%}
@item
intvec operations: @code{+}, @code{-}
@item
intvec operation with an intmat: @code{*}
@item
intvec comparison (done lexicographically, yielding int):
@code{<>}, @code{==}, @code{<=}, @code{>=}, @code{>}, @code{<}
@end enumerate

@menu
* intvec functions::
@end menu
@iftex
See @ref{intvec functions}.
@end iftex

@strong{Example}
@example
@c example
  intvec iv=1,3,5,7,8;
  iv=iv,iv;           // concatenation
  iv+1;               // add 1 to each entry
  iv*2;
  iv;
  iv-10;
  iv=iv,0;
  iv;
  iv/2;
  iv+iv;              // componentwise addition
  iv[size(iv)-1];     // last-1 entry
  intvec iw=2,3,4,0;
  iv==iw;             // comparision
  intmat im[2][4];
  im=2,3,4,0,1,0,0,0;
  iv=im*iw;
  iv;
@c example
@end example
@c ------------------------------
@node intvec functions, , intvec expression, intvec expression
@subsection intvec functions
@cindex intvec functions
There are the following functions concerning intvec
@table @asis
@item @code{hilb}
returns Hilbert series as intvec (see @ref{hilb})
@item @code{indepSet}
indices of a maximal set of independent variables of an ideal (see @ref{indepSet})
@item @code{leadexp}
the exponent vector of the leading monomial (see @ref{leadexp})
@item @code{nrows}
number of rows (see @ref{nrows})
@item @code{qhweight}
returns quasihgomogeneous weights (see @ref{qhweight})
@item @code{size}
length of the intvec (see @ref{size})
@item @code{sortvec}
permutation for sorting ideals/modules (see @ref{sortvec})
@item @code{transpose}
transpose of an intvec, returns an intmat (see @ref{transpose})
@item @code{weight}
returns weights for the weigted ecart method (see @ref{weight})
@end table
@c ------------------------------
@node intmat expression, rings, intvec expression,Expressions
@section intmat expression
@cindex intmat expression

Integer matrices are matrices with entries of integers.
For the range of integers see @ref{int expression}.
@example
@c example
  intmat m[2][3]=1,2,3,4,5,6;
  m;
@c example
@end example

A intmat expression is:
@enumerate
@item
a list of int expressions, intvec expressions and intmat expressions
@item
a function returning intmat (see @ref{intmat functions})
@item
intmat operations with int: @code{+}, @code{-}, @code{*}, @code{/}, @code{%}
@item
intmat operations: @code{+}, @code{-}, @code{*}
@item
intmat comparison (yielding int): @code{<>}, @code{==}
@end enumerate

@strong{Example}
@example
@c example
  intmat m[2][3]=1,0,2,4,5,1;
  m+1;             // adds unit intmat to m
  m[2,1];          // entry at 2,1
  intmat m1[3][2]=1,0,2,4,0,1;
  m1*10;           // multiply each entry with 10
  m*m1;
  m+transpose(m1);
  intvec v1=1,2,4;
  intvec v2=5,7,8;
  m=v1,v2;         // overwrite M with v1 and v2
  m;
  trace(m);
@c example
@end example
@c ------------------------------
@node intmat functions, , intmat expression, intmat expression
@subsection intmat functions
@cindex intmat functions
There are the following functions for intmat
@table @asis
@item @code{bareiss}
Bareiss algorithm (see @ref{bareiss})
@item @code{betti}
Betti numbers of a free resolution (see @ref{betti})
@item @code{det}
determinant (see @ref{det})
@item @code{ncols}
number of cols (see @ref{ncols})
@item @code{nrows}
number of rows (see @ref{nrows})
@item @code{random}
create a random intmat (see @ref{random})
@item @code{size}
total number of entries (see @ref{size})
@item @code{transpose}
transpose of an intmat (see @ref{transpose})
@item @code{trace}
trace of an intmat (see @ref{trace})
@end table
@c ------------------------------
@node rings, poly expression, intmat expression, Expressions
@section rings
@cindex rings
Every number, polynomial, vector, ideal, module and every matrix
(but not intmat)
in @sc{Singular} must be defined over a
base ring which is a polynomial ring over a field
or a localization hereof
(depending on the monomial ordering, see @ref{Monomial orderings})
or a quotient ring (factor ring) hereof modulo a standard basis.
The @code{ring} (resp. @code{qring} for quotient ring) command informs
@code{@sc{Singular}} about the coefficient field,
the names of indeterminants and the monomial ordering.
A definition of a ring sets this ring as the actual base ring.
The reserved word @code{basering} is an alias for the actual ring.
All subsequent definitions of
polynomials, vectors, ideals, modules and matrices
refer to this ring and are "local" to it
until a new ring is defined with a @code{ring} or a @code{qring}
or @code{setring} command.
Access to objects belonging to other rings
is only possible via a ring map,
i.e. via @code{map}, @code{imap} or @code{fetch}
(@code{imap} and @code{fetch} require that the rings are similiar enough).
@enumerate
@item
Coefficient fields are Z/p (p a prime <= 32003),
Galois fields GF(q) (q<=32761),
Q (the rational numbers), algebraic or transcedental extensions of Z/p or Q,
and real numbers (floats)
@item
The indeterminants (variables) of polynomials are names or indexed names
(e.g. @code{x,y} or @code{x(0),x(2),...} or @code{a(1..5)} for
@code{a(1),...,a(5)} or @code{b(5..1)} for @code{b(5),...,b(1)}
or @code{x1,x2,y1,y2}).
The set of indeterminants is always ordered.
@item
Monomial orderings are
the lexicographical ordering (@code{lp, ls}),
the degree reverse lexicographical ordering with weights 1 (@code{dp, ds})
or arbitrary weights (@code{wp, ws}),
the degree lexicographical ordering with weights 1 (@code{Dp, Ds})
or arbitrary weights (@code{Wp, Ws}),
or the matrix ordering (@code{M}).

The orderings @code{ls,ds,Ds,ws,Ws} describe orderings in series
rings; @code{lp,dp,Dp,wp,Wp} orderings in polynomial rings.
The orderings @code{lp,ls,dp,ds,wp,ws,Dp,Ds,Wp,Ws} can be combined
(yielding a block ordering).
They can also be combined with the special orderings @code{c, C}
(ordering of the components of a vector) and @code{a}
(inserting a weight vector into the order matrix).
See @ref{Monomial orderings}.
@end enumerate
See @ref{ring}; @ref{setring}; @ref{qring}; @ref{maps};
@ref{fetch}.
There are versions of @sc{Singular} which offer the
possibility to work in
supercommutative superalgebras (which includes exterior algebras)
or in Weyl algebras.
Such rings can be defined with @code{ring} and @code{alternating}
(supercommutative superalgebras) resp. with
@code{dring} (Weyl algebras). (See @ref{alternating}; @ref{dring}.)
@c ---------------------------------------
@node poly expression, number expression, rings,Expressions
@section poly expression
@cindex poly expression

Polynomials are the basic data for all main algorithms in @code{@sc{Singular}}.
They consist of finitely many terms (coefficient*power product)
which are combined by the usual
polynomial operations (see @ref{poly expression}).
Polynomials can only be defined or accessed with respect to a base ring
which determines the coefficient type, the names of the indeterminants and the
monomial ordering.
@example
@c example
  ring r=32003,(x,y,z),dp;
  poly f=x3+y5+z2;
@c example
@end example

A poly expression is (optional parts in square brackets):
@enumerate
@item
a monomial (there are NO spaces allowed inside a monomial)
@example
  [coefficient] ring_variable [ exponent] [ring_variable [exponent] @dots{}]
@end example
monomials which contain an indexed ring variable
must be built from @code{ring_variable} and @code{coefficient}
with the operations * and ^
@item
an identifier of type poly
@item
a function returning poly (see @ref{poly functions})
@item
an int expression (see @ref{implicit type conversions})
@item
poly expressions combined by arithmetic operations +,-,*,/ or ^.
(see @ref{poly operations}).
@end enumerate
@strong{Example:}
@example
  2x, x3, 2x2y3, xyz, 2xy2; //  are monomials
  2*x, x^3, 2*x^2*y^3, x*y*z, 2*x*y^2; // are poly expressions
  2*x(1); // is a valid poly expression, but not 2x(1) (a syntax error)
  2*x^3; //  is a valid poly expression equal to 2x3 (a valid monomial)
         // but not equal to 2x^3
         // which will be interpreted as (2x)^3
@end example
@menu
* ring::
* poly::
* poly operations::
* poly functions::
* implicit type conversions::
* type casting::
@end menu
@iftex
See @ref{ring}; @ref{poly}; @ref{poly operations}; @ref{poly functions};
@ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node poly operations, poly functions, poly expression, poly expression
@subsection poly operations
@cindex poly operations
There are the following operations for polys:
@table @asis
@item @code{+}
addition
@item @code{-}
negation resp. subtraction
@item @code{*}
multiplication
@item @code{/}
division by a monomial, non divisible terms yield 0
@item @code{^,**}
power by an integer
@item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
comparison
@item @code{[}, @code{]}
choice of the monomial at the indicated place w.r.t. the monomial order
@end table

@strong{Example:}
@example
@c example
  ring R=0,(x,y),dp;
  x+y;
  x<=y;
  (x+y+x^2)[2]; // the 2nd biggest monomial
  (x+y)/x;
@c example
@end example
@c ------------------------------
@node poly functions, ,poly operations, poly expression
@subsection poly functions
@cindex poly functions
There are the following functions concerning polys:
@table @asis
@item @code{cleardenom}
quotient of a poly by its content (see @ref{cleardenom})
@item @code{coef}
matrix of coefficients and monomials (see @ref{coef})
@item @code{coeffs}
matrix of coefficients (see @ref{coeffs})
@item @code{deg}
degree (see @ref{deg})
@item @code{det}
determinant (see @ref{det})
@item @code{diff}
partial derivative (see @ref{diff})
@item @code{finduni}
find univariate polynomials in a zero dimensional ideal (see @ref{finduni})
@item @code{homog}
homogenization (see @ref{homog})
@item @code{jacob}
ideal resp. matrix of all partial derivatives (see @ref{jacob})
@item @code{lead}
leading monomial (see @ref{lead})
@item @code{leadcoef}
coefficient of the leading term (see @ref{leadcoef})
@item @code{leadexp}
the exponent vector of the leading monomial (see @ref{leadexp})
@item @code{jet}
monomials with degree smaller k+1 (see @ref{jet})
@item @code{ord}
degree of the leading monomial (see @ref{ord})
@item @code{reduce}
normal form with respect to a standard base (see @ref{reduce})
@item @code{rvar}
test for ring variable (see @ref{rvar})
@item @code{simplify}
normalize a polynomial (see @ref{simplify})
@item @code{size}
number of monomials (see @ref{size})
@item @code{subst}
substitute a ring variable (see @ref{subst})
@item @code{trace}
trace of a matrix (see @ref{trace})
@item @code{var}
the indicated variable of the ring (see @ref{var})
@end table
Brackets may be used to access elements of ideals and matrices:
@emph{ideal expression} @code{[} @emph{position} @code{]} is a generator of the ideal,
@emph{matrix expression} @code{[} @emph{row}@code{,} @emph{column} @code{]} is a matrix entry.

@c @strong{Example}
@c @example
@c @end example
@c ---------------------------------------
@node number expression, ideal expression, poly expression,Expressions
@section number expression
@cindex number expression

Numbers are the coefficients of a monomial (power products of ring variables).
They can only be defined or accessed with respect to a base ring
which determines the coefficient field.
@example
@c example
  ring r0=32003,x,dp;
  number n=2/3; n;
  ring r1=0,x,dp;
  number n=2/3; n;
  ring r2=(0,a),(x,y,z),dp;
  number n=2/3; n;
  n=a+a^2;
  poly f=n*x+2;f;
@c example
@end example

A number expression is:
@enumerate
@item
a rational number (there are NO spaces allowed inside a rational number,
see @ref{int expression})
@item
a floating point number (if the coefficient field is @code{real}):
@*<digits>@code{.}<digits>@code{e}<sign><digits>
@item
an identifier of type number
@item
a function returning number (see @ref{number operations})
@item
an int expression (see @ref{implicit type conversions})
@item
number expressions combined by arithmetic operations @code{+,-,*,/} or @code{^,**}.
(see @ref{number operations}).
@end enumerate
@strong{Example:}
@example
  2/3, 4/8, 2/2 ; // are numbers
  2 / 3, 4/ 8,  2 /2 ; // are int expressions (of value 0, 0 and 1)
  1.7e-2; 1.7e+2 // are valid (but  1.7e2 not), if the field is `real`
@end example
@menu
* ring::
* number::
* number operations::
* implicit type conversions::
* type casting::
@end menu
@iftex
See @ref{number}; @ref{ring}; @ref{number operations};
@ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node number operations, , , number expression
@subsection number operations
@cindex number operations
There are the following operations and functions for numbers:
@table @asis
@item @code{+}
addition
@item @code{-}
negation resp. subtraction
@item @code{*}
multiplication
@item @code{/}
division
@item @code{^,**}
power, exponentiation (by an integer)
@item @code{<=, >=, ==, <>}
comparison
@item @code{leadcoef}
coefficient of the leading term (see @ref{leadcoef})
@end table

@c @strong{Example}
@c @example
@c @end example
@c ------------------------------
@node ideal expression, vector expression, number expression,Expressions
@section ideal expression
@cindex ideal expression

Ideals are represented as lists of polynomials which generate the ideal.
Like polynomials they
can only be defined or accessed with respect to a base ring.
@example
  ring R;
  poly f=x2+y3;
  ideal i=z2,f;// the ideal generated by z^2,x^2+y^3 in R
@end example

An ideal expression is:
@enumerate
@item
an expression list of poly expressions
@item
an identifier of type ideal
@item
a function returning ideal
@item
ideal expressions combined by arithmetic operations @code{+,*}
@item
a power of an ideal expression (operator @code{^} or @code{**})
@*Note that the computation of the product i*i involves
all products of generators of i while i^2 involves only the different ones
and is therefore faster
@item
a typecast to ideal.
@end enumerate
@menu
* ideal::
* ideal operations::
* ideal functions::
* implicit type conversions::
* type casting::
@end menu
@iftex
See @ref{ideal}; @ref{ideal operations}; @ref{ideal functions};
@ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node ideal operations, ideal functions, ideal expression, ideal expression
@subsection ideal operations
@cindex ideal operations
There are the following operations for ideals:
@table @asis
@item @code{+}
addition (concatenation of the generator and simplification)
@item @code{*}
multiplication (with ideal, poly, vector, module)
@item @code{^}
power, exponentiation (by an integer)
@end table

@c @strong{Example}
@c @example
@c @end example
@c ------------------------------
@node ideal functions, ,ideal operations, ideal expression
@subsection ideal functions
@cindex ideal functions
There are the following functions for ideals:
@table @asis
@item @code{char_series}
ireducible characteristic series (see @ref{char_series})
@item @code{coeffs}
matrix of coefficients (see @ref{coeffs})
@item @code{contract}
contraction by an ideal (see @ref{contract})
@item @code{diff}
partial derivative (see @ref{diff})
@item @code{degree}
multiplicity, dimension and codimension of the ideal of leading terms (see @ref{degree})
@item @code{dim}
Krull dimension of base ring modulo the ideal of leading terms (see @ref{dim})
@item @code{eliminate}
elimination of variables (see @ref{eliminate})
@item @code{facstd}
factorizing Groebner basis algorithm (see @ref{facstd})
@item @code{fglm}
compute the Groebner basis from a GB w.r.t. a different ordering (see @ref{fglm})
@item @code{finduni}
find univariate polynomials in a zero dimensional ideal (see @ref{finduni})
@item @code{homog}
homogenization with respect to a variable (see @ref{homog})
@item @code{hilb}
Hilbert function of a standardbasis (see @ref{hilb})
@item @code{indepSet}
a maximal set of independent variables of an ideal (see @ref{indepSet})
@item @code{interred}
interreduction of an ideal (see @ref{interred})
@item @code{intersect}
ideal intersection (see @ref{intersect})
@item @code{jacob}
ideal of all partial derivatives resp. jacobi matrix (see @ref{jacob})
@item @code{jet}
k-jet: Taylor series up to a given order (see @ref{jet})
@item @code{kbase}
vector space basis of basering modulo standardbasis (see @ref{kbase})
@item @code{koszul}
Koszul matrix (see @ref{koszul})
@item @code{lead}
leading terms of a set of generators (see @ref{lead})
@item @code{lift}
lift-matrix (see @ref{lift})
@item @code{liftstd}
standardbasis and transformation matrix computation (see @ref{liftstd})
@item @code{maxideal}
power of the maximal ideal at 0 (see @ref{maxideal})
@item @code{minbase}
minimal generating set of a homogeneous ideal/module or an ideal/module in a local ring
(see @ref{minbase})
@item @code{minor}
set of minors of a matrix (see @ref{minor})
@item @code{modulo}
represents (h1+h2)/h1=h2/(h1 intersect h2) (see @ref{modulo})
@item @code{mres}
minimal free resolution of an ideal/module, also minimizing the given ideal/module
(see @ref{mres})
@item @code{mstd}
standard basis and minimal generating set of an ideal (see @ref{mstd})
@item @code{mult}
multiplicity of an ideal resp. module (see @ref{mult})
@item @code{ncols}
number of columns (see @ref{ncols})
@item @code{preimage}
preimage under a ring map (see @ref{preimage})
@item @code{qhweight}
quasihomogeneous weights of an ideal (see @ref{qhweight})
@item @code{quotient}
ideal quotient (see @ref{quotient})
@item @code{reduce}
normalform with respect to a standardbasis (see @ref{reduce})
@item @code{res}
minimal free resolution of an ideal/module but not changing the given ideal/module
(see @ref{res})
@item @code{simplify}
simplify a set of polynomials (see @ref{simplify})
@item @code{size}
number of non-zero generators (see @ref{size})
@item @code{sortvec}
permutation for sorting ideals/modules (see @ref{sortvec})
@item @code{sres}
free resolution of a standard basis (see @ref{sres})
@item @code{std}
standardbasis computation (see @ref{std}, @ref{liftstd})
@item @code{subst}
substitute a ring variable (see @ref{subst})
@item @code{syz}
computation of the first syzygy module (see @ref{syz})
@item @code{vdim}
vector space dimension of basering modulo ideal (see @ref{vdim})
@item @code{weight}
optimal weights (see @ref{weight})
@end table
Brackets may be used to access elements of ideals:
@emph{ideal expression} @code{[} @emph{position} @code{]} is a generator of the ideal.

@c @strong{Example}
@c @example
@c @end example
@c ---------------------------------------
@node vector expression, module expression, ideal expression,Expressions
@section vector expression
@cindex vector expression

Vectors are elements of a free module over the basering with basis
@code{gen(1)}, @code{gen(2)}, @dots{} .
Each vector belongs to a free module of rank equal to the biggest index
of a generator with nonzero coefficient. Since generators with zero
coefficients need not be written any vector may be considered
also as an element of a free module of higher rank.
Like polynomials they
can only be defined or accessed with respect to this base ring.
(E.g. if f and g are polynomials then
@code{f*gen(1)+g*gen(3)+gen(4)} can also be written as @code{[f,0,g,1]}
or as @code{[f,0,g,1,0]}.)

A vector expression is:
@enumerate
@item
an identifier of type vector
@item
a function returning vector
@item
a poly expression (via the canonical embedding p -> p*gen(1))
@item
vector expressions combined by arithmetic operations @code{+} or @code{-}
@item a poly expression and a vector expression
combined by arithmetic operation @code{*}.
@end enumerate
@strong{Example:}
@example
@c example
  // ordering gives priority to components:
  ring rr=0,(x,y,z),(c,dp);
  vector v=[x2+y3,2,0,x*y]+gen(6)*x6;
  v;
  vector w=[z3-x,3y];
  v-w;
  v*(z+x);
@c example
@end example
@menu
* ring::
* vector::
* vector operations::
* vector functions::
* implicit type conversions::
* type casting::
@end menu
@iftex
See @ref{ring}; @ref{vector}; @ref{vector operations}; @ref{vector functions};
@ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node vector operations, vector functions, vector expression, vector expression
@subsection vector operations
@cindex vector operations
There are the following operations for vectors:
@table @asis
@item @code{+}
addition
@item @code{-}
negation resp. subtraction
@item @code{/}
division by a monomial, not divisible terms yield 0
@item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
comparison
@item @code{[} @code{]}
choice of a component
@end table

@strong{Example:}
@example
@c example
  ring R=0,(x,y),(c,dp);
  [x,y]-[1,x];
  [1,2,x,4][3];
@c example
@end example
@c ------------------------------
@node vector functions, ,vector operations, vector expression
@subsection vector functions
@cindex vector functions
There are the following functions for vectors:
@table @asis
@item @code{cleardenom}
quotient of a vector by its content (see @ref{cleardenom})
@item @code{coeffs}
matrix of coefficients (see @ref{coeffs})
@item @code{deg}
degree (see @ref{deg})
@item @code{diff}
partial derivative (see @ref{diff})
@item @code{gen}
i-th generator (see @ref{gen})
@item @code{homog}
homogenization (see @ref{homog})
@item @code{jet}
k-jet: monomials with degree smaller k+1 (see @ref{jet})
@item @code{lead}
leading monomial (see @ref{lead})
@item @code{leadcoef}
leading coefficient (see @ref{leadcoef})
@item @code{leadexp}
the exponent vector of the leading monomial (see @ref{leadexp})
@item @code{nrows}
number of rows (see @ref{nrows})
@item @code{ord}
degree of the leading monomial (see @ref{ord})
@item @code{reduce}
normal form with respect to a standard base (see @ref{reduce})
@item @code{simplify}
normalize a vector (see @ref{simplify})
@item @code{size}
number of monomials (see @ref{size})
@item @code{subst}
substitute a ring variable (see @ref{subst})
@end table

@c @strong{Example}
@c @example
@c @end example
@c ------------------------------
@node module expression, matrix expression, vector expression,Expressions
@section module expression
@cindex module expression

Modules are submodules of a free module over the base ring with basis
@code{gen(1)}, @code{gen(2)}, @dots{} .
They are represented by lists of vectors which generate the submodule.
Like vectors they
can only be defined or accessed with respect to a base ring.
If M is a submodule of
@ifinfo
R^n,
@end ifinfo
@tex
R$^n,$
@end tex
R the base ring, generated by vectors
@ifinfo
v_1, @dots{}, v_k, then v_1, @dots{}, v_k
@end ifinfo
@tex
$v_1, \ldots, v_k$, then $v_1, \ldots, v_k$
@end tex
may be considered as the generators of relations of
@ifinfo
R^n/M
@end ifinfo
@tex
R$^n$/M
@end tex
between the canonical generators @code{gen(1)},@dots{},@code{gen(n)}.
Hence any finitely generated R-module can be represented in @sc{Singular}
by its module of relations. The assignments
@code{module M=v1,...,vk; matrix A=M;}
creates the presentation matrix of size n x k for
@ifinfo
R^n/M,
@end ifinfo
@tex
R$^n$/M,
@end tex
i.e. the columns of A are the vectors
@ifinfo
v_1, @dots{}, v_k
@end ifinfo
@tex
$v_1, \ldots, v_k$
@end tex
which generate M.

A module expression is:
@enumerate
@item
an expression list of vector expressions
@item
an identifier of type module
@item
a function returning module
@item
module expressions combined by the arithmetic operation @code{+}
@item
multiplication of a module expressions with an ideal or poly expression (@code{*})
@item
a typecast to module.
@end enumerate
@menu
* module::
* module operations::
* module functions::
* implicit type conversions::
* type casting::
@end menu
@iftex
See @ref{module}; @ref{module operations}; @ref{module functions};
@ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node module operations, module functions, module expression, module expression
@subsection module operations
@cindex module operations
There are the following operations for modules:
@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)
@item @code{*}
multiplication with ideal or poly, but not `module` * `module`
@end table

@c @strong{Example}
@c @example
@c @end example
@c ------------------------------
@node module functions, ,module operations, module expression
@subsection module functions
@cindex module functions
There are the following functions for modules:
@table @asis
@item @code{coeffs}
matrix of coefficients (see @ref{coeffs})
@item @code{degree}
multiplicity, dimension and codimension of the module of leading terms (see @ref{degree})
@item @code{diff}
partial derivative (see @ref{diff})
@item @code{dim}
Krull dimension of free module over the base ring modulo the module of leading terms (see @ref{dim})
@item @code{eliminate}
elimination of variables (see @ref{eliminate})
@item @code{freemodule}
the free module of given rank (see @ref{freemodule})
@item @code{hilb}
Hilbert function of a standardbasis (see @ref{hilb})
@item @code{homog}
homogenization with respect to a variable (see @ref{homog})
@item @code{interred}
interreduction of a module (see @ref{interred})
@item @code{intersect}
module intersection (see @ref{intersect})
@item @code{jet}
k-jet: Taylor series up to a given order (see @ref{jet})
@item @code{kbase}
vector space basis of free module over the basering modulo standardbasis (see @ref{kbase})
@item @code{lead}
initial module (see @ref{lead})
@item @code{lift}
lift-matrix (see @ref{lift})
@item @code{liftstd}
standardbasis and transformation matrix computation (see @ref{liftstd})
@item @code{minbase}
minimal generating set of a homogeneous ideal/module or an ideal/module 
over a local ring
(see @ref{minbase})
@item @code{modulo}
represents (h1+h2)/h1=h2/(h1 intersect h2) (see @ref{modulo})
@item @code{mres}
minimal free resolution of an ideal/module, also minimizing the given module
(see @ref{mres})
@item @code{mult}
multiplicity of a module (see @ref{mult})
@item @code{ncols}
number of columns (see @ref{ncols})
@item @code{nrows}
number of rows (see @ref{nrows})
@item @code{prune}
minimize the embedding into a free module (see @ref{prune})
@item @code{qhweight}
quasihomogeneous weights of an ideal/module (see @ref{qhweight})
@item @code{quotient}
ideal quotient (see @ref{quotient})
@item @code{reduce}
normalform with respect to a standardbasis (see @ref{reduce})
@item @code{res}
minimal free resolution of an ideal/module but not changing the given ideal/module
(see @ref{res})
@item @code{simplify}
simplify a set of vectors (see @ref{simplify})
@item @code{size}
number of non-zero generators (see @ref{size})
@item @code{sortvec}
permutation for sorting ideals/modules (see @ref{sortvec})
@item @code{sres}
free resolution of a standard basis (see @ref{sres})
@item @code{std}
standardbasis computation (see @ref{std}, @ref{liftstd})
@item @code{subst}
substitute a ring variable (see @ref{subst})
@item @code{syz}
computation of the first syzygy module (see @ref{syz})
@item @code{vdim}
vector space dimension of free module over the basering modulo module (see @ref{vdim})
@item @code{weight}
"optimal" weights (see @ref{weight})
@end table

@c @strong{Example}
@c @example
@c @end example
@c ---------------------------------------
@node matrix expression, list expression, module expression,Expressions
@section matrix expression
@cindex matrix expression

Matrices are matrices with polynomial entries.
Like polynomials they
can only be defined or accessed with respect to a base ring.
If you wish to compute with matrices having integer or rational entries
define a ring with characteristic 0 and one variable.

If A is a matrix then the assignment @code{module M=A;} or
@code{module M=module(A);} creates a module generated by the columns of A.
Note that the trailing zero columns of A may be deleted by module operations with M.

A matrix expression is:
@enumerate
@item
an expression list of poly expressions
@item
an identifier of type matrix
@item
a function returning matrix
@item
matrix expressions combined by arithmetic operations @code{+,-,*}
@item
a typecast to matrix.
@end enumerate
@menu
* matrix::
* matrix operations::
* matrix functions::
* implicit type conversions::
* type casting::
@end menu
@iftex
See @ref{matrix}; @ref{matrix operations}; @ref{matrix functions};
@ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node matrix operations, matrix functions, matrix expression, matrix expression
@subsection matrix operations
@cindex matrix operations
There are the following operations for matrices
@table @asis
@item @code{+}
addition
@item @code{-}
negation or subtraction
@item @code{*}
multiplication (with poly, matrix)
@item @code{==}, @code{<>}
comparison
@end table

@c @strong{Example}
@c @example
@c @end example
@c ------------------------------
@node matrix functions, ,matrix operations, matrix expression
@subsection matrix functions
@cindex matrix functions
There are the following functions for matrices
@table @asis
@item @code{bareiss}
Bareiss algorithm (see @ref{bareiss})
@item @code{coef}
matrix of coefficients and monomials (see @ref{coef})
@item @code{coeffs}
matrix of coefficients (see @ref{coeffs})
@item @code{det}
determinant (see @ref{det})
@item @code{diff}
partial derivative (see @ref{diff})
@item @code{jacob}
Jacobi matrix (see @ref{jacob})
@item @code{koszul}
Koszul matrix (see @ref{koszul})
@item @code{lift}
lift-matrix (see @ref{lift})
@item @code{liftstd}
standardbasis and transformation matrix computation (see @ref{liftstd})
@item @code{minor}
set of minors of a matrix (see @ref{minor})
@item @code{ncols}
number of columns (see @ref{ncols})
@item @code{nrows}
number of rows (see @ref{nrows})
@item @code{size}
number of matrix entries (see @ref{size})
@item @code{subst}
substitute a ring variable (see @ref{subst})
@item @code{trace}
trace of a matrix (see @ref{trace})
@item @code{transpose}
transpose a matrix (see @ref{transpose})
@item @code{wedge}
wedge product (see @ref{wedge})
@end table
Brackets may be used to access elements of matrices:
@emph{matrix expression} @code{[} @emph{row}@code{,} @emph{column} @code{]} is a matrix entry.

@c @strong{Example}
@c @example
@c @end example
@c ---------------------------------------
@node list expression, links, matrix expression,Expressions
@section list expression
@cindex list expression

Lists are arrays whose elements can be of any type
(including ring/qring). If one element belongs to a ring the whole list
belongs to that ring.
(This applies also to the special list @code{#}.)
@*Note that a list stores the objects itself and not the names.
Hence, if @code{L} is a list, @code{L[1]} for example has no name.
You can create a name, say @code{R}, for @code{L[1]} by @code{def R=L[1];}.
If you want to store also the name of an object,
say @code{r}, you may add it to the list with @code{nameof(r);}.
Objects of a list may be rings. If @code{L[1]} is a ring, you may
define @code{L[1]} to be the basering for instance by
@code{setring L[1];}.
@*Note: Unlike other assignments a ring as an element of a list
is not a copy but another reference to the same ring.
@*Note: @code{list()} is the empty list, see @ref{type casting}.

A list expression is:
@enumerate
@item
an identifier of type list
@item
a function returning list
@item
list expressions combined by arithmetic operation @code{+} and @code{,}
@item
a typecast to list
@item
the empty list @code{list()}
@end enumerate
@menu
* list::
* list operations::
* list functions::
* implicit type conversions::
* type casting::
@end menu
@iftex
See @ref{list}; @ref{list operations}; @ref{list functions};
@ref{implicit type conversions}; @ref{type casting}.
@end iftex
@c ------------------------------
@node list operations, list functions, list expression, list expression
@subsection list operations
@cindex list operations
There are the following operations for list
@table @asis
@item @code{+}
concatenation
@item @code{,}
construct a new list whose elements are the parts of the expression list
@end table

@c @strong{Example}
@c @example
@c @end example
@c ------------------------------
@node list functions, ,list operations, list expression
@subsection list functions
@cindex list functions
There are the following functions for list
@table @asis
@item @code{betti}
Betti numbers from a resolution (see @ref{betti})
@item @code{delete}
delete an element from a list (see @ref{delete})
@item @code{facstd}
factorizing Groebner basis algorithm (see @ref{facstd})
@item @code{insert}
insert or append a new element to a list (see @ref{insert})
@item @code{minres}
minimize a free resolution (see @ref{minres})
@item @code{mres}
minimal free resolution of an ideal/module, also
minimizing the first module (see @ref{mres})
@item @code{names}
list of all userdefined variable names (see @ref{names})
@item @code{res}
minimal free resolution of an ideal/module (see @ref{res})
@item @code{size}
number of entries (see @ref{size})
@item @code{sres}
free resolution of an ideal/module given by a standard base (see @ref{sres})
@end table
Brackets may be used to access elements of lists:
@emph{list expression} @code{[} @emph{int expression} @code{]} is a list entry.

@c @strong{Example}
@c @example
@c @end example
@c ---------------------------------------
@node links, procedures, list expression, Expressions
@section links
@cindex links

Links describe the communication channels of Singular, i.e.
something @sc{Singular} can write to and/or read from. Currently,
Singular supports four different link types: @ref{Ascii links},  @ref{MPfile links},
@ref{MPtcp links}, and @ref{DBM links}.
@table @code
@item @strong{Defintion:}
@*link_expression = previously declared link
@*link_expression = property_string @code{+} name_string
@*where
@*property_string = @code{""}, or type_string @code{+ ":" +} mode_string
@code{+ " "}
@*and
@*type_string = @code{""}, or @code{"Ascii"}, or @code{"MPfile"}, or
@code{"MPtcp"}, or @code{"DBM"}
@end table

A link is described by a string which starts with a property_string
(specifying the type and mode of the link) and is followed by a
name_string (specifying, for example, a filename).

@*A property string
must always contain the colon (":") character and may not contain space
characters. The string before the colon denotes the type of the link and
the string after the colon denotes its mode. If no type is specified,
then the link type is set to @code{Ascii}, by default. If no mode is
specified, then the default mode of the respective link type is used. If
no property string is specified, then by default, the link type is set
to @code{Ascii} and the mode is left unspecified.

The name_string following the property_string specifies a filename for
@code{Ascii}, @code{MPfile}, and @code{DBM} links and a network
connection for @code{MPtcp} links.

A link is opened by the command @code{open} or by the first
@code{read} or @code{write} command and closed by @code{close} or
@code{kill} (either explicitly by the user or implicitly by leaving the
local scope of the identifier). Status information about a link can be
obtained using the command @code{status}. The state of a @sc{Singular}
session (i.e. all variables and their values) can be dumped and
retrieved using the commands @code{dump} and @code{getdump}. See
@ref{read}, @ref{write}, @ref{open}, @ref{close}, @ref{status},
@ref{dump}, @ref{getdump}.

@menu
* Link operations::
* Ascii links::
* MP links::
* DBM links::
@end menu
@iftex
See @ref{Ascii links}; @ref{MP links};  @ref{DBM links};
@end iftex

@c ---------------------------------------
@node Link operations, Ascii links, links, links
@subsection Link operations
@cindex Link operations
@table @asis
@item @code{close}
see @ref{close}
@item @code{dump}
see @ref{dump}
@item @code{getdump}
see @ref{getdump}
@item @code{open}
see @ref{open}
@item @code{read}
see @ref{read}
@item @code{status}
see @ref{status}
@item @code{write}
see @ref{write}
@end table
@c ---------------------------------------
@node Ascii links, MP links, Link operations, links
@subsection Ascii links
@cindex Ascii links
Via Ascii links data that can be converted to a string can be written
into files for storage or communcation with other programs. The data is
written in plain Ascii format. The output format of polynomials is done
w.r.t. the value of the global variable @ref{short}. Reading
from an Ascii links returns a string - conversion into other data is up to
the user.

Ascii links provide also the possibility to read from
@code{stdin} / write to @code{stdout}: the empty string as filename
denotes the terminal.
@table @code
@item @code{type_string:}
@code{"Ascii"} or @code{""}
@item @code{mode_string:}
@*@code{""}  // mode is set by first read/write
@*@code{"a"} // append mode (default for writing)
@*@code{"w"} // overwrite mode
@*@code{"r"} // read mode
@item @code{name_string:}
filename
@item @strong{Operations:}
@ref{open}, @ref{close}, @ref{status}, @ref{read}, @ref{write},
@ref{dump}, @ref{getdump}.
@item @strong{Restrictions:}
An Ascii link can be used either for reading or for writing, but not for
both at the same time. A @code{close} command must be used before a
change of i/o direction.

Types without a conversion to @code{string} cannot be written.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  link l=":w example.txt";     // type is Ascii, mode is overwrite
  l;
  status(l, "name");           // name is example.txt
  status(l, "open", "yes");    // link is not yet opened
  ideal i=maxideal(2);
  write (l,1,";",2,";","ideal i=",i,";");
  status(l, "open", "yes");    // now link is open
  status(l, "mode");           // for writing 
  write("example.txt","int j=5;");// data is appended to file
  read("example.txt");         // data is returned as string
  close(l);                    // link is closed
  execute read(l);             // read string is executed
  status(l, "open", "yes");    // now link is open
  status(l, "mode");           // in read mode
  close(l);                    // link is closed
  // dump vars overwriting previous file content:
  dump(":w example.txt");
  kill r;
  getdump("example.txt");      // get dump from file
  dump("");                    // dump to stdout
@c example
@end example

@end table
@c ---------------------------------------
@node MP links, DBM links, Ascii links, links
@subsection MP links
@cindex MP links
MP (Multi Protocol) links give the possibility to store and communicate
data in the binary MP format format: read and write access is very fast
compared to Ascii links. MP links can be established using files (link
type is @code{MPfile}) or using TCP sockets (link type is
@code{MPtcp}). All data (including such data that can not be converted
to a string) can be written to an MP link. For ring-dependent data, a
ring description is written together with the data. Reading from an MP
link returns an expression (not a string) which was evaluated after the
read operation. If the expression read from an MP link is not from the
same ring as the current ring, then a @code{read} changes the current
ring.  Currently, data is written without attributes (which is likely to
change in future versions). For a general description of MP, see
@code{http://symbolicnet.mcs.kent.edu:/areas/mp.html}.
@*@strong{Restrictions:} MP links are currently only implemented for
Unix platforms. Objects of type @code{number} are always communicated as
objects of type @code{poly}.
@menu
* MPfile links::
* MPtcp links::
@end menu

@c ---------------------------------------
@node MPfile links, MPtcp links, MP links, MP links
@subsubsection MPfile links
@cindex MPfile links
MPfile links provide the possibility to store data in a file using the
binary MP format. Read and write operations are very fast compared to
Ascii links. Therefore, for storing large amounts of data, MPfile links
should be used, instead of Ascii links. Unlike Ascii links, data read
from MPfile links is returned as expressions one at a time, and not as a
string containing the entire content of the file. Furthermore, ring
dependent data is stored together with a ring description. Therefore,
reading ring-dependent data might change the current ring.

@table @code
@item @code{type_string:}
@code{"MPfile"}
@item @code{mode_string:}
@code{""} // mode is set by first read/write
@*@code{"a"} // append mode (default for writing)
@*@code{"w"} // overwrite mode
@*@code{"r"} // read mode
@item @code{name_string:}
filename
@item @strong{Operations:}
@ref{open}, @ref{close}, @ref{status}, @ref{read}, @ref{write},
@ref{dump}, @ref{getdump}, @ref{quote}, @ref{eval}.
@item @strong{Restrictions:}
An MP file link can be used either for reading or for writing, but not for
both at the same time. A @code{close} command must be used before a
change of i/o direction.
@item @strong{Example:}
@example
@c example
  ring r;
  link l="MPfile:w example.mp"; // type=MPfile, mode=overwrite
  l;
  status(l, "name"); // name is example.mp; link is not yet opened
  ideal i=maxideal(2);
  write (l,1, i, "hello world");// write three expressions
  status(l, "open", "yes");     // now link is open
  status(l, "mode");            // in write mode
  write(l,4);                   // append one more expression
  close(l);                     // link is closed
  read(l);                      // only first expression is read
  status(l, "open", "yes");     // now link is open
  status(l, "mode");            // for reading
  kill r;
  def i = read(l);              // second expression
  listvar();                    // notice that current ring was set
  def s = read(l);              // third expression
  close(l);                     // link is closed
  dump("MPfile:w example.mp");  // dump everything to example.mp
  kill basering, s; listvar();  // kill all vars
  getdump("MPfile: example.mp");// get dump from file
@c example
@end example
@end table
@c ---------------------------------------
@node MPtcp links, , MPfile links, MP links
@subsubsection MPtcp links
@cindex MPtcp links
MPtcp links give the possibility to exchange data in the binary MP
format between two processes which may run on the same or different
computers. MPtcp links can be opened in four different modes: listen,
connect, launch, and fork. 

@*Opening an MPtcp link in listen mode blocks
until a connection to the specified port was made by a connect
call. Opening a MPtcp link in connect mode, supposes that an application
is listening for a connection at the specified host and port. 

@*Opening an MPtcp link in launch mode, launches the specified
application (using rsh, i.e., the application to launch must either be
given with an absolute pathname, or must be in a directory contained in
the search path) on the specified host.  The launching side (client)
"listens" at a chosen port, until the launched (server) application
which was launched with the additional command line arguments "--MPmode
connect --MPhost hostname --MPport portnumber" (hostname and portnumber
are substituted by their respective values) does a connect call. To
launch @sc{Singular} in server mode, the command line option @code{-b}
must be added.

@*Opening an MPtcp link in fork mode, forkes a child of the current
@sc{Singular}, which will take the role of a server, i.e. after the
connection between the parent (client) and child (server) is
established, the child @sc{Singular} goes into server mode. All
variables and their values which existed in the parent
@sc{Singular} befor the fork link was opened, are inherited by the child
(i.e. forked) @sc{Singular}. 

@*To arrange the
evaluation of an expression by a server, the expression must be quoted,
so that a local evaluation is prevented (otherwise, the expression is
evaluated first, and the result of the evaluation is written, instead of
the expression which is to be evaluated).

If @sc{Singular} is in server mode, the value of the variable
@code{mp_ll} is the MPtcp link connecting to the client and
@sc{Singular} is in an infinite read-eval-write loop until the
connection is closed from the client side (by closing its connecting
link). Reading and writing is done to the link @code{mp_ll} -- after an
expression is read, it is evaluated and the result of the evaluation is
written back.  That is, for each expression which was written to the
server, there is exactly one expression written back (which might be an
"empty" expression, if the evaluation on the server side does not return
a value).

MPtcp links should explicitely be opened before being used. MPtcp links
are bidirectional, i.e., can be be used for both, writing and
reading. Reading from an MPtcp link blocks until data was written to
that link. The @code{status} command can be used to check whether there
is data to read. 

@table @code
@item type_string:
@code{"MPtcp"}
@sp 1
@item mode_string:
@code{"fork"}
@*@code{""} // default MPtcp mode is fork
@item mode_string:
@code{"launch"}
@item name_string:
host_spec @code{+} application_spec
@sp 1
@item mode_string:
@code{"listen"}
@item name_string:
port_spec
@sp 1
@item mode_string:
@code{"connect"}
@item name_string:
host_spec @code{+} port_spec
@sp 1
@item application_spec
@code{""} // "Singular -b" is used as default MPapplication
@*@code{" --MPapplication "+} application // application to launch; must be in search path
@item host_spec
@code{""} // localhost is used as default MPhost
@*@code{" --MPhost "} hostname // used host for connection
@item port_spec
@code{" --MPport "} portnumber // string specifying the port to use
@sp 1
@item @strong{Operations:}
@ref{open}, @ref{close}, @ref{status}, @ref{read}, @ref{write},
@ref{dump}, @ref{getdump}, @ref{quote}, @ref{eval}.
@item @strong{Example:}
@example
@c example
  LIB "general.lib"; // needed for "which" and "killall" commands
  // MPtcp:launch link for launching Singular in batch modus
  // on the local host 
  link l="MPtcp:launch";
  open(l); 
  l; // notice that link is ready for writing but not for reading
  ring r; ideal i=x2+y,xyz+z,x2+y2;
  write (l,quote(std(eval(i)))); // std(i) is computed on server
  // server wrote result back -- ready for reading
  def j = read(l);   // result of computation on server is read
  j;
  write(l, quote(std(i)));
                     // std of polynomial "i" is computed on server
  def k = read(l);   // result of computation is read
  k; basering;       // notice that a new ring was created and set
  listvar(all);
  write(l, killall); read(l);
                     // write killall procedure to server
  // and kill everything in server, but links (need to protect mp_ll)
  write(l, quote(killall("not", "link"))); read(l); 
  write(l, quote(getdump(mp_ll))); // server gets dump 
  dump(l);           //  dump is written to server (includes proc's)
  read(l);           // result of previous write-command is read
  killall("not", "link"); killall("proc");
                     // kills eveything, but links
  write(l, quote(dump(mp_ll))); // server writes dump
  getdump(l);        // dump is read from server
  read(l);           // result of previous write-command is read
  close(l);          // server is shut down
  listvar(all);      // same state as we had before "killall()"
  l = "MPtcp:";      // fork link declaration
  open(l); l;        // Notice that name is "parent"
  // and name of forked link is "child"
  write(l, quote(status(mp_ll, "name")));
  read(l);
  write(l, quote(i)); // Child inherited vars and their values
  read(l);
  close(l);          // shut down forked child
@c example
@end example
@end table
@c ---------------------------------------
@node DBM links, , MP links, links
@subsection DBM links
@cindex DBM links
DBM links provide access to data stored in a data base
(using the unix dbm or gdbm library).

@table @code
@item @code{type_string:}
@code{"DBM"}
@item @code{mode_string:}
@code{""} // mode is set by first read to "r"
@*@code{"r"} // read mode
@*@code{"rw"} // read and overwrite mode
@item @code{arguments:}
filename
@item @strong{Usage}
@code{read} ( link ) @expansion{} string
@*returns the key of the next entry of the data base
@sp 1
@code{read} ( link , key ) @expansion{} string
@*@code{read} returns the value to the key from the data base
@sp 1
@code{write} ( link , key , value )
@*inserts the pairs of strings (key, value) into the data base
(requires mode @code{"rw"})
@sp 1
@code{write} ( link , key )
@*delete the pair with key @code{key} from the data base
(requires mode @code{"rw"})
@item @strong{Restrictions:}
Arguments to @code{read} and @code{write} must be strings.
@item @strong{Example:}
@example
@c example
  link dbmLink="DBM:rw example";
  write(dbmLink,"1","abc");
  write(dbmLink,"3","XYZ");
  write(dbmLink,"2","ABCc");
  dbmLink;
  close(dbmLink);
  // read all keys (till empty string):
  read(dbmLink);
  read(dbmLink);
  read(dbmLink);
  read(dbmLink);
  // read data corresponding to key "1"
  read(dbmLink,"1");
  // read all data:
  read(dbmLink,read(dbmLink));
  read(dbmLink,read(dbmLink));
  read(dbmLink,read(dbmLink));
  // close
  close(dbmLink);
@c example
@end example
@end table
@c ---------------------------------------
@node procedures, maps, links, Expressions
@section procedures
@cindex procedures

Procedures are user defined functions with an arbritrary number of arguments
of any type which return a result.
They contain sequences of @sc{Singular} commands in a special format.
Procedures are used to extend the set of functions with your own functions.
Procedures are kept in the main memory (or in library files, see @ref{LIB}).
You can also store more than one procedure in a single file
(see @ref{procedures and Libraries}).
(E.g. the file @code{sing.lib} may contain the procedures @code{milnor} and @code{tjurina}.
After reading @code{sing.lib} the functions @code{milnor} and @code{tjurina} may be used
as if they were @sc{Singular} functions.) @*
Procedures can be "called" like a normal function by
typing their name followed by the list of arguments
in parentheses. If the procedure is not already in
main memory it will be loaded and kept there. The call then executes
the sequence of commands stored in the specified procedure.
@* See @ref{proc}; @ref{LIB}.
@c ---------------------------------------
@node maps, untyped definitions, procedures, Expressions
@section maps
@cindex maps

Maps are ring maps from a preimage ring into the base ring.
Note that the target of a map is ALWAYS the actual base ring.
Maps between rings with different coefficient fields are
possible, the map of the coefficients is defined in the following way:
@table @asis
@item Z/p -> Q
@tex
$[i]_p \rightarrow i \in [-p/2,p/2] \subseteq $Z
@end tex
@ifinfo
[i]_p -> i in [-p/2,p/2] in Z
@end ifinfo
@item Z/p -> Z/p'
@tex
$[i]_p \in $Z/p$ \rightarrow i \in [-p/2,p/2] \subseteq $Z$ \rightarrow [i]_{p'} \in $Z/p'
@end tex
@ifinfo
[i]_p in Z/p -> i in [-p/2,p/2] in Z -> [i]_p' in Z/p'
@end ifinfo
@item Q -> Z/p
@itemx Q -> (Z/p)(a,..)
@itemx Q -> Q(a,..)
@itemx Z/p ->(Z/p)(a,...)
as usual
@end table
See @ref{map}; @ref{imap}; @ref{fetch}; @ref{subst}.
@c ---------------------------------------
@node untyped definitions, expression list, maps, Expressions
@section untyped definitions
@cindex untyped definitions

Objects may also be defined without a type: they get their
type from the first assignment to them.
E.g. @code{ideal i=x,y,z; def j=i^2;} defines the ideal @code{i^2}
with the name @code{j}.
@*Note: Unlike other assignments a ring as an untyped object
is not a copy but another reference to the same ring.
@example
  ring r;
  def s=basering;
  setring s;
@end example
defines a ring @code{s} which is just another reference (or name)
for the @code{basering}. This is useful if the basering
is not local to the procedure (so it cannot be accessed by its name)
but you need a name for it (e.g. for a use with @code{setring} or @code{map}).
@code{setring r;} does not work in this case, because
@code{r} may not be local to the procedure.
@* See @ref{def}.
@c ---------------------------------------
@node expression list, block, untyped definitions,Expressions
@section expression list
@cindex expression list
An expression list is any comma separated list of expressions.
@*@strong{Example:}
@example
@c example
  ring r;
  poly f=x2-y3;
  int i=37;
  string s1="abc";
  string s2="def";
  string s=s1,s2; // typecast from expression list to string
  s;
  s1,s2;
  f,i,s;
@c example
@end example
@c ------------------------------
@node block,implicit type conversions,expression list,Expressions
@section block
@cindex block
A block is a sequence of commands surrounded by @{ and @}. Blocks
are used for proc, if, else, while and for statements.
@example
  @{
     command;
     @dots{}
  @}
@end example
@menu
* if::
* for::
* while::
* proc::
@end menu
@iftex
See @ref{if}; @ref{for}; @ref{while}; @ref{proc}
@end iftex
@c ------------------------------
@node implicit type conversions, type casting, block, Expressions
@section implicit type conversions
@cindex implicit type conversions
Assignments convert the type of an expression to the type
of the left-hand side of the assignment.
Operations, which require certain
types of operands can also implicitly convert the type of an
expression (e.g. you can multiply a polynomial by an integer because
the integer is automatically converted to polynomial).
Possible conversions are:
@* @sp 1
@enumerate
@item
@code{int} @expansion{} @code{poly}
@item
@code{int} @expansion{} @code{number}
@item
@code{number} @expansion{} @code{poly}
@item
@code{int} @expansion{} @code{vector}
(i @expansion{} i*gen(1))
@item
@code{poly} @expansion{} @code{vector}
(p @expansion{} p*gen(1))
@item
@code{int} @expansion{} @code{intvec}
@item
@code{intvec} @expansion{} @code{intmat}
@item
@code{matrix} @expansion{} @code{module}
@item
@code{vector} @expansion{} @code{module}
@item
@code{ideal} @expansion{} @code{module}
@item
@code{ideal} @expansion{} @code{matrix}
@item
@code{vector} @expansion{} @code{matrix}
@item
@code{module} @expansion{} @code{matrix}
@item
@code{intvec} @expansion{} @code{matrix}
@item
@code{intmat} @expansion{} @code{matrix}
@item
@code{string} @expansion{} @code{proc}
@item
@code{resolution} @expansion{} @code{list}
@item
@code{list} @expansion{} @code{resolution}.
@end enumerate

Note that type conversions do not act transitively.
@c ---------------------------------
@node type casting, ,implicit type conversions,Expressions
@section type casting
@cindex type casting
An expression can be converted to another type by using a type name
as a function returning this type.
Possible type castings are:
@enumerate
@item
to @code{string} from @code{int}, @code{number}, @code{poly}, @code{vector},
 @code{ideal}, @code{matrix}, @code{module}, @code{map}, @code{proc}
@item
to @code{int} from @code{number}, @code{poly}
@item
to @code{number} from @code{poly}
@item
to @code{poly} from @code{int}, @code{number}
@item
to @code{ideal} from @code{vector}, @code{poly},
@code{matrix}, @code{int}, @code{number}
@item
to @code{ideal} from expression lists of @code{poly},
@code{int}, @code{number}. (The list may be empty)
@item
to @code{ideal} from @code{matrix}, @code{vector}, @code{poly}, @code{module}
@item
to @code{matrix} from @code{module}, @code{ideal}, @code{vector}.
@* There are two forms to convert something to a matrix:
if @code{matrix(xx)} is used then the size of the matrix will
be determined by xx.
But @code{matrix(xx,a,b)} may also be used - the result is
an a x b matrix.
@item
to @code{intvec} from expression lists of @code{int}. (The list may be empty)
@item
to @code{module} from expression lists of @code{vector}
@code{int}, @code{number}, @code{poly}. (The list may be empty)
@item
to @code{module} from @code{matrix}, @code{vector}, @code{ideal}.
@item
to @code{list} from expression lists of any type. (The list may be empty)
@end enumerate
@strong{Examples:}
@example
@c example
  ring r=0,x,(c,dp);
  number(3x);
  number(poly(3));
  ideal i=1,2,3,4,5,6;
  print(matrix(i));
  print(matrix(i,3,2));
  vector v=[1,2];
  print(matrix(v));
  module(matrix(i,3,2));
@c example
@end example
@c ---------------------------------------
@node Commands, procedures and Libraries, Expressions, Top
@chapter Commands
@cindex Commands
@ifinfo
@*List of all supported commands.
@end ifinfo
@menu
* Declaration commands::
* Functions::
* Control structures::
* Proc commands::
* Other commands::
* System variables::
@end menu
@c ---------------------------------------
@node Declaration commands, Functions, Commands, Commands
@section Declaration commands
@cindex Declaration commands

The general syntax for a declaration command is
@*
  type name [ @code{=} expression ] @code{;}
@*
where type stands for one of the data types of @sc{Singular},
name for the name of the object you are creating and expression
is any expression of the type or one that can be converted to the type
of the object (see @ref{Expressions}).
The expression is defaulted whenever possible. @*
It is possible to redefine or overwrite an already existing object
(as an object of the same type).
A redefinition will
first set the variable to the default value and then compute the expression.
The difference between redefinition and overwriting is shown in the following
example:
@*
@*@strong{Example:}
@example
@c example
  int i=3;
  i=i+1;        // overwriting
  i;
  int i=i+1;   // redefinition
  i;
@c example
@end example
@ifinfo
@*List of all supported declaration commands.
@end ifinfo
@menu
* int::
* string::
* intvec::
* intmat::
* ring::
* poly::
* number::
* ideal::
* vector::
* module::
* matrix::
* map::
* qring::
* dring::
* list::
* def::
* proc::
* link::
@end menu
@c ---------------------------------------
@node int, string, Declaration commands, Declaration commands
@subsection int
@cindex int

@table @code
@item @strong{Syntax:}
@code{int} name @code{=} int_expression @code{;}
@item @strong{Purpose:}
define an integer variable
@item @strong{Default:}
0
@item @strong{Example:}
@example
@c example
  int i = 42;
  int j = i + 3; j;
  i = i * 3 - j; i;
  int k;   // assigning the default value 0 to k
  k;
@c example
@end example
@end table
@menu
* int expression::
@end menu
@iftex
See @ref{int expression}.
@end iftex
@c ---------------------------------------
@node string, intvec, int, Declaration commands
@subsection string
@cindex string

@table @code
@item @strong{Syntax:}
@code{string} name @code{=} string_expression @code{;}
@item @strong{Purpose:}
define a string variable
@item @strong{Default:}
"" (the empty string)
@item @strong{Example:}
@example
@c example
  string s1="Now I know";
  string s2="how to encode a \" in a string...";
  string s=s1+" "+s2; // concatenation of 3 strings
  s;
  s1,s2;   // 2 strings, separated by a blank in the output:
@c example
@end example
@end table
@menu
* string expression::
@end menu
@iftex
See @ref{string expression}.
@end iftex
@c ---------------------------------------
@node intvec, intmat, string, Declaration commands
@subsection intvec
@cindex intvec

@table @code
@item @strong{Syntax:}
@code{intvec} name @code{=} intvec_expression @code{;}
@item @strong{Purpose:}
define an intvec variable
@item @strong{Default:}
0
@item @strong{Example:}
@example
@c example
  intvec iv=1,3,5,7,8;
  iv;
  iv[4];
  iv[3..size (iv)];
@c example
@end example
@end table
@menu
* intvec expression::
@end menu
@iftex
See @ref{intvec expression}.
@end iftex
@c ---------------------------------------
@node intmat, ring, intvec, Declaration commands
@subsection intmat
@cindex intmat

@table @code
@item @strong{Syntax:}
@code{intmat} name @code{=} intmat_expression @code{;}
@*@code{intmat} name @code{[} rows @code{] [} cols @code{] =} intmat_expression @code{;}
@*@code{intmat} name @code{[} rows @code{] [} cols @code{] =} list_of_int_expressions @code{;}
@item @strong{Purpose:}
define an intmat variable
@* The int_list fills up the matrix beginning with the first row
from the left to the right, then the second row and so on.
If the int_list contains less than rows*cols elements,
the matrix is filled up with zeros; if it contains more
elements, then only the first rows*cols elements are used.
@item @strong{Default:}
0 (1 x 1 matrix)
@item @strong{Example:}
@example
@c example
  intmat im[2][3]=1,3,5,7,8;
  im;
  im[2,2];
@c example
@end example
@end table
@menu
* intmat expression::
@end menu
@iftex
See @ref{intmat expression}.
@end iftex
@c ---------------------------------------
@node ring, poly, intmat, Declaration commands
@subsection ring
@cindex ring
@cindex basering

@table @code
@item @strong{Syntax:}
@example
  @code{ring} name @code{=} field@code{,}
              @code{(} names_of_ring_variables @code{),}
              @code{(} ordering @code{);}
@end example
@item @strong{Default:}
@example
  32003,(x,y,z),dp;
@end example
@item @strong{Purpose:}
define a base ring for polynomials, ideals, vectors, modules
and matrices and set it as the actual basering

All advanced algorithm in @sc{Singular} require a ring.
The last defined ring is the basering until a new ring is defined
or until it is changed with @code{setring} or @code{keepring} or
it gets killed.

The coefficient field is given by either
@table @bullet
@item
the characteristic (0 or a prime <= 32003)
@item
an expression_list of the characteristic and
the names of  parameters.
If there is only one parameter you may define a minimal polynomial for it
to work in an algebraic extension of Q or F(p).
See @ref{minpoly}
@item
an expression_list of the number of element
(a small prime characteristic p to the power of a small exponent n) and a
name for a primitive element (generating the multiplicative group).
The maximal values for p and n depend on the files in the directory @code{gftables}.
They define the finite field with p^n elements.
@item
the name @code{real}. The field elements will be the machine floating
point numbers.
@end table
@*If you write a  characteristic which is not a prime,
it is automatically converted
to the next lower prime or you receive an error message.

The names of ring variables
are like variable names (comma separated).

The ordering is a list
of blockorderings which have an order keyword
(lp, ls, dp, ds, Dp, Ds, wp, ws, Wp, Ws, M, c, a) and an optional number of variables
(for lp, ls, dp, ds, Dp, Ds) or a list of
weights (for wp, ws, Wp, Ws, a and M).
If none of the orderings C or c (order by components) is given,
C will be appended at the end of the list of orderings.
@*
If one element of the list consists of only one entry, the parentheses may
be omitted.
@item @strong{Example:}
@example
  ring r =
  32003,       // coefficient field: Z/32003
  ( x,y,z ),   // names for variables
  ds;          // monomial ordering
               // (degrevlex in a series ring)
               // parenthesis of lists with only one element
               // are optional
@end example
@example
  ring r2=10,(x(1..6)),(lp(2),dp(4));
               // defines a ring with name r2,
               // (10 is substituted by the next lower prime)
               // coefficient field: Z/7
               // variables x(1),x(2),..,x(6)
               // which is the polynomial ring (Z/7)[x(1),..,x(6)]
               // with lexicographical ordering on x(1) and x(2)
               // and then
               // degree reverse lexicographical on x(3)..x(6)
@end example
@example
  ring r3=0,(x,y,z,a,b,c),(ds(3), dp(3));
               // defines a ring with name r3,
               // coefficient field Q
               // variables x,y,z,a,b,c
               // which is the ring (Q[a,b,c])[x,y,z]_(x,y,z)
@end example
@example
  ring r4=0,(x,y,z),(c,dp);
               // defines a ring with name r4,
               // coefficient field Q (rationals)
               // variables x,y,z
               // which is the polynomial ring Q[x,y,z]
               // with ordering of vectors by
               // first number of the component and then
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r5=(7,a),(x,y,z),dp;
               // defines a ring with name r5,
               // coefficient field K=(Z/7)(a)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // with ordering
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r6=(7,a),(x,y,z),dp;
  minpoly=a^2+a+3;
               // defines a ring with name r6,
               // coefficient field K=(Z/7)[a]/a^2+a+3
               // (the finite field with 49 elements)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // with ordering
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r7=(7^2,a),(x,y,z),dp;
                // defines a ring with name r7,
                // the same ring as r6
                // this option is offered for
                // a few powers of primes
                // (see file gftable/49)
                // the computations are faster
                //   in this representation
@end example
@example
  ring r8=(181,A,B,Z),(x,y,z),dp;
               // defines a ring with name r8
               // coefficient field K=Z/181(A,B,Z)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r9=real,(x,y,z),dp;
               // defines a ring with name r9
               // coefficient field R
               // (represented as floating point numbers)
               // variables x,y,z
               // which is the polynomial ring R[x,y,z]
               // degree reverse lexicographical on x,y,z
  number n=1.7e+2; // input format of real numbers
@end example

@item @strong{Note:}
Computations in rings with one parameter are faster
than computations with more parameters. (Cancellation of common factors
are only implemented in the first case)

@* Computation over the field @code{real} has computing errors because
of rounding.
@item @strong{Use in proc:}
All changes of the base ring by a definition
of a new ring or a setring command in a proc are local to this proc
(i.e. will not affect the calling procedure)
unless a @code{keepring} command is used.
@end table
@menu
* Baserings and ground fields::
* ring::
* Monomial orderings::
* qring:: define quotient rings
* alternating:: define supercommutative superalgebras
* dring:: define Weyl algebras
* charstr:: the coefficient field
* npars:: number of parameters
* nvars:: number of variables
* ordstr:: the monomial ordering
* parstr:: the parameters
* par:: the parameter as number
* varstr:: the ring variables
* var:: the ring variables as poly
* setring:: a local ring change
* keepring:: ring change in the next (upper) level
@end menu
@iftex
See @ref{Baserings and ground fields}; @ref{ring}; @ref{Monomial orderings};
@ref{qring}; @ref{alternating}; @ref{dring}; @ref{charstr}; @ref{npars};
@ref{nvars}; @ref{ordstr};
@ref{varstr}; @ref{var}; @ref{setring}; @ref{keepring}.
@end iftex
@c ---------------------------------------
@node poly, number, ring, Declaration commands
@subsection poly
@cindex poly

@table @code
@item @strong{Syntax:}
@code{poly} name @code{=} poly_expression @code{;}
@item @strong{Purpose:}
define a polynomial
@item @strong{Default:}
0
@item @strong{Example:}
@example
  ring r = 32003,(x,y,z),dp;
  poly s1  = x3y2+151x5y+186xy6+169y9;
  poly s2  = 1*x^2*y^2*z^2+3z8;
  poly s3  = 5/4x4y2+4/5*x*y^5+2x2y2z3+y7+11x10;
  int a,b,c,t=37,5,4,1;
  poly f=3*x^a+x*y^(b+c)+t*x^a*y^b*z^c;
@end example
@end table
@menu
* poly expression::
@end menu
@iftex
See @ref{poly expression}.
@end iftex
@c ---------------------------------------
@node number, ideal, poly, Declaration commands
@subsection number
@cindex number

@table @code
@item @strong{Syntax:}
@code{number} name @code{=} number_expression @code{;}
@item @strong{Purpose:}
define a number
@item @strong{Default:}
0
@item @strong{Example:}
@example
@c example
  ring r = 32003,(x,y,z),dp;
  number n = 4/6;
  n;
  ring r0 = 0,x,dp;
  number n = 4/6;
  n;
  ring R=real,x,dp;
  number n=4/6;
  n;
  n=0.25e+2;
  n;
@c example
@end example
@end table
@menu
* number expression::
@end menu
@iftex
See @ref{number expression}.
@end iftex
@c ---------------------------------------
@node ideal, vector, number, Declaration commands
@subsection ideal
@cindex ideal

@table @code
@item @strong{Syntax:}
@code{ideal} name @code{=} list_of_poly_expressions @code{;}
@*@code{ideal} name @code{=} ideal_expression @code{;}
@item @strong{Purpose:}
define an ideal
@item @strong{Default:}
0
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  poly s1 = x2;
  poly s2 = y3;
  poly s3 = z;
  ideal i =  s1, s2-s1, s2*s3, s3^4;
  i;
  ideal j = i^2;
  // generators i[k]*i[l], 1<=k<=l<=size(i);
  ideal IJ = i*j;
  // generators i[k]*j[l], 1<=k<=size(i), 1<=l<=size(j)
  size(j), size(IJ);
@c example
@end example
@end table
@menu
* ideal expression::
* poly expression::
@end menu
@iftex
See @ref{ideal expression}; @ref{poly expression}.
@end iftex
@c ---------------------------------------
@node vector, module, ideal, Declaration commands
@subsection vector
@cindex vector

@table @code
@item @strong{Syntax:}
@code{vector} name @code{=} vector_expression @code{;}
@item @strong{Purpose:}
define a vector of polynomials (an element of a sub-module of a free module)
@item @strong{Default:}
[0]
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),(c,dp);
  poly s1 = x2;
  poly s2 = y3;
  poly s3 = z;
  vector v = [s1, s2-s1, s3-s1]+ s1*gen(5);
  // v is a vector in the free module of rank 5
  v;
@c example
@end example
@end table
@menu
* vector expression::
* module expression::
@end menu
@iftex
See @ref{vector expression}; @ref{module expression}.
@end iftex
@c ---------------------------------------
@node module, matrix, vector, Declaration commands
@subsection module
@cindex module

@table @code
@item @strong{Syntax:}
@code{module} name @code{=} list_of_vector_expressions @code{;}
@*@code{module} name @code{=} module_expression @code{;}
@item @strong{Purpose:}
define a module
@item @strong{Default:}
[0]
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),(c,dp);
  vector s1 = [x2,y3,z];
  vector s2 = [xy,1,0];
  vector s3 = [0,x2-y2,z];
  poly   f  = xyz;
  module m = s1, s2-s1,f*(s3-s1);
  // show m in the matrix format (columns generate m)
  print(m);
@c example
@end example
@end table
@menu
* module expression::
* vector expression::
@end menu
@iftex
See @ref{module expression};
@ref{vector expression}.
@end iftex
@c ---------------------------------------
@node matrix, map, module, Declaration commands
@subsection matrix
@cindex matrix

@table @code
@item @strong{Syntax:}
@code{matrix} name@code{[}rows@code{][}cols@code{] =} list_of_poly_expressions @code{;}
@*@code{matrix} name = matrix_expression @code{;}
@item @strong{Purpose:}
define a matrix

The poly_list fills up the matrix beginning with the first row
from the left to the right, then the second row and so on.
If the poly_list contains less than rows*cols elements,
the matrix is filled up with zeros; if it contains more
elements, then only the first rows*cols elements are used.
If the right-hand side is a matrix expression
the matrix on the left-hand side becomes the same size as the right-hand side,
otherwise the size is determined by the left-hand side.
If the size is omitted a 1x1 matrix will be created.
@item @strong{Default:}
0 (1 x 1 matrix)
@item @strong{Example:}
@example
@c example
  int ro = 3;
  ring r = 32003,(x,y,z),dp;
  poly f=xyz;
  poly g=z*f;
  ideal i=f,g,g^2;
  matrix m[ro][3] = 1x3y4, 0, i, f ; // a 3 x 3 matrix
  m;
  print(m);
  matrix A;   // the 1 x 1 zero matrix
  matrix C=m; // defines C as a 3 x 3 matrix equal to m
  print(C);
@c example
@end example
@end table
@menu
* matrix expression::
* poly expression::
@end menu
@iftex
See @ref{matrix expression}; @ref{poly expression}.
@end iftex
@c ---------------------------------------
@node  map, qring, matrix, Declaration commands
@subsection map
@cindex map

@table @code
@item @strong{Syntax:}
@code{map} name @code{=} preimage_ring_name @code{,} ideal_expression @code{;}
@item @strong{Purpose:}
define a ring map from preimage_ring to basering
@sp 1
map the variables of the preimage ring to the generators of the ideal.
If the ideal contains less elements than variables in the
preimage_ring the remaining variables are maped to 0, if the ideal contains
more elements these are ignored.
The image ring is always the actual base ring.
For the mapping of coefficients from different fields see @ref{maps}.
@item @strong{Default:}
none
@item @strong{Apply a map:}
the name of a map serves as the function which maps objects from the
preimage_ring into the base ring.  These objects must be defined
by names (no evaluation in the preimage ring is possible).
@*Maps may be composed.
@item @strong{Remark:}
There are standard mappings for the identity map: @code{fetch} and @code{imap}.
@item @strong{Example:}
@example
@c example
  ring r1=32003,(x,y,z),dp;
  ideal i=x,y,z;
  ring r2=32003,(a,b),dp;
  map f=r1,a,b,a+b;
  // maps from r1 to r2,
  // x to a, y to b and z to a+b
  f(i);
  // operations like f(i[1]) or f(i*i) are not allowed
  ideal i=f(i);
  // objects in different rings may have the same name
  map g   = r2,a2,b2;
  map phi = g(f);
  // composition of map f and g
  // maps from r1 to r2,
  // x to a2, y to b2, z to a2+b2
  phi(i);
@c example
@end example
@end table
@menu
* maps::
* ideal expression::
* ring::
* fetch::
* imap::
@end menu
@iftex
See @ref{maps}; @ref{ideal expression}; @ref{ring};
@ref{imap}; @ref{fetch}.
@end iftex
@c ---------------------------------------
@node  qring, dring, map, Declaration commands
@subsection qring
@cindex qring

@table @code
@item @strong{Syntax:}
@code{qring} name @code{=} ideal_expression @code{;}
@item @strong{Purpose:}
define a quotient ring as the base ring modulo a standard basis

The ideal must be a standard basis.
The qring command performs a change of the base ring to this
new ring.
@item @strong{Default:}
none
@item @strong{Example:}
@example
@c example
  ring r1=32003,(x,y,z),dp;
  ideal i=std(ideal(x,y));
  qring q=i;
  basering;
  std(ideal(x+y,x+y+z,z));
@c example
@end example
@end table
@menu
* ideal expression::
* ring::
@end menu
@iftex
See @ref{ideal expression}; @ref{ring}.
@end iftex
@c ---------------------------------------
@node  dring, list, qring, Declaration commands
@subsection dring
@cindex dring

@table @code
@item @strong{Syntax:}
@example
  @code{dring} name @code{=} field@code{,}
              @code{(} names_of_ring_variables @code{),}
              @code{(} ordering @code{);}
@end example
@item @strong{Purpose:}
define a Weyl algebra
@sp 1
For each of the variables x_i an additional variable dx_i
is created which is the differentiation operator by x_i.
@*The allowed orderings are @code{dp} and @code{Dp} (at the moment).
@sp 1
By default ideals are set of differential operators (polynomials
in x_i and dx_i), which  operate on modules.
This can be changed by the predefined attribute @code{D}, see @ref{attrib}.
@item @strong{Default:}
none
@item @strong{Example:}
@example
  dring w=0,(x),(c,dp);
  // the ring variables are dx and x with dx*x=x*dx+1
  ideal i=x,dx;
  i[1]*i[2];
  @expansion{} x*dx
  i[2]*i[1];
  @expansion{} x*dx+1
  module m=[x];
  dx*m[1];
  @expansion{} [1]
@end example
@end table
@menu
* ring::
@end menu
@iftex
See @ref{ring}.
@end iftex

@strong{Note:} These rings are only available in those versions of
@sc{Singular} which are compiled with the DRING option.
The DRING version is
significantly slower for usual (commutative) ring operations.
@c ---------------------------------------
@node  list, def, dring, Declaration commands
@subsection list
@cindex list

@table @code
@item @strong{Syntax:}
@code{list} name @code{=} expression_list@code{;}
@*@code{list} name @code{=} list_expression@code{;}
@item @strong{Purpose:}
define a list
@item @strong{Default:}
empty list
@item @strong{Example:}
@example
@c example
  list l=1,"str";
  l[1];
  l[2];
  ring r;
  ideal i = x^2, y^2 + z^3;
  l[3] = i;
  l;
@c example
@end example
@end table
@menu
* type casting::
* expression list::
* list expression::
@end menu
@iftex
See @ref{type casting}; @ref{expression list}; @ref{list expression}.
@end iftex

@strong{Note:} If one element of a list belongs to a ring, the whole
list belongs to that ring.
@c ---------------------------------------
@node  def, proc, list, Declaration commands
@subsection def
@cindex def

@table @code
@item @strong{Syntax:}
@code{def} name @code{=} expression @code{;}
@item @strong{Purpose:}
define an object of the same type as the right-hand side
@item @strong{Default:}
none
@item @strong{Note:}
This is useful if the right-hand side may be of
variable type as a consequence of a computation (e.g. ideal or module or
matrix ..)
@item @strong{Example:}
@example
@c example
  def i=2;
  typeof(i);
@c example
@end example
@end table
@menu
* untyped definitions::
* typeof::
@end menu
@iftex
See @ref{untyped definitions}; @ref{typeof}.
@end iftex
@c ---------------------------------------
@node proc, link, def,  Declaration commands
@subsection proc
@cindex proc
@table @code
@item @strong{Syntax:}
@code{proc} name block
@*@code{proc} name parameter_list block
@item @strong{Purpose:}
define a new function
@item @strong{Default:}
none
@item @strong{Example (for a procedure without an argument list):}
@example
  // this proc tests if it is called with exactly one argument n
  // and print the numbers 1 to n
  // If the proc is called without an argument or with more
  //  than one argument, a message is displayed
  // # is a reserved name and denotes the list of arguments,
  // #[i] is the i-th argument
  proc print_n
  @{
    if (size(#) != 1)
    @{
      "USAGE: print_n ( int_expression );";
      return();
    @}
    int i;
    for(i=1;i<=#[1];i=i+1)
    @{
      i;
    @}
  @}

  print_n();
  @expansion{} USAGE: print_n ( int_expression );
  print_n(1+2);
  @expansion{} 1
  @expansion{} 2
  @expansion{} 3
  print_n(1,2);
  @expansion{} USAGE: print_n ( int_expression );
@end example
@end table
For a description of the paramter_list see @ref{parameter list}.
A convenient and recommended way to define procedures is to prepare a file
(see @ref{procedures and Libraries})
and read this file with the @code{LIB} command.
The difference between procedures from libraries and
other procedures is the missing help and example part
which may be provided in a library file.
@menu
* LIB::
* procedures and Libraries::
* procedures::
* proc in a library::
* Examples::
* block::
* return::
@end menu
@iftex
See @ref{LIB}; @ref{procedures}; @ref{Examples}; @ref{block}; @ref{return}.
@end iftex
@c ---------------------------------------
@node link,,proc,  Declaration commands
@subsection link
@cindex link
@table @code
@item @strong{Syntax:}
@code{link} name @code{=} string_expression @code{;}
@item @strong{Purpose:}
defines a new communcation link
@item @strong{Default:}
stdin/stdout
@item @strong{Example:}
@example
  link l=":w example.txt";
  int i=22;
  string s="An int follows:";
  write(l,s,i);
  l;
  close(l);
  read(l);
  l;
  read(l);
  close(l);
@end example
@end table
@menu
* links::
* read::
* write::
* open::
* close::
@end menu
@iftex
See @ref{links}; @ref{read}; @ref{write}; @ref{open}; @ref{close}.
@end iftex
@c ---------------------------------------
@node Functions, Control structures, Declaration commands, Commands
@section Functions
@cindex Functions

The general syntax for a function is
@*
  [target @code{=} ] function_name @code{(} parameters @code{);}
@*
If no target is specified, the result is printed.
@* In the following, @strong{Type} means the return type of the function.
@ifinfo
@*List of all supported functions.
@end ifinfo
@menu
* bareiss::
* betti::
* char::
* char_series::
* charstr::
* cleardenom::
* coef::
* coeffs::
* contract::
* defined::
* deg::
* delete::
* det::
* diff::
* dim::
* eliminate::
* extgcd::
* facstd::
* factorize::
* fetch::
* fglm::
* find::
* finduni::
* freemodule::
* gcd::
* gen::
* hilb::
* homog::
* imap::
* indepSet::
* insert::
* interred::
* intersect::
* jacob::
* jet::
* kbase::
* koszul::
* lead::
* leadcoef::
* leadexp::
* lift::
* liftstd::
* maxideal::
* memory::
* minbase::
* minor::
* minres::
* modulo::
* mres::
* mstd::
* mult::
* nameof::
* names::
* ncols::
* nrows::
* npars::
* nvars::
* ord::
* ordstr::
* par::
* pardeg::
* parstr::
* preimage::
* prime::
* prune::
* qhweight::
* quotient::
* random::
* read::
* reduce::
* regularity::
* res::
* reservedName::
* resultant::::
* rvar::
* simplify::
* size::
* sortvec::
* sres::
* status::
* std::
* stdfglm::
* stdhilbert::
* subst::
* syz::
* trace::
* transpose::
* typeof::
* var::
* varstr::
* vdim::
* wedge::
* weight::
@end menu
@c ---------------------------------------
@node bareiss, betti, Functions, Functions
@subsection bareiss
@cindex bareiss

@table @code
@item @strong{Syntax:}
@code{bareiss (} matrix_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
applies Bareiss' algorithm to a matrix
Result is a triangular matrix.
@item @strong{Example:}
@example
@c example
  ring r2=0,(x(1..12)),ds;
  matrix m[5][5]=maxideal(1),maxideal(1);
  print(m);
  m=bareiss(m);
  print(m);
  m[3,2];
@c example
@end example
@end table
@menu
* matrix::
* matrix expression::
@end menu
@iftex
See @ref{matrix}; @ref{matrix expression}.
@end iftex
@c ---------------------------------------
@node betti, char, bareiss, Functions
@subsection betti
@cindex betti
@table @code
@item @strong{Syntax:}
@code{betti (} list_expression @code{)}
@*@code{betti (} resolution @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
@tex
compute the graded Betti numbers of
$R^n/M$, if $R$ denotes the basering and
$M$ a homogeneous submodule of $R^n$ and the argument represents a
resolution of
$R^n/M$:
@end tex
@iftex
@*
@end iftex
@tex
The entry d at (i,j) is the minimal number of generators in degree i+j of
the j-th syzygy module of $R^n/M$ (the 0-th (resp.1-st) syzygy module of
$R^n/M$ is
$R^n$ (resp. $M$)).
@end tex
@ifinfo
compute the graded Betti numbers of
R^n/M, if R denotes the basering and
M a homogeneous submodule of R^n and the argument represents a resolution of
R^n/M:
@*The entry d at (i,j) is the minimal number of generators in degree i+j of
the j-th syzygy module of R^n/M (the 0-th (resp.1-st) syzygy module of R^n/M is
R^n (resp. M)).
@end ifinfo
The argument is considered to be the result of a res/sres/mres command.
(Only the initial monomials are considered for the computation
of the graded Betti numbers.)
@item @strong{Example:}
@example
@c example
  ring r=32003,(a,b,c,d),dp;
  ideal j=bc-ad,b3-a2c,c3-bd2,ac2-b2d;
  list T=mres(j,0); // 0 forces a full resolution
  print(T[1]); // a minimal set of generators for j
  print(T[2]); // the first syzygy module (minimal generating set)
  print(T[3]); // the second syzygy module (minimal generating set)
  print(T[4]);
  betti(T);
  // most useful for reading off the graded Betti numbers:
  print(betti(T),"betti");
@c example
@end example
@end table
@menu
* res::
* mres::
* sres::
* print::
* list expression::
@end menu
@iftex
See @ref{res}; @ref{mres}; @ref{sres}; @ref{print}; @ref{list expression}.
@end iftex
@c ---------------------------------------
@node char, char_series, betti, Functions
@subsection char
@cindex char

@table @code
@item @strong{Syntax:}
@code{char (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the characteristic of the coefficient field of a ring
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),dp;
  char(r);
@c example
@end example
@end table
@menu
* ring::
* charstr::
@end menu
@iftex
See @ref{ring}; @ref{charstr}.
@end iftex
@c ---------------------------------------
@node char_series, charstr, char, Functions
@subsection char_series
@cindex char_series

@table @code
@item @strong{Syntax:}
@code{char_series (} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
the rows of the matrix represent the irreducible characteristic series of the
ideal with respect to the current variable ordering
@*See Shang-Ching Chou, Mechanical Geometry Theorem Proving (D. Reidel Publishing Company, 1988)
or Dongming Wang, Characteristic Sets and Zero Structure of Polynomial Sets
(Lecture Notes, RISC-Linz, Johannes Kepler University, 1989).
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y,z),dp;
  print(char_series(ideal(xyz,xz,y)));
@c example
@end example
@item @strong{Background:}
@tex
Let $>$ be the lexicographical ordering $x_1 < ... < x_n$ on $R=K[x_1,...,x_n]$.
For $f \in R$ let lvar(f) (the leading variable of f) be the largest
variable in lead(f) (the leading term of f with respect to $>$),
i.e. if $f=a_k(x_1,...,x_{k-1})x_k^s+...+a_0(x_1,...,x_{k-1})$ for some
$k \leq n$ then $lvar(f)=x_k$, moreover let $ini(f):=a_k(x_1,...,x_{k-1})$.

A set $T=\{f_1,...,f_r\} \subset R$ is called triangular if $lvar(f_1)<...<lvar(f_r)$.
The pseudoremainder $r=prem(g,f)$ of $g$ with respect to $f$ is defined by
$ini(f)^a*g=q*f+r$ with the property $deg_{lvar(f)}(r)<deg_{lvar(f)}(f)$,
a minimal.

(T,U) is called a triangular system, if T is a triangular set such that ini(T)
does not vanish on $Zero(T) \setminus Zero(U)
( =:Zero(T\setminus U))$.

T is called irreducible if for every i there are no $d_i$,$f_i'$,$f_i''$ with
the property:
$$   lvar(d_i)<lvar(f_i) $$
$$   lvar(f_i')=lvar(f_i'')=lvar(f_i)$$
$$   0 \not\in prem(\{ d_i, ini(f_i'), ini(f_i'')\},\{ f_1,...,f_(i-1)\})$$
such that $prem(d_i*f_i-f_i'*f_i'',\{f_1,...,f_(i-1)\})=0$.

(T,U) is irreducible if T is irreducible.

Let $G=\{g_1,...,g_s\}$ then there are irreducible triangular sets $T_1,...,T_l$
such that $Zero(G)=\bigcup(i=1..l: Zero(T_i\setminus I_i))$
where $I_i=\{ini(f), f \in T_i \}$.
@end tex
@ifinfo
Let > be the lexicographical ordering x_1 < ... < x_n on R=K[x_1,...,x_n].
For f in R let lvar(f) (the leading variable of f) be the largest
variable in lead(f) (the leading term of f with respect to >),
i.e. if f=a_k(x_1,...,x_(k-1))x_k^s+...+a_0(x_1,...,x_(k-1)) for some
k<=n then lvar(f)=x_k, moreover let ini(f):=a_k(x_1,...,x_(k-1)).

A set T=@{f_1,...,f_r@} in R is called triangular if lvar(f_1)<...<lvar(f_r).
The pseudoremainder r=prem(g,f) of g with respect to f is defined by
ini(f)^a*g=q*f+r with the property deg_(lvar(f))(r)<deg_(lvar(f))(f),s
a minimal.

(T,U) is called a triangular system, if T is a triangular set such that ini(T)
does not vanish on the zero set of T \ zero set of U
( =:Zero(T\U)).

T is called irreducible if for every i there are no d_i,f_i',f_i'' with
the property:
@*   lvar(d_i)<lvar(f_i)
@*   lvar(f_i')=lvar(f_i'')=lvar(f_i)
@*   0 not in prem(@{ d_i, ini(f_i'), ini(f_i'')@},@{ f_1,...,f_(i-1)@})
@*such that prem(d_i*f_i-f_i'*f_i'',@{f_1,...,f_(i-1)@})=0.

(T,U) is irreducible if T is irreducible.

Let G=@{g_1,...,g_s@} then there are irreducible triangular sets T_1,...,T_l
such that Zero(G)=Union(i=1..l: Zero(T_i\I_i))
where I_i=@{ini(f), f in T_i @}.
@end ifinfo
@item @strong{Example:}
@example
@c example
  ring R= 0,(x,y,z,u),dp;
  ideal i=-3zu+y2-2x+2,
          -3x2u-4yz-6xz+2y2+3xy,
          -3z2u-xu+y2z+y;
  print(char_series(i));
@c example
@end example
@end table
@c ---------------------------------------
@node charstr, cleardenom, char_series, Functions
@subsection charstr
@cindex charstr

@table @code
@item @strong{Syntax:}
@code{charstr (} ring_name @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the description of the coefficient field of a ring
@item @strong{Example:}
@example
@c example
  ring r= (32003,a),(x,y),dp;
  char(r);
  charstr(r);
@c example
@end example
@end table
@menu
* ring::
* char::
* varstr::
* ordstr::
@end menu
@iftex
See @ref{ring}; @ref{char}; @ref{ordstr}; @ref{varstr}.
@end iftex
@c ---------------------------------------
@node cleardenom, coef, charstr, Functions
@subsection cleardenom
@cindex cleardenom

@table @code
@item @strong{Syntax:}
@code{cleardenom (}poly_expression@code{)}
@*@code{cleardenom (}vector_expression@code{)}
@item @strong{Type:}
same as the input type
@item @strong{Purpose:}
multiply a polynomial/vector by a suitable constant to cancel
all denominators from its coefficients and then divide it by its content.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  poly f=(3x+6y)^5;
  f;
  cleardenom(f);
@c example
@end example
@end table
@c @menu
@c * poly expression::
@c @end menu
@c @iftex
@c See @ref{poly expression}.
@c @end iftex
@c ---------------------------------------
@node coef, coeffs, cleardenom, Functions
@subsection coef
@cindex coef

@table @code
@item @strong{Syntax:}
@code{coef (}poly_expression @code{,} product_of_ringvars @code{)}
@*@code{coef (}vector_expression@code{,} product_of_ringvars@code{,} matrix_name@code{,} matrix_name @code{)}
@item @strong{Type:}
matrix in the first case
@*none in the second case
@item @strong{Purpose:}
determine the monomials in f occurring in m, where f is the first argument
and m the second argument.

First case:  return a 2 x n matrix M, n being the number
of the determined monomials.
The first row consists of these monomials, the second row
of the corresponding coefficients of the monomials in f.
Thus f = M[1,1]*M[2,1]+..+M[1,n]*M[2,n].

Second case: the first matrix (i.e. the 3rd argument) will contain the
monomials, the second (i.e. the 4th argument)  the corresponding coefficients of the monomials in the vector.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  poly f=x5+5x4y+10x2y3+y5;
  matrix m=coef(f,y);
  print(m);
  f=x^20+xy+x2y;
  print(coef(f,xy));
  vector v=[f,zy+77+xy];
  print(v);
  matrix mc;matrix mm;
  coef(v,y,mc,mm);
  print(mc);
  print(mm);
@c example
@end example
@end table
@menu
* poly expression::
* coeffs::
@end menu
@iftex
See @ref{poly expression}; @ref{coeffs}.
@end iftex
@c ---------------------------------------
@node coeffs, contract, coef, Functions
@subsection coeffs
@cindex coeffs

@table @code
@item @strong{Syntax:}
@code{coeffs (}poly_expression @code{,} ring_variable @code{)}
@*@code{coeffs (}ideal_expression@code{,} ring_variable @code{)}
@*@code{coeffs (}vector_expression@code{,} ring_variable @code{)}
@*@code{coeffs (}module_expression@code{,} ring_variable @code{)}
@*@code{coeffs (}poly_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (}ideal_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (}vector_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (}module_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
develop each polynomial from the first argument, say @code{J},
(poly_expression/ .. /module_expression) as a univariate polynomial
in the given ring_variable,
say @code{z}, and return the coefficients as a @code{k} x @code{d}
matrix @code{M},
where:
@* @code{d-1} = maximum @code{z}-degree of all occuring polynomials
@* @code{k}   = 1 in case of a polynomial resp. number of generators
in case of an ideal;
in case of a vector or a module this procedure is repeated for each
component and the resulting matrices are appended.
@*If a third argument is present, say @code{T},
it contains the coefficients such that
@*  @code{matrix(J) = T*M}.
@*Thus the j-th generator of an ideal @code{J} is equal to
@*
@tex
$J[j] = z^0*M[1,j] + z^1*M[2,j] + ... + z^{d-1}*M[d,j]$,
@end tex
@ifinfo
J[j] = z^0*M[1,j] + z^1*M[2,j] + ... + z^(d-1)*M[d,j],
@end ifinfo
@*while for a module @code{J} the i-th component of the j-th generator is equal to the
entry _[i,j] of matrix(@code{J}) and we get
@*
@tex
$[i,j] = z^0*M[(i-1)*d+1,j] + z^1*M[(i-1)*d+2,j] + ... + z^{d-1}*M[i*d,j]$
@end tex
@ifinfo
_[i,j] = z^0*M[(i-1)*d+1,j] + z^1*M[(i-1)*d+2,j] + ... + z^(d-1)*M[i*d,j]
@end ifinfo
@item @strong{Example:}
@example
@c example
  ring r;
  poly f=(x+y)^5;
  matrix M=coeffs(f,y);
  print(M);
  ideal i=f,xyz+z^10*y^7;
  print(coeffs(i,y));
@c example
@end example
@end table
@menu
* poly expression::
* coef::
@end menu
@iftex
See @ref{poly expression}; @ref{coef}.
@end iftex
@c ---------------------------------------
@node contract, defined, coeffs, Functions
@subsection contract
@cindex contract

@table @code
@item @strong{Syntax:}
@code{contract (}ideal_expression@code{,} ideal_expression@code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
contract each of the n elements of the second ideal J
by each of the m elements of the first ideal I,
producing a m x n matrix.
@*Contraction is defined on monomials by:
@*
@ifinfo
contract( x^A , x^B) := x^(B-A) (if B>=A elementwise), 0 otherwise
@end ifinfo
@tex
$${\rm contract}(x^A ,  x^B) := \cases{ x^{(B-A)}, &if $B\ge A$ elementwise\cr 0,&otherwise.\cr}$$
@end tex
where A and B are the multiexponents of the ring variables represented by x.
@code{contract} is extended bilinearly to all polynomials.
@item @strong{Example:}
@example
@c example
  ring r=0,(a,b,c,d),dp;
  ideal I=a2,a2+bc,abc;
  ideal J=a2-bc,abcd;
  print(contract(I,J));
@c example
@end example
@end table
@menu
* diff::
* ideal expression::
@end menu
@iftex
See @ref{diff}; @ref{ideal expression}.
@end iftex
@c ---------------------------------------
@node defined, deg, contract, Functions
@subsection defined
@cindex defined

@table @code
@item @strong{Syntax:}
@code{defined (} name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns a value !=0 (TRUE) if there is an userdefined object with this name,
and 0 (FALSE) otherwise
@*A nonzero return value is the level where the object is defined (level
1 denotes the top level, level 2 the level of a first procedure, level 3
the level of a procedure called by a procedure, etc.).
Local objects may be identified by @code{if (defined(..)==voice) ..}.
@item @strong{Example:}
@example
@c example
  ring r= 0,(x,y),dp;
  matrix m[5][6]= x,y,1,2,0,x+y;
  defined(mm);
  defined(r) and defined(m);
@c example
@end example
@end table
@menu
* voice::
@end menu
@iftex
See @ref{voice}.
@end iftex
@c ---------------------------------------
@node deg, delete, defined, Functions
@subsection deg
@cindex deg

@table @code
@item @strong{Syntax:}
@code{deg (} poly_expression @code{)}
@*@code{deg (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the maximal (weighted) degree of
the terms of a polynomial or a vector;
@*deg(0) is -1
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),lp;
  deg(x3+y4+xyz3);
  ring r=7,(x,y),wp(2,3);
  poly f=x2+y3;
  deg(f);
  ring R=7,(x,y),ws(2,3);
  poly f=x2+y3;
  deg(f);
  vector v=[x2,y];
  deg(v);
@c example
@end example
@end table
@menu
* ord::
* poly expression::
* vector expression::
@end menu
@iftex
See @ref{ord}; @ref{poly expression}; @ref{vector expression}.
@end iftex
@c ---------------------------------------
@node delete, det, deg, Functions
@subsection delete
@cindex delete

@table @code
@item @strong{Syntax:}
@code{delete (} list_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
delete the element with the given index from a list (the input will not be changed)
@item @strong{Example:}
@example
@c example
  list l="a","b","c";
  list l1=delete(l,2);l1;
  l;
@c example
@end example
@end table
@menu
* list::
* list expression::
* insert::
@end menu
@iftex
See @ref{list}; @ref{list expression}; @ref{insert}.
@end iftex
@c ---------------------------------------
@node det, diff, delete, Functions
@subsection det
@cindex det

@table @code
@item @strong{Syntax:}
@code{det (} intmat_expression @code{)}
@*@code{det (} matrix_expression @code{)}
@item @strong{Type:}
int or poly
@item @strong{Purpose:}
return the determinant of a square matrix
@item @strong{Example:}
@example
@c example
  ring r=7,(x,y),wp(2,3);
  matrix m[3][3]=1,2,3,4,5,6,7,8,x;
  det(m);
@c example
@end example
@end table
@menu
* matrix expression::
@end menu
@iftex
See @ref{matrix expression}.
@end iftex
@c ---------------------------------------
@node diff, dim, det, Functions
@subsection diff
@cindex diff

@table @code
@item @strong{Syntax:}
@code{diff (} poly_expression@code{,} ring_variable @code{)}
@*@code{diff (} vector_expression@code{,} ring_variable @code{)}
@*@code{diff (} ideal_expression@code{,} ring_variable @code{)}
@*@code{diff (} module_expression@code{,} ring_variable @code{)}
@*@code{diff (} matrix_expression@code{,} ring_variable @code{)}
@*@code{diff (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
the same as the type of the first argument
respective matrix for diff (ideal_expression, ideal_expression )
@item @strong{Purpose:}
partial derivative of a polynomial object by a ring variable
(first forms)
@*respective differentiate each element (1..n) of the second ideal
by the differential operator corresponding to each element (1..m) in the first
ideal, producing a m x n matrix
@item @strong{Example:}
@example
@c example
  ring r= 0,(x,y,z),dp;
  poly f=2*x^3*y+3*z^5;
  diff(f,x);
  diff(f,z);
  vector v=[f,y2+z];
  diff(v,z);
  ideal i=x2,x2+yz,xyz;
  ideal j=x2-yz,xyz;
  print(diff(i,j));
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
* ideal expression::
* module expression::
* matrix expression::
* contract::
* jacob::
* var::
@end menu
@iftex
See @ref{poly expression};
@ref{vector expression};
@ref{ideal expression};
@ref{module expression};
@ref{matrix expression};
@ref{contract};
@ref{jacob};
@ref{var};
@end iftex
@c ---------------------------------------
@node dim, eliminate, diff, Functions
@subsection dim
@cindex dim

@table @code
@item @strong{Syntax:}
@code{dim (} ideal_expression @code{)}
@*@code{dim (} modul_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
compute the dimension of the ideal/module generated by
the leading monomials of the generators representing the given
ideal/module. This is also the dimension of the ideal if it is represented by
a standard basis. Note that the dimension of an ideal I means
the Krull dimension of the base ring modulo I.
@*The dimension of a
module is the dimension of its annihilator ideal.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal I=std(ideal(x2,xy,y5));
  dim(I);
@c example
@end example
@end table
@menu
* ideal::
* std::
* degree::
* vdim::
* mult::
@end menu
@iftex
See @ref{ideal}; @ref{std}; @ref{degree}; @ref{vdim}; @ref{mult}.
@end iftex
@c ---------------------------------------
@node eliminate, extgcd, dim, Functions
@subsection eliminate
@cindex eliminate

@table @code
@item @strong{Syntax:}
@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
eliminate variables occurring as factors of the second argument from an
ideal/module by intersection with the subring not containing these variables.
@*@code{eliminate} does not need a special orderinmg nor a standard basis as input.

@*Since elimination is expensive, it might be useful,
first to compute the Hilbert function of the ideal (first argument)
with a fast ordering (e.g. dp). Then make use of it to speed up
the computation: a Hilbert-driven elimanation uses the intvec
provided as the third argument.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal i=x2,xy,y5;
  eliminate(i,x);
  ring R=0,(x,y,t,s,z),dp;
  ideal i=x-t,y-t2,z-t3,s-x+y3;
  eliminate(i,ts);
  intvec v=hilb(std(i),1);
  eliminate(i,ts,v);
@c example
@end example
@end table
@menu
* ideal::
* module::
* std::
* hilb::
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{ideal}; @ref{module}; @ref{std}; @ref{hilb};
@ref{ideal expression};
@ref{module expression}.
@end iftex
@c ---------------------------------------
@node extgcd, facstd, eliminate, Functions
@subsection extgcd
@cindex extgcd

@table @code
@item @strong{Syntax:}
@code{extgcd (} int_expression@code{,} int_expression @code{)}
@*@code{extgcd (} poly_expression@code{,} poly_expression @code{)}
@item @strong{Type:}
list of 3 objects of the same type as the type of the arguments
@item @strong{Purpose:}
extended gcd: the first element is the greatest common divisor
of the two arguments,
the second and third are factors such that if @code{list L=extgcd(a,b);}
then L[1]=a*L[2]+b*L[3].
@item @strong{Note:}
polynomials must be univariate to apply @code{extgcd}
@item @strong{Example:}
@example
@c example
  extgcd(2,3);
  ring r=0,(x,y),lp;
  extgcd((x2+x3)*(x2-x3),(x2+x5)*(x2+x3));
@c example
@end example
@end table
@menu
* gcd::
* int expression::
* poly expression::
@end menu
@iftex
See @ref{gcd};
@ref{int expression};
@ref{poly expression}
@end iftex
@c ---------------------------------------
@node facstd, factorize, extgcd, Functions
@subsection facstd
@cindex facstd

@table @code
@item @strong{Syntax:}
@code{facstd (} ideal_expression @code{)}
@*@code{facstd (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
list of ideals
@item @strong{Purpose:}
factorizing Groebner basis algorithm: returns a list of Groebner bases.
@*The intersection of these ideals has the same zero set as the input,
i.e. the radical of the intersection coincides with the radical of the input
ideal.
In many cases (but not all!) this is already a decomposition of the radical
of the ideal. (Note however, that, in general, no inclusion holds.)
@*The second, optional argument gives a list of polynomials which define
non-zero constraints. Hence, the intersection of the output ideals
has a zero set which is the (closure of the) complement of the zero set
of the second argument in the zero set of the first argument.
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y,z),(c,dp);
  ideal I=xyz,x2z;
  facstd(I);
  facstd(I,x);
@c example
@end example
@end table
@menu
* std::
* ring::
* ideal expression::
@end menu
@iftex
See @ref{std};
@ref{ring};
@ref{ideal expression}.
@end iftex
@c ---------------------------------------
@node factorize, fetch, facstd, Functions
@subsection factorize
@cindex factorize

@table @code
@item @strong{Syntax:}
@code{factorize (} poly_expression @code{)}
@*@code{factorize (} poly_expression@code{, 0 )}
@*@code{factorize (} poly_expression@code{, 2 )}
@item @strong{Type:}
list of ideal and intvec
@item @strong{Syntax:}
@code{factorize (} poly_expression@code{, 1 )}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
compute the irreducible factors (as an ideal) of the polynomial
together with or without
the multiplicities (as an intvec) depending on the second argument:
@*0: returns factors and multiplicities, first factor is a constant.
May also be written with only one argument
@*1: returns non-constant factors
@*2: returns non-constant factors and multiplicities
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  factorize(9*(x-1)^2*(y+z));
  factorize(9*(x-1)^2*(y+z),1);
  factorize(9*(x-1)^2*(y+z),2);
@c example
@end example
@end table
@menu
* poly expression::
@end menu
@iftex
See @ref{poly expression}
@end iftex
@c ---------------------------------------
@node fetch, fglm, factorize, Functions
@subsection fetch
@cindex fetch

@table @code
@item @strong{Syntax:}
@code{fetch (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
map objects between "almost identical" rings.@*
@code{fetch} is the
identity map between rings, qrings and drings with the same
coefficient field and the same number of variables (but possible with
different orderings), the i-th variable of the source ring is mapped to
the i-th variable of the base ring.
This offers a convinient way to change variable names or map objects from a
ring to a quotient ring of that ring or vice versa.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal i=maxideal(3);
  ideal j=std(i);
  poly f=x+y2+z3;
  vector v=[f,1];
  qring q=j;
  poly f=fetch(r,f);
  f;
  vector v=fetch(r,v);
  v;
  ideal i=fetch(r,i);
  i;
  ring rr=0,(a,b,c),lp;
  poly f=fetch(q,f);
  f;
  vector v=fetch(r,v);
  v;
  ideal k=fetch(q,i);
  k;
@c example
@end example
@end table
@menu
* ring::
* qring::
* dring::
* imap::
@end menu
@iftex
See @ref{ring}; @ref{qring}; @ref{dring};
@ref{imap}.
@end iftex
@c ---------------------------------------
@node fglm, find, fetch, Functions
@subsection fglm
@cindex fglm

@table @code
@item @strong{Syntax:}
@code{fglm (} ring_name@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
calculate the Groebner basis in the current ring for the given ideal.
@*The ideal must be zero dimensional and given as a reduced Groebner
basis in the given ring.
The result will be a reduced Groebner basis.
@*The only difference between the given ring and the current ring
may be the monomial ordering and a permutation of the variables
resp. parameters.
@c @item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),Dp;
  ideal i=y3+x2, x2y+x2, x3-x2, z4-x2-y;
  option(redSB);   // force the computation of a reduced SB
  i=std(i);
  vdim(i);
  ring s=0,(z,x,y),lp;
  ideal j=fglm(r,i);
  j;
@c example
@end example
@end table
@menu
* ring::
* qring::
* std::
* option::
* vdim::
@end menu
@iftex
See @ref{ring}; @ref{qring};
@ref{std}; @ref{option}; @ref{vdim}.
@end iftex
@c ---------------------------------------
@node find, finduni, fglm, Functions
@subsection find
@cindex find
@table @code
@item @strong{Syntax:}
@code{find (} string_expression@code{,} substring_expression @code{)}
@*@code{find (} string_expression@code{,} substring_expression@code{,} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the position of the substring
in the string or 0 (if not found),
@*start the search at the position given in the 3rd argument
@item @strong{Example:}
@example
@c example
  find("Aac","a");
  find("abab","a"+"b");
  find("abab","a"+"b",2);
  find("abab","ab",3);
  find("0123","abcd");
@c example
@end example
@end table
@menu
* string expression::
@end menu
@iftex
See @ref{string expression}.
@end iftex
@c ---------------------------------------
@node finduni, freemodule, find, Functions
@subsection finduni
@cindex finduni
@table @code
@item @strong{Syntax:}
@code{finduni (} ideal_expression@code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:} 
the ith generator of the returned ideal is a univariate
polynomial of minimal degree in the ith (ring) variable such that this
polynomial belongs to the given ideal.  
@*The ideal must be zero
dimensional and given as a reduced Groebner basis in the current ring.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y), dp;
  ideal k = jacob(x5+y11+xy9+x3y9);
  option(redSB);  // force computation of reduced basis
  k=std(k);
  finduni(k);
@c example
@end example
@end table
@menu
* ring::
* std::
* option::
* vdim::
@end menu
@iftex
See @ref{ring}; 
@ref{std}; @ref{option}; @ref{vdim}.
@end iftex
@c ---------------------------------------
@node freemodule, gcd, finduni, Functions
@subsection freemodule
@cindex freemodule

@table @code
@item @strong{Syntax:}
@code{freemodule (} int_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
create the free module of rank n generated by
gen(1), @dots{} , gen(n)
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),(c,dp);
  freemodule(3);
@c example
@end example
@end table
@menu
* gen::
* module expression::
@end menu
@iftex
See @ref{gen}; @ref{module expression}.
@end iftex
@c ---------------------------------------
@node gcd, gen, freemodule, Functions
@subsection gcd
@cindex gcd

@table @code
@item @strong{Syntax:}
@code{gcd (} int_expression@code{,} int_expression @code{)}
@*@code{gcd (} poly_expression@code{,} poly_expression @code{)}
@item @strong{Type:}
the same as the type of the arguments
@item @strong{Purpose:}
compute the greatest common divisor
@item @strong{Example:}
@example
@c example
  gcd(2,3);
  ring r=0,(x,y,z),lp;
  gcd(3x2*(x+y),9x*(y2-x2));
@c example
@end example
@end table
@menu
* extgcd::
* int expression::
* poly expression::
@end menu
@iftex
See @ref{extgcd};
@ref{int expression};
@ref{poly expression}
@end iftex
@c ----------------------------------------
@node gen, hilb, gcd, Functions
@subsection gen
@cindex gen

@table @code
@item @strong{Syntax:}
@code{gen (} int_expression @code{)}
@item @strong{Type:}
vector
@item @strong{Purpose:}
return the i-th free generator of a free module
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y,z),(c,dp);
  gen(3);
  vector v=gen(5);
  poly f= xyz;
  v=v+f*gen(4); v;
  ring rr= 32003,(x,y,z),dp;
  fetch(r,v);
@c example
@end example
@end table
@menu
* int expression::
* vector::
@end menu
@iftex
See @ref{int expression}; @ref{vector}.
@end iftex
@c ---------------------------------------
@node hilb, homog, gen, Functions
@subsection hilb
@cindex hilb
@table @code
@item @strong{Syntax:}
@code{hilb (} ideal_expression @code{)}
@*@code{hilb (} module_expression @code{)}
@*@code{hilb (} ideal_expression@code{,} int_expression @code{)}
@*@code{hilb (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
none (if called with one argument)
@*intvec (if called with two arguments)
@item @strong{Purpose:}
compute the Hilbert series of the ideal/module
defined by the leading terms of the generators
of the given ideal/module.   If the input is
homogeneous (all variable weights 1) and a standard basis,
this will be the Hilbert series of the original
ideal/module
@sp 1
@*with one argument: print first and second Hilbert series
@*with two arguments: return the n-th Hilbert series as intvec (n=1,2)
@item @strong{Example:}
@example
@c example
  ring R=32003,(x,y,z),dp;
  ideal i=x2,y2,z2;
  ideal s=std(i);
  hilb(s);
  hilb(s,1);
  hilb(s,2);
@c example
@end example
@item @strong{Background:}
@tex
Let M $=\bigoplus M_i$ be a graded module over $K[x_1,...,x_n]$.
The Hilbert series  of M is the power series
$$H_M(t)=\sum_{i=-\infty}^\infty dim_K M_i t^i$$
It turns out that $H_M(t)$ can be written in two useful ways:
$$H_M(t)={Q(t)\over (1-t)^n}={P(t)\over (1-t)^{dim(M)}}$$
where Q(t) and P(t) are polynomials from Z[t].
Q(t) is called first Hilbert series, and P(t) the second Hilbert series.
@end tex
@ifinfo
Let M =(+) M_i be a graded module over K[x_1,...,x_n].
The Hilbert series  of M is the power series
H_M(t)=sum_i dim_K (M_i)*t^i.
It turns out that H_M(t) can be written in two useful ways:
H_M(t)=Q(t)/(1-t)^n=P(t)/(1-t)^dim(M).
where Q(t) and P(t) are polynomials from Z[t].
Q(t) is called first Hilbert series, and P(t) the second Hilbert series.
@end ifinfo
@end table
@menu
* ideal expression::
* module expression::
* std::
@end menu
@iftex
See @ref{ideal expression};
@ref{module expression};
@ref{std}.
@end iftex
@c ---------------------------------------
@node homog, imap, hilb, Functions
@subsection homog
@cindex homog

@table @code
@item @strong{Syntax:}
@code{homog (} ideal_expression @code{)}
@*@code{homog (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
tests for homogeneity: return 1 for homogeneous input, 0 otherwise
@item @strong{Syntax:}
@*@code{homog (} polynomial_expression@code{,} ring_variable @code{)}
@*@code{homog (} vector_expression@code{,} ring_variable @code{)}
@*@code{homog (} ideal_expression@code{,} ring_variable @code{)}
@*@code{homog (} module_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
same as first argument
@item @strong{Purpose:}
homogenize polynomials, vectors, ideals or modules by multiplying
each monomial with a suitable power of the given ring variable (which must have
weight 1)
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),ds;
  poly s1=x3y2+x5y+3y9;
  poly s2=x2y2z2+3z8;
  poly s3=5x4y2+4xy5+2x2y2z3+y7+11x10;
  ideal i=s1,s2,s3;
  homog(s2,z);
  homog(i,z);
  homog(i);
  homog(homog(i,z));
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{poly expression}; @ref{vector expression}; @ref{ideal expression};
@ref{module expression}.
@end iftex
@c ---------------------------------------
@node imap, indepSet, homog, Functions
@subsection imap
@cindex imap

@table @code
@item @strong{Syntax:}
@code{imap (} ring_name @code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
identity map on common subrings.@*
@code{imap} is the
map between rings, qrings and drings with the same
coefficient field which is the identity on variables of
the same name and 0 otherwise.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal i=x,y+z,2xz;
  ring R=0,(a,b,x,y,c),lp;
  ideal i=imap(r,i);
  i;
@c example
@end example
@end table
@menu
* ring::
* qring::
* dring::
* fetch::
@end menu
@iftex
See @ref{ring}; @ref{qring}; @ref{dring};
@ref{fetch}.
@end iftex
@c ---------------------------------------
@node indepSet, insert, imap, Functions
@subsection indepSet
@cindex indepSet

@table @code
@item @strong{Syntax:}
@code{indepSet (} ideal_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
compute a maximal set U of independent variables of the ideal given
by a standard basis:
If v is the result then
v[i] is 1 if the i-th variable of the ring is an independent variable.
Hence the set U conisting of the variables x(i) s.t. v[i]=1 is a maximal
independent set.
@c Indeed we compute a maximal strongly independent set U,
@c where no power of a variable from U occurs as a leading term ofs
@c a standard basis of the ideal.


U is a set of independent variables iff
@tex
$I \cap K[U]=(0)$ is,
@end tex
@ifinfo
I intersect K[U]=(0),
@end ifinfo
i.e. eliminating the remaining variables gives (0).
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal I=xy,xz,yz;
  indepSet(std(I));
  eliminate(I,yz);
@c example
@end example
@end table
@menu
* std::
* ideal expression::
@end menu
@iftex
See @ref{std}; @ref{ideal expression}.
@end iftex
@c ---------------------------------------
@node insert, interred, indepSet, Functions
@subsection insert
@cindex insert

@table @code
@item @strong{Syntax:}
@code{insert (} list_expression @code{,} expression @code{)}
@*@code{insert (} list_expression @code{,} expression @code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
insert a new element into a list at the beginning
or (if called with 3 arguments) after the given position
(the input will not be changed)
@item @strong{Example:}
@example
@c example
  list L=1,2;
  insert(L,4,2);
  insert(L,4);
@c example
@end example
@end table
@menu
* list::
* list expression::
* delete::
@end menu
@iftex
See @ref{list}; @ref{list expression}; @ref{delete}.
@end iftex
@c ---------------------------------------
@node interred, intersect, insert, Functions
@subsection interred
@cindex interred
@table @code
@item @strong{Syntax:}
@code{interred (} ideal_expression @code{)}
@*@code{interred (} module_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
interreduce a set of polynomials/vectors
@*
@ifinfo
input: f_1,@dots{},f_n
@end ifinfo
@tex
input: $f_1,...,f_n$
@end tex
@*
@ifinfo
output: g1,@dots{},gs with s<=n and the properties
@end ifinfo
@tex
output: $g_1,...,g_s$ with $s<=n$ and the properties
@end tex
@itemize @bullet
@item
@ifinfo
(f1,@dots{},fn) = (g1,@dots{},gs)
@end ifinfo
@tex
$(f_1,...,f_n) = (g_1,...,g_s)$
@end tex
@item
@ifinfo
L(g_i)<>L(g_j) for all i<>j
@end ifinfo
@tex
L($g_i)\neq $L($g_j$) for all $i\neq j$
@end tex
@item
in the case of a global ordering (polynomial ring):
@*
@ifinfo
L(gi)
@end ifinfo
@tex
$L(g_i)$
@end tex
 does not divide m for all monomials m of
@ifinfo
@{g1,@dots{},g(i-1),g(i+1),@dots{},gs@}
@end ifinfo
@tex
$\{g_1,...,g_{i-1},g_{i+1},...,g_s\}$
@end tex
@item
in the case of a local or mixed ordering (localization of polynomial ring):
@*if, for any i<>j, L(
@ifinfo
gi
@end ifinfo
@tex
$g_i$
@end tex
) | L(
@ifinfo
gj
@end ifinfo
@tex
$g_j$
@end tex
) then ecart(
@ifinfo
gi
@end ifinfo
@tex
$g_i$
@end tex
) > ecart(
@ifinfo
gj
@end ifinfo
@tex
$g_j$
@end tex
)
@end itemize
Remark: L(g) denotes the leading term of g and ecart(g)=deg(g)-deg(L(g)).
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal i=x2+z,z,2z;
  interred(i);
  ring R=0,(x,y,z),ds;
  ideal i=zx+y3,z+y3,z+xy;
  interred(i);
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
* std::
@end menu
@iftex
See
@ref{ideal expression};
@ref{module expression};
@ref{std}.
@end iftex
@c ---------------------------------------
@node intersect, jacob, interred, Functions
@subsection intersect
@cindex intersect
@table @code
@item @strong{Syntax:}
@code{intersect (} expression_list of ideal_expression @code{)}
@*@code{intersect (} expresion_list of module_expression @code{)}
@item @strong{Type:}
ideal resp. module
@item @strong{Purpose:}
ideal or module intersection
@*If the option @code{computeSB} is in effect
the result will be a standard basis.
@item @strong{Example:}
@example
@c example
  ring R=0,(x,y),dp;
  ideal i=x;
  ideal j=y;
  intersect(i,j);
  ring r=181,(x,y,z),(c,ls);
  ideal id1=maxideal(3);
  ideal id2=x2+xyz,y2-z3y,z3+y5xz;
  ideal id3=intersect(id1,id2,ideal(x,y));
  id3;
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
* expression list::
* option::
@end menu
@iftex
See @ref{ideal expression};
@ref{module expression};
@ref{expression list};
@ref{option}.
@end iftex
@c ---------------------------------------
@node jacob, jet, intersect, Functions
@subsection jacob
@cindex jacob
@table @code
@item @strong{Syntax:}
@code{jacob (} poly_expression @code{)}
@*@code{jacob (} ideal_expression @code{)}
@item @strong{Type:}
ideal, if the input is a polynomial
@* matrix, if the input is an ideal
@item @strong{Purpose:}
compute the jacobi ideal/matrix generated by all partial
derivatives of the input
@item @strong{Example:}
@example
@c example
  ring R;
  poly f=x^2+y^3+z^5;
  jacob(f);
  ideal i=jacob(f);
  print(jacob(i));
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
* diff::
* nvars::
@end menu
@iftex
See @ref{ideal expression};
@ref{module expression};
@ref{diff};
@ref{nvars}.
@end iftex
@c ---------------------------------------
@node jet, kbase, jacob, Functions
@subsection jet
@cindex jet
@table @code
@item @strong{Syntax:}
@code{jet (} poly_expression@code{,} int_expression @code{)}
@*@code{jet (} vector_expression@code{,} int_expression @code{)}
@*@code{jet (} ideal_expression@code{,} int_expression @code{)}
@*@code{jet (} modul_expression@code{,} int_expression @code{)}
@*@code{jet (} poly_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} vector_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} ideal_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} modul_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
delete from the first argument all terms of degree (resp. weighted degree where
the weights are given by the third argument) bigger than the second
argument
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,dp);
  jet(1+x+x2+x3+x4,3);
  poly f=1+x+y+z+x2+xy+xz+y2+x3+y3+z4;
  jet(f,3);
  intvec iv=2,1,1;
  jet(f,3,iv);
  // the part of f with (total) degree >3:
  f-jet(f,3);
  // the homogeneous part of f of degree 2:
  jet(f,2)-jet(f,1);
  // the absolute term of f:
  jet(f,0);
  // now for other types:
  ideal i=f,x,f*f;
  jet(i,2);
  vector v=[f,1,x];
  jet(v,1);
  jet(v,0);
  v=[f,1,0];
  module m=v,v,[1,x2,z3,0,1];
  jet(m,2);
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
* ideal expression::
* module expression::
* int expression::
* intvec expression::
@end menu
@iftex
See @ref{poly expression}; @ref{vector expression};
@ref{ideal expression};
@ref{module expression};
@ref{int expression};
@ref{intvec expression}.
@end iftex
@c ---------------------------------------
@node kbase, koszul, jet, Functions
@subsection kbase
@cindex kbase
@table @code
@item @strong{Syntax:}
@code{kbase (} ideal_expression @code{)}
@*@code{kbase (} module_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
compute a vector space basis (consisting of monomials)
of the quotient of the ring by an ideal
resp. of a free module by a module in case this is finite dimensional
(and if the input is a standard basis with respect to the ring ordering).
If the input is no standard basis, the leading terms of the input are
used and the result may have no meaning.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),ds;
  ideal i=x2,y2,z;
  kbase(std(i));
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
* vdim::
@end menu
@iftex
See @ref{ideal expression}; @ref{module expression}; @ref{vdim}.
@end iftex
@c ---------------------------------------
@node koszul, lead, kbase, Functions
@subsection koszul
@cindex koszul
@table @code
@item @strong{Syntax:}
@code{koszul (} int_expression@code{,} int_expression @code{)}
@*@code{koszul (} int_expression@code{,} ideal_expression @code{)}
@*@code{koszul (} int_expression@code{,} int_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
@code{koszul(d,n)} computes a matrix of the Koszul relations of degree d of
the first n ring variables
@*@code{koszul(d,id)} computes a matrix of the Koszul relations of degree d of
the generators of the ideal @code{id}
@*@code{koszul(d,n,id)} computes a matrix of the Koszul relations of degree d of
the first n generators of the ideal @code{id}
@*(koszul(1,id),koszul(2,id),... build a complex, that is @code{koszul(i,id)*koszul(i+1,id)}=0.)
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  print(koszul(3,2));
  ideal I=xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z;
  print(koszul(1,I));
  print(koszul(2,I));
  print(koszul(2,I)*koszul(3,I));
@c example
@end example
@end table
@menu
* int expression::
* ideal expression::
* matrix expression::
@end menu
@iftex
See @ref{int expression}; @ref{matrix expression}.
@end iftex
@c -------------------------------------------------
@node lead, leadcoef, koszul, Functions
@subsection lead
@cindex lead
@table @code
@item @strong{Syntax:}
@code{lead (} poly_expression @code{)}
@*@code{lead (} vector_expression @code{)}
@*@code{lead (} ideal_expression @code{)}
@*@code{lead (} module_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
returns the leading (or initial) term(s) of a polynomial, a vector,
or of the generators of an ideal or module with respect
to the monomial ordering.
@cindex IN
@item @strong{Note:}
@code{IN} may be used instead of @code{lead}.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,ds);
  poly f=x2+y+z3;
  vector v=[x^10,f];
  ideal i=f,z;
  module m=v,[0,0,1+x];
  lead(f);
  lead(v);
  lead(i);
  lead(m);
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{poly expression};
@ref{vector expression};
@ref{ideal expression};
@ref{module expression}.
@end iftex
@c -------------------------------------------------
@node leadcoef, leadexp, lead, Functions
@subsection leadcoef
@cindex leadcoef
@table @code
@item @strong{Syntax:}
@code{leadcoef (} poly_expression @code{)}
@*@code{leadcoef (} vector_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
returns the leading (or initial) coefficient of a polynomial or a vector
with respect to the monomial ordering
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),ds;
  poly f=x2+y+z3;
  vector v=[2*x^10,f];
  leadcoef(f);
  leadcoef(v);
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
@end menu
@iftex
See @ref{poly expression};
@ref{vector expression}.
@end iftex
@c -------------------------------------------------
@node leadexp, lift, leadcoef, Functions
@subsection leadexp
@cindex leadexp
@table @code
@item @strong{Syntax:}
@code{leadexp (} poly_expression @code{)}
@*@code{leadexp (} vector_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
returns the exponent vector of the leading monomial of a polynomial or a vector
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,ds);
  poly f=x2+y+z3;
  vector v=[2*x^10,f];
  leadexp(f);
  leadexp(v);
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
@end menu
@iftex
See @ref{poly expression};
@ref{vector expression}.
@end iftex
@c -------------------------------------------------
@node lift, liftstd, leadexp, Functions
@subsection lift
@cindex lift
@table @code
@item @strong{Syntax:}
@code{lift (} ideal_expression@code{,} subideal_expression @code{)}
@*@code{lift (} module_expression@code{,} submodule_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
compute the transformation matrix which expresses the generators of a
submodule in terms of the generators of a module
(which may be given by a standard basis or not (use two different algorithms)).
@*Hence, if @code{sm} is the submodule (or ideal), @code{m} the
module (or ideal) and @code{T} the transformation matrix
then @code{matrix(sm)=matrix(m)*T}
and @code{sm=module(matrix(m)*T)} (or @code{sm=ideal(matrix(m)*T)}).
@*Gives a warning if @code{sm} is not a submodule.
@item @strong{Example:}
@example
@c example
  ring r;
  ideal m=3x2+yz,7y6+2x2y+5xz;
  poly f=y7+x3+xyz+z2;
  ideal i=jacob(f);
  matrix T=lift(i,m);
  matrix(m)-matrix(i)*T;
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{ideal expression};
@ref{module expression}.
@end iftex
@c -----------------------------------------
@node liftstd, maxideal, lift, Functions
@subsection liftstd
@cindex liftstd
@table @code
@item @strong{Syntax:}
@code{liftstd (} ideal_expression@code{,} matrix_name @code{)}
@*@code{liftstd (} module_expression@code{,} matrix_name @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a standard basis of an ideal or module and the transformation
matrix from the given ideal/module to the standard basis.
@*Hence, if @code{m} is the ideal or module, @code{sm} its standard basis
and @code{T} the transformation matrix then @code{matrix(sm)=matrix(m)*T}
and @code{sm=ideal(matrix(m)*T)} respectivly @code{sm=module(matrix(m)*T)}.
@item @strong{Example:}
@example
@c example
  ring R=0,(x,y,z),dp;
  poly f=x3+y7+z2+xyz;
  ideal i=jacob(f);
  matrix T;
  ideal sm=liftstd(i,T);
  sm;
  print(T);
  matrix(sm)-matrix(i)*T;
@c example
@end example
@end table
@menu
* ideal::
* ring::
* option::        Sets certain strategies.
* std::
* matrix::
@end menu
@iftex
See @ref{ideal}; @ref{ring}; @ref{option}; @ref{std}; @ref{matrix}.
@end iftex
@c ---------------------------------------
@node maxideal, memory, liftstd, Functions
@subsection maxideal
@cindex maxideal
@table @code
@item @strong{Syntax:}
@code{maxideal (} int_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the power given by int_expression of the maximal ideal
(maxideal(i)=(1) for i<=0).
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  maxideal(2);
@c example
@end example
@end table
@menu
* ring::
@end menu
@iftex
See @ref{ring}.
@end iftex
@c ---------------------------------------
@node  memory, minbase, maxideal, Functions
@subsection memory
@cindex memory
@table @code
@item @strong{Syntax:}
@code{memory (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns statistics concerning the memory management:
@*@code{memory(0)} is the number of active bytes
@*@code{memory(1)} is the number of allocated bytes
@item @strong{Example:}
@example
@c example
  "Objects of Singular use (at the moment) ",memory(0)," bytes,"+newline+
  "allocated from system (at the moment):", memory(1), "bytes";
@c example
@end example
@end table
@c @menu
@c @end menu
@c @iftex
@c @end iftex
@c ---------------------------------------
@node minbase, minor, memory, Functions
@subsection minbase
@cindex minbase
@table @code
@item @strong{Syntax:}
@code{minbase (} ideal_expression @code{)}
@*@code{minbase (} module_expression @code{)}
@item @strong{Type:}
the same as the type of the argument
@item @strong{Purpose:}
returns a minimal set of generators of an ideal/module if the input is
either homogeneous or if the ordering is local.
@item @strong{Example:}
@example
@c example
  ring r=181,(x,y,z),(c,ls);
  ideal id2=x2+xyz,y2-z3y,z3+y5xz;
  ideal id4=maxideal(3)+id2;
  id4;
  minbase(id4);
@c example
@end example
@end table
@c @menu
@c @end menu
@c @iftex
@c @end iftex
@c ---------------------------------------
@node minor, minres, minbase, Functions
@subsection minor
@cindex minor
@table @code
@item @strong{Syntax:}
@code{minor (} matrix_expression@code{,} int_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the set of all minors (=subdeterminants) of the given size of a matrix
@item @strong{Example:}
@example
@c example
  ring r = 0, (x(1..5)), ds;
  matrix m[2][4]= x(1), x(2), x(3), x(4), x(2), x(3), x(4), x(5);
  print(m);
  ideal j = minor(m, 2);
  j;
@c example
@end example
@end table
@menu
* det::
@end menu
@iftex
See @ref{det}.
@end iftex
@c ---------------------------------------
@node  minres, modulo, minor, Functions
@subsection minres
@cindex minres
@table @code
@item @strong{Syntax:}
@code{minres (} list @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
minimize a free resolution of an ideal or module
given by the list argument.
@item @strong{Example:}
@example
@c example
  ring r=31991,(t,x,y,z,w),ls;
  ideal T=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
    t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  list R3=sres(std(T),0);
  size(R3);
  list R4=minres(R3);
  size(R4);
@c example
@end example
@end table
@menu
* res::
* mres::
* sres::
@end menu
@iftex
See @ref{res}; @ref{mres}; @ref{sres}.
@end iftex
@c --------------------------------------
@node modulo, mult, minres, Functions
@subsection modulo
@cindex modulo
@table @code
@item @strong{Syntax:}
@code{modulo (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{modulo (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
@code{modulo(h1,h2)}
@ifinfo
represents h1/(h1 intersect h2) (isomorphic to (h1+h2)/h2)
@end ifinfo
@tex
represents $h_1/(h_1 \cap h_2) (\cong (h_1+h_2)/h_2)$
@end tex
as factor of the free module
@ifinfo
R^k
@end ifinfo
@tex
R$^k$
@end tex
by the resulting submodule M,  where
@ifinfo
h1
@end ifinfo
@tex
$h_1$
@end tex
is generated by k elements as in
the following exact sequence:
@*
@ifinfo
@example
                                M
h1/(h1 intersect h2) <--- R^k <--- R^l
@end example
@end ifinfo
@tex
$h_1/(h_1 \cap h_2)\ \leftarrow\  R^k\ \buildrel{M}\over{\leftarrow}\ R^l$
@end tex
@item @strong{Example:}
@example
@c example
  ring r;
  ideal h1 = x,y,z;
  ideal h2 = x;
  module m=modulo(h1,h2);
  print(m);
@c example
@end example
@end table
@menu
* syz::
@end menu
@iftex
See @ref{syz}.
@end iftex
@c ---------------------------------------
@node mult, mres, modulo, Functions
@subsection mult
@cindex mult
@table @code
@item @strong{Syntax:}
@code{mult (} ideal_expression @code{)}
@*@code{mult (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
compute the degree of the monomial ideal/module generated by
the leading monomials of the input.
@*If the input is a standard basis of a homogeneous ideal
then it returns the degree of this ideal.
@*If the input is a standard basis of an ideal in a (local)
ring with respect to a local degree ordering
then it returns the multiplicity of the ideal (in the sense of Samuel,
with respect to the maximal ideal).
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),ds;
  poly f = (x^3+y^5)^2+x^2*y^7;
  ideal i = std(jacob(f));
  mult(i);
  mult(std(f));
@c example
@end example
@end table
@menu
* ideal::
* std::
* dim::
* degree::
* vdim::
@end menu
@iftex
See @ref{ideal}; @ref{std}; @ref{degree}; @ref{vdim}; @ref{dim}.
@end iftex
@c ---------------------------------------
@node  mres, mstd, mult, Functions
@subsection mres
@cindex mres
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression @code{,} int_expression @code{)}
@*@code{mres (} module_expression @code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression@code{,} name @code{)}
@*@code{mres (} module_expression@code{,} int_expression@code{,} name @code{)}
@item @strong{Type:}
none
@footnote{this form is kept for historical reasons (some libraries use it), it use is discouraged}
@item @strong{Purpose:}
compute a minimal free resolution of an ideal or module M with the
standard basis method. More precisely, let A=matrix(M), then @code{mres}
computes a free resolution of
@ifinfo
M1=coker(A)=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A)=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
@*where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are a minimal set of generators
of M if the basering is local or if M is homogeneous.
The computation will stop after k steps, if the int expression k
is not zero, and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*If k=0 @code{mres(M,0)}
returns a list of n modules where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then L[1] consists of a minimal set of generators of the input, L[2]
consists of a minimal set of generators of the first szyzgy module of
L[1], etc., until L[p+1], such that L[i]
@ifinfo
!=0 for i<=p
@end ifinfo
@tex
$\ne 0$ for i$\le$p
@end tex
 but L[p+1], the
first szyzgy module of L[p], is 0 (if the basering is not a qring).
@item @strong{Example:}
@example
@c example
  ring r  = 31991,(t,x,y,z,w),ls;
  ideal M = t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
            t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  list L  = mres(M,0);
  size(L);
  // projective dimension of M is 4
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
* res::
* sres::
@end menu
@iftex
See @ref{ideal expression}; @ref{module expression};
@ref{res}; @ref{sres}.
@end iftex
@c ---------------------------------------
@node  mstd, nameof, mres, Functions
@subsection mstd
@cindex mstd
@table @code
@item @strong{Syntax:}
@code{mstd (} ideal_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
returns a list of a standard basis and a minimal set of
generators - the input must be homogeneous and
the ring a polynomial ring (global ordering).
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z,t),dp;
  poly f=x3+y4+z6+xyz;
  ideal j=jacob(f),f;
  j=homog(j,t);j;
  mstd(j);
@c example
@end example
@end table
@menu
* ideal expression::
* std::
* minbase::
@end menu
@iftex
See @ref{ideal expression};
@ref{std}; @ref{minbase}.
@end iftex
@c ---------------------------------------
@node nameof, names, mstd, Functions
@subsection nameof
@cindex nameof
@table @code
@item @strong{Syntax:}
@code{nameof (} expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
return the name of an expression as string
@item @strong{Example:}
@example
@c example
  int i = 9;
  string s = nameof(i);
  s;
  nameof(s);
  nameof(i+1); //gives the empty string:
@c example
@end example
@end table
@menu
* typeof::
* names::
* reservedName::
@end menu
@iftex
See @ref{typeof}; @ref{names}; @ref{reservedName}.
@end iftex
@c ---------------------------------------
@node names, ncols, nameof, Functions
@subsection names
@cindex names
@table @code
@item @strong{Syntax:}
@code{names ( )}
@*@code{names (} ring_name @code{)}
@item @strong{Type:}
list of strings
@item @strong{Purpose:}
return the names of all user defined variables
which are ring independent or, in the second case, belong to the given ring
@item @strong{Example:}
@example
@c example
  int i = 9;
  ring r;
  poly f;
  names();
  names(r);
@c example
@end example
@end table
@menu
* nameof::
* reservedName::
@end menu
@iftex
See @ref{nameof}; @ref{reservedName}.
@end iftex
@c ---------------------------------------
@node ncols, npars, names, Functions
@subsection ncols
@cindex ncols
@table @code
@item @strong{Syntax:}
@code{ncols (} matrix_expression @code{)}
@*@code{ncols (} intmat_expression @code{)}
@*@code{ncols (} ideal_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the number of columns of a matrix or an intmat or the number of
given generators of the ideal, including zeroes.
@*Note that @code{size(}ideal@code{)} counts the number of generators
which are different from zero.
@item @strong{Example:}
@example
@c example
  ring r;
  matrix m[5][6];
  ncols(m);
  ideal i=x,0,y;
  ncols(i);
  size(i);
@c example
@end example
@end table
@menu
* matrix::
* matrix expression::
* nrows::
* size::
@end menu
@iftex
See @ref{matrix}; @ref{matrix expression}; @ref{nrows}; @ref{size}.
@end iftex
@c ---------------------------------------
@node npars, nrows, ncols, Functions
@subsection npars
@cindex npars
@table @code
@item @strong{Syntax:}
@code{npars (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the numbers of parameters of a ring
@item @strong{Example:}
@example
@c example
  ring r=(23,t,v),(x,a(1..7)),lp;
  // the parameters are t,v
  npars(r);
@c example
@end example
@end table
@menu
* ring::
@end menu
@iftex
See @ref{ring}.
@end iftex
@c ---------------------------------------
@node nrows, nvars, npars, Functions
@subsection nrows
@cindex nrows
@table @code
@item @strong{Syntax:}
@code{nrows (} matrix_expression @code{)}
@*@code{nrows (} intmat_expression @code{)}
@*@code{nrows (} intvec_expression @code{)}
@*@code{nrows (} module_expression @code{)}
@*@code{nrows (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the number of rows of a matrix, an intmat or an intvec resp.@*
the minimal rank of a free module in which the given the module or
vector lives (the index of the last non-zero component)
@item @strong{Example:}
@example
@c example
  ring R;
  matrix M[2][3];
  nrows(M);
  nrows(freemodule(4));
  module m=[0,0,1];
  nrows(m);
  nrows([0,x,0]);
@c example
@end example
@end table
@menu
* matrix::
* module::
* vector::
* ncols::
@end menu
@iftex
See @ref{matrix}; @ref{module}; @ref{vector}; @ref{ncols}.
@end iftex
@c ---------------------------------------
@node nvars, ord, nrows, Functions
@subsection nvars
@cindex nvars
@table @code
@item @strong{Syntax:}
@code{nvars (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the numbers of variables of a ring
@item @strong{Example:}
@example
@c example
  ring r=23,(x,a(1..7)),ls;
  nvars(r);
@c example
@end example
@end table
@menu
* ring::
@end menu
@iftex
See @ref{ring}.
@end iftex
@c ---------------------------------------
@node ord, ordstr, nvars, Functions
@subsection ord
@cindex ord
@table @code
@item @strong{Syntax:}
@code{ord (} poly_expression @code{)}
@*@code{ord (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the (weighted) degree of
the initial term of a polynomial or a vector;
the weights are the weights used for the first block of the ring ordering.
@*ord(0) is -1
@item @strong{Example:}
@example
@c example
  ring r=7,(x,y),wp(2,3);
  poly f=x2+y3;
  ord(f);
  ring R=7,(x,y),ws(2,3);
  poly f=x2+y3;
  ord(f);
  vector v=[x2,y];
  ord(v);
@c example
@end example
@end table
@menu
* deg::
* poly expression::
* vector expression::
@end menu
@iftex
See @ref{deg}; @ref{poly expression}; @ref{vector expression}.
@end iftex
@c ---------------------------------------
@node ordstr, par, ord, Functions
@subsection ordstr
@cindex ordstr
@table @code
@item @strong{Syntax:}
@code{ordstr (} ring_name @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
return the description of the monomial ordering of the ring
@item @strong{Example:}
@example
@c example
  ring r=7,(x,y),wp(2,3);
  ordstr(r);
@c example
@end example
@end table
@menu
* ring::
* varstr::
* parstr::
* charstr::
@end menu
@iftex
See @ref{ring}; @ref{varstr}; @ref{parstr}; @ref{charstr}.
@end iftex
@c ---------------------------------------
@node par, pardeg, ordstr, Functions
@subsection par
@cindex par
@table @code
@item @strong{Syntax:}
@code{par (} int_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
return the n-th parameter of the basering ring
@item @strong{Example:}
@example
@c example
  ring r=(0,a,b,c),(x,y,z),dp;
  par(2);
@c example
@end example
@end table
@menu
* ring::
* var::
@end menu
@iftex
See @ref{ring}; @ref{var}.
@end iftex
@c ---------------------------------------
@node pardeg, parstr, par, Functions
@subsection pardeg
@cindex pardeg
@table @code
@item @strong{Syntax:}
@code{pardeg(} number_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the degree of a number considered as a polynomial in the ring parameters
@item @strong{Example:}
@example
@c example
  ring r=(0,a,b,c),(x,y,z),dp;
  pardeg(a^2*b);
@c example
@end example
@end table
@menu
* ring::
* var::
@end menu
@iftex
See @ref{ring}; @ref{var}.
@end iftex
@c ---------------------------------------
@node parstr, preimage, pardeg, Functions
@subsection parstr
@cindex parstr
@table @code
@item @strong{Syntax:}
@code{parstr (} ring_name @code{)}
@*@code{parstr (} int_expression @code{)}
@*@code{parstr (} ring_name@code{,} int_expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
return the list of parameters of the ring
@*or the name of the n-th parameter for an integer n
@*@code{parstr(n)} is equivalent to @code{parstr(basering,n)}
@item @strong{Example:}
@example
@c example
  ring r=(7,a,b,c),(x,y),wp(2,3);
  parstr(r);
  parstr(2);
  parstr(r,3);
@c example
@end example
@end table
@menu
* ring::
* charstr::
* varstr::
* ordstr::
@end menu
@iftex
See @ref{ring};
@ref{charstr};
@ref{varstr};
@ref{ordstr}.
@end iftex
@c ---------------------------------------
@node preimage, prime, parstr, Functions
@subsection preimage
@cindex preimage

@table @code
@item @strong{Syntax:}
@code{preimage (} ring_name@code{,} map_name@code{,} ideal_name @code{)}
@*@code{preimage (} ring_name@code{,} ideal_expression@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
return the preimage of an ideal under a given map
@*
The second argument has to be a map from the basering to the given ring
(or an ideal defining such a map),
and the ideal has to be an ideal in the given ring.
@item @strong{Example:}
@example
@c example
  ring r1=32003,(x,y,z,w),lp;
  ring r=32003,(x,y,z),dp;
  ideal i=x,y,z;
  ideal i1=x,y;
  map f=r1,i;
  setring r1;
  ideal i1=preimage(r,f,i1);
  i1;
@c example
@end example
@end table
@menu
* map::
* ring::
@end menu
@iftex
See @ref{map}; @ref{ring}.
@end iftex
@c ---------------------------------------
@node prime, prune, preimage, Functions
@subsection prime
@cindex prime
@table @code
@item @strong{Syntax:}
@code{prime (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the largest prime smaller or equal to the argument;
@*return 2 for all arguments smaller than 3
@item @strong{Example:}
@example
@c example
  prime(32004);
  prime(-1);
@c example
@end example
@end table
@menu
* int expression::
@end menu
@iftex
See @ref{int expression}.
@end iftex
@c ---------------------------------------
@node prune, qhweight, prime, Functions
@subsection prune
@cindex prune
@table @code
@item @strong{Syntax:}
@code{prune (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
return the module minimal embedded in a free module such that the
corresponding factor modules are isomorphic
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  module m=gen(1),gen(3),[x,y,0,z],[x+y,0,0,0,1];
  print(m);
  print(prune(m));
@c example
@end example
@end table
@menu
* module expression::
@end menu
@iftex
See @ref{module expression}.
@end iftex
@c ---------------------------------------
@node qhweight, quotient, prune, Functions
@subsection qhweight
@cindex qhweight
@table @code
@item @strong{Syntax:}
@code{qhweight (} ideal_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
compute the weight vector for a quasihomogeneous ideal.
If the input is not weighted homogeneous, an intvec of zeroes will be returned.
@item @strong{Example:}
@example
@c example
  ring h1=32003,(t,x,y,z),dp;
  ideal i=x4+y3+z2;
  qhweight(i);
@c example
@end example
@end table
@menu
* ideal expression::
* intvec expression::
* weight::
@end menu
@iftex
See @ref{ideal expression}; @ref{intvec expression}; @ref{weight}.
@end iftex
@c ---------------------------------------
@node quotient, random, qhweight, Functions
@subsection quotient
@cindex quotient
@table @code
@item @strong{Syntax:}
@code{quotient (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quotient (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Syntax:}
@code{quotient (} module_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
compute the ideal quotient resp. module quotient
@*@code{quotient(i,j)}=
@ifinfo
@{a in basering | a j in  i @}
@end ifinfo
@tex
$\{a \in {\rm basering } \mid a \cdot j \subset i\}$
@end tex
in the first case and
@*@code{quotient(m,j)}=
@ifinfo
@{b in basering | b j in m @}, where m in basering^n,
@end ifinfo
@tex
$\{b \in basering^n \mid b j \subset m\}$, where $m\subset basering^n$,
@end tex
in the second case.
@item @strong{Example:}
@example
@c example
ring r=181,(x,y,z),(c,ls);
ideal id1=maxideal(3);
ideal id2=x2+xyz,y2-z3y,z3+y5xz;
ideal id6=quotient(id1,id2);
id6;
quotient(id2,id1);
@c example
@end example
@menu
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{ideal expression};
@ref{module expression}.
@end iftex
@end table
@c ---------------------------------------
@node random, read, quotient, Functions
@subsection random
@cindex random
@table @code
@item @strong{Syntax:}
@code{random (} min_integer@code{,} max_integer @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return random integer between min_integer and max_integer
@item @strong{Syntax:}
@code{random (} max_integer@code{,} rows@code{,} cols @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
return a random intmat of size rows x cols with entries between
-max_integer and +max_integer (inclusive)
@item @strong{Example:}
@example
@c example
  random(1,1000);
  random(1,2,3);
@c example
@end example
@end table
@menu
* int expression::
* intmat expression::
@end menu
@iftex
See @ref{int expression}; @ref{intmat expression}.
@end iftex
@c ---------------------------------------
@node read, reduce, random, Functions
@subsection read
@cindex read
@table @code
@item @strong{Syntax:}
@code{read (} link @code{)}
@*@code{read (}  link@code{,} string_expression @code{)} // DBM links, only
@item @strong{Type:}
any
@item @strong{Purpose:}
Read data from a link. 
@*For Ascii links, the content of the entire
file is returned as one string. 
@*For MP links, one expression is read
from the link, and returned after an evaluation. A link blocks
(i.e. does not return) as long as there is no data to read from an MPtcp
link. The @code{status} command can be used to check whether or not
there is data to read. 
@*For DBM links, a 
@code{read} with one argument returns the value of the next entry in the
data base, and a @code{read} with two arguments returns the value to the
key from the data base. 
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal i=x+y,z3+22y;
  // write the ideal i to the file save_i
  write(":w save_i",i);
  // @dots{}
  ring r0=0,(x,y,z),Dp;
  // create an ideal k equal to the content
  // of the file save_i
  string s="ideal k="+read("save_i")+";";
  execute s;
  k;
@c example
@end example
@end table
@menu
* links::
* write::
* getdump::
* execute::
* status::
@end menu
@iftex
See @ref{links}; @ref{write}; @ref{getdump}; @ref{execute}; @ref{status}.
@end iftex
@c ---------------------------------------
@node reduce, regularity, read, Functions
@subsection reduce
@cindex reduce
@table @code
@item @strong{Syntax:}
@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduce a polynomial, vector, ideal  or module
to its normal form with respect to an ideal or module represented
by a standard basis.
Return 0 if and only if the polynomial (resp. vector, ideal, module)
is an element (resp. subideal, submodule) of the ideal (resp. module).
The result may have no meaning if the second argument is not a standard basis.
@*The third (optional) argument 1 forces a lazy reduction
(only the leading term is used for the reduction; no tail reduction).
@cindex NF
@item @strong{Note:}
@code{NF} may be used instead of @code{reduce}.
@item @strong{Example:}
@example
@c example
  ring r1 = 0,(z,y,x),ds;
  poly s1=2x5y+7x2y4+3x2yz3;
  poly s2=1x2y2z2+3z8;
  poly s3=4xy5+2x2y2z3+11x10;
  ideal i=s1,s2,s3;
  ideal j=std(i);
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j);
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j,1);
@c example
@end example
@end table
@menu
* ideal expression::
* vector expression::
* std::
@end menu
@iftex
See @ref{ideal expression}; @ref{vector expression}; @ref{std}.
@end iftex
@c ---------------------------------------
@node regularity, res, reduce, Functions
@subsection regularity
@cindex regularity
@table @code
@item @strong{Syntax:}
@code{regularity ( list_expression @code{)}}
@item @strong{Type:}
int
@item @strong{Purpose:}
compute the regularity of a homogeneous ideal/module from a
minimal resolution given by the list expression.
@*
@ifinfo
Let (+) K[X]e(a,n) -> @dots{} -> (+) K[X]e(a,0) -> I -> 0
@* be a minimal resolution with homogeneous maps of degree 0.
The regularity is the smallest number s with the property deg( e(a,i)) <= s+i
for all i.
@end ifinfo
@tex
Let $0 \rightarrow\ \bigoplus_a K[x]e_{a,n}\ \rightarrow\ \dots
  \rightarrow\ \bigoplus_a K[x]e_{a,0}\ \rightarrow\
  I\ \rightarrow\ 0$
be a minimal resolution of I considered with homogeneous maps of degree 0.
The regularity is the smallest number $s$ with the property deg($e_{a,i})
 \leq s+i$ for all $i$.
@end tex
@*If the input to the commands @code{res} and @code{mres} is homogeneous
the regularity will be computed and used as a degree bound during
the computation unless @code{option(notRegularity);} is given.
@item @strong{Example:}
@example
@c example
  ring rh3=32003,(w,x,y,z),(dp,C);
  poly f= x11+y10+z9+x5*y2+x2*y2*z3+x*y^3*(y2+x)^2;
  ideal j= homog(jacob(f),w);
  list jj=res(j,0);
  regularity(jj);
@c example
@end example
@end table
@menu
* res::
* mres::
* sres::
* minres::
* option::
@end menu
@iftex
See @ref{res}; @ref{mres}; @ref{sres}; @ref{minres}; @ref{option}.
@end iftex
@c ---------------------------------------
@node  res, reservedName, regularity, Functions
@subsection res
@cindex res
@table @code
@item @strong{Syntax:}
@code{res (} ideal_expression@code{,} int_expression @code{)}
@*@code{res (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{res (} ideal_expression@code{,} int_expression@code{,} name @code{)}
@*@code{res (} module_expression@code{,} int_expression@code{,} name @code{)}
@item @strong{Type:}
none
@footnote{this form is kept for historical reasons (some libraries use it),
its use is discouraged}
@item @strong{Purpose:}
compute a minimal free resolution of an ideal or module M with the standard basis method.
More precisely, let
@tex
$A_1$=matrix(M),
@end tex
@ifinfo
A1=matrix(M),
@end ifinfo
then @code{res}
computes a free resolution of
@ifinfo
M1=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
@*where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are the given set of generators of M.
The computation will stop after k steps, if the int expression k
is not zero, and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*If k=0, @code{res(M,0)}
returns a list of n modules where n is the number of variables of the basering.
Let @code{list l=res(M,0);}
then L[1]=M is identical to the input, L[2] is a minimal set of generators
of the first szyzgy
module of L[1], etc.
( L[i]
@ifinfo
=M_i
@end ifinfo
@tex
$=M_i$
@end tex
 in the notations from above).
@item @strong{Example:}
@example
@c example
  ring r  = 31991,(t,x,y,z,w),ls;
  ideal M = t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
            t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  list L  = res(M,0);
  size(L);
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
* int expression::
* mres::
* sres::
@end menu
@iftex
See @ref{ideal expression}; @ref{module expression}; @ref{int expression};
@ref{mres};@ref{sres}.
@end iftex
@c ---------------------------------------
@node reservedName, resultant, res, Functions
@subsection reservedName
@cindex reservedName
@table @code
@item @strong{Syntax:}
@code{reservedName ( )}
@item @strong{Type:}
none
@item @strong{Syntax:}
@code{reservedName (} string_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
prints a list of all reserved identifiers (first form) or tests
whether the string is a reserved identifier
@item @strong{Example:}
@example
  reservedName();
  @expansion{} ...
@c example
  reservedName("ring");
  reservedName("xyz");
@c example
@end example
@end table
@menu
* names::
@end menu
@iftex
See @ref{names}.
@end iftex
@c ---------------------------------------
@node  resultant, rvar, reservedName, Functions
@subsection resultant
@cindex resultant
@table @code
@item @strong{Syntax:}
@code{resultant (} poly_expression@code{,} poly_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
compute the resultant of the first and second argument with respect
to the variable given as the third argument
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  poly f=3*(x+2)^3+y;
  poly g=x+y+z;
  resultant(f,g,x);
@c example
@end example
@end table
@menu
* poly expression::
* ring::
@end menu
@iftex
See @ref{poly expression} @ref{ring}.
@end iftex
@c ---------------------------------------
@node rvar, simplify, resultant, Functions
@subsection rvar
@cindex rvar
@table @code
@item @strong{Syntax:}
@code{rvar (} name @code{)}
@*@code{rvar (} poly_expression @code{)}
@*@code{rvar (} string_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
return the number of the variable (hence its boolean value is TRUE) if the name is a ring variable
or if the string is the name of a ring variable of the base ring.
@item @strong{Example:}
@example
@c example
  ring r=29,(x,y,z),lp;
  rvar(x);
  rvar(r);
  rvar(y);
  rvar(var(3));
  rvar("x");
@c example
@end example
@end table
@menu
* ring::
* var::
* varstr::
@end menu
@iftex
See @ref{ring}; @ref{var}; @ref{varstr}.
@end iftex
@c ---------------------------------------
@node simplify, size, rvar, Functions
@subsection simplify
@cindex simplify
@table @code
@item @strong{Syntax:}
@code{simplify (} poly_expression@code{,} int_expression @code{)}
@*@code{simplify (} vector_expression@code{,} int_expression @code{)}
@*@code{simplify (} ideal_expression@code{,} int_expression @code{)}
@*@code{simplify (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
return the "simplified" first argument depending on the function
given as the second argument.
@*The simplifications rules are the sum of the following
functions:
@table @asis
@item 1
normalize (leading coefficients will be 1)
@item 2
erase zero generators/columns
@item 4
keep only the first from identical generators/columns
@item 8
keep only the first from generators/columns which differ by a factor
from the ground field
@end table
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),(c,dp);
  simplify(2x,1);
  simplify([4x,2y],1);
  ideal i=x,0,2y,0,3z;
  simplify(i,1+2);
  matrix A[2][3]=x,0,2x,y,0,2y;
  simplify(A,2+8); // by automatic conversion to module
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{poly expression}; @ref{vector expression};
@ref{ideal expression}; @ref{module expression}.
@end iftex
@c ---------------------------------------
@node size, sortvec, simplify, Functions
@subsection size
@cindex size
@table @code
@item @strong{Syntax:}
@code{size (} string_expression @code{)}
@*@code{size (} intvec_expression @code{)}
@*@code{size (} intmat_expression @code{)}
@*@code{size (} poly_expression @code{)}
@*@code{size (} vector_expression @code{)}
@*@code{size (} ideal_expression @code{)}
@*@code{size (} module_expression @code{)}
@*@code{size (} matrix_expression @code{)}
@*@code{size (} list_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
@table @asis
@item ideal or module
return the number of (non zero) generators
@item string, intvec or list
return the length
@item poly or vector
return the number of monomials
@item matrix or intmat
return the the number of entries (rows*columns)
@end table
@item @strong{Example:}
@example
@c example
  string s="hello";
  size(s);
  intvec iv=1,2;
  size(iv);
  ring r=0,(x,y,z),lp;
  poly f=x+y+z;
  size(f);
  vector v=[x+y,0,1];
  size(v);
  ideal i=f,y;
  size(i);
  module m=v,[0,1],[0,0,1],2*v;
  size(m);
  matrix mm[2][2];
  size(mm);
@c example
@end example
@end table
@menu
* string expression::
* intvec expression::
* intmat expression::
* poly expression::
* vector expression::
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{string expression};
@ref{intvec expression};
@ref{intmat expression};
@ref{poly expression};
@ref{vector expression}; @ref{ideal expression}; @ref{module expression}.
@end iftex
@c ---------------------------------------
@node sortvec, sres, size, Functions
@subsection sortvec
@cindex sortvec
@table @code
@item @strong{Syntax:}
@code{sortvec (} ideal_expression @code{)}
@*@code{sortvec (} module_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
compute the permutation v: I[i] -> I[v[i]]
which orders the ideal/module by their initial term,
starting with the smallest.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=x,y,z,x3,xz;
  sortvec(I);
@c example
@end example
@end table
@menu
@end menu
@iftex
@c See @ref{string expression}; @ref{intvec expression}; @ref{poly expression};
@end iftex
@c ---------------------------------------
@node sres, status, sortvec, Functions
@subsection sres
@cindex sres
@table @code
@item @strong{Syntax:}
@code{sres (} ideal_expression@code{,} int_expression @code{)}
@*@code{sres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{sres (} ideal_expression@code{,} int_expression @code{,} name @code{)}
@*@code{sres (} module_expression@code{,} int_expression @code{,} name @code{)}
@item @strong{Type:}
none
@footnote{this form is kept for historical reasons (some libraries use it),
its use is discouraged}
@item @strong{Purpose:}
compute a free resolution of an ideal or module with Schreyer's
method. The ideal/module has to be a standard basis.
More precisely, let M be given by a standard basis and
@tex
$A_1=matrix(M)$.
@end tex
@ifinfo
A1=matrix(M).
@end ifinfo
Then @code{sres}
computes a free resolution of
@ifinfo
M1=coker(A)=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A)=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
The computation will stop after k steps, if the int expression k
is not zero, and returns a list of modules (given by standard bases)
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*If k=0, @code{sres(M,0)}
returns a list of n modules where n is the number of variables of the basering.

Even if @code{sres} does not compute a minimal resolution, the @code{betti}
command gives the true betti numbers! In many cases of interest
@code{sres} is much faster than any other known method.
Let @code{list l=sres(M,0);} then L[1]=M is identical to the input,
L[2] is a standard basis with respect to the Schreyer ordering of 
the first szyzgy
module of L[1], etc.
( L[i]
@ifinfo
=M_i
@end ifinfo
@tex
$=M_i$
@end tex
 in the notations from above).
@item @strong{Example:}
@example
@c example
  ring r  = 31991,(t,x,y,z,w),ls;
  ideal M = t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
            t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  M       = std(M);
  list L  = sres(M,0);
  size(L);
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
* int expression::
* mres::
* res::
* minres::
* betti::
@end menu
@iftex
See @ref{ideal expression}; @ref{module expression}; @ref{int expression};
@ref{mres}; @ref{res}; @ref{minres}; @ref{betti}.
@end iftex
@c ---------------------------------------
@node status, std, sres, Functions
@subsection status
@cindex status
@table @code
@item @strong{Syntax:}
@code{status (} link_expression@code{,} string_expression @code{)}
@item @strong{Type:}
string
@item @strong{Syntax:}
@code{status (} link_expression@code{,} string_expression@code{,} string_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the status of the link as asked for by the second argument.
If a third argument is given, the result of the comparison to the status
string is returned:
@code{(status(l,s1)==s2)} is equivalent to @code{status(l,s1,s2)}
@table @code
@item @code{"name"}
the name string given by the definition of the link (usually the filename)
@item @code{"type"}
returns @code{"Ascii"}, @code{"MPfile"}, @code{"MPtcp"} or @code{"DBM"}
@item @code{"open"}
returns @code{"yes"} or @code{"no"}
@item @code{"openread"}
returns @code{"yes"} or @code{"no"}
@item @code{"openwrite"}
returns @code{"yes"} or @code{"no"}
@item @code{"read"}
returns @code{"ready"} or @code{"not ready"}
@item @code{"write"}
returns @code{"ready"} or @code{"not ready"}
@item @code{"mode"}
returns (depending on the type of the link and its status)
@code{"","w","a","r"} or @code{"rw"}
@end table
@item @strong{Example:}
@example
@c example
  link l=":w example.txt";
  status(l,"write");
  open(l);
  status(l,"write");
  close(l);
@c example
@end example
@end table
@menu
* links::
@end menu
@iftex
See @ref{links}.
@end iftex
@c ---------------------------------------
@node std, stdfglm, status, Functions
@subsection std
@cindex std
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} intvec_expression @code{)}
@*@code{std (} module_expression@code{,} intvec_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
return a standard basis of an ideal or module with respect to the
monomial ordering of the basering.
A standard basis is a set of generators such that
the leading terms generate the leading ideal/module.
@*Use an optional
second argument as Hilbert series
(result of @code{hilb(i,1)}, see @ref{hilb}),
if the ideal/module is homogeneous,
(Hilbert driven standard basis computation,@ref{stdhilbert}).
@item @strong{Example:}
@example
@c example
  ring r = 32003, (x,y,z), ds;
  poly s1  = 1x3y2 + 151x5y + 169x2y4 + 151x2yz3 + 186xy6 + 169y9;
  poly s2  = 1x2y2z2 + 3z8;
  poly s3  = 5x4y2 + 4xy5 + 2x2y2z3 + 1y7 + 11x10;
  ideal i = s1, s2, s3;
  // compute standard basis j
  ideal j = std(i);
@c example
@end example
@end table
@menu
* ideal::
* ring::
* option::        Sets certain strategies.
* hilb::
* facstd::
* mstd::
* stdfglm::
* stdhilbert::
@end menu
@iftex
See @ref{ideal}; @ref{ring}; @ref{option}; @ref{facstd}; @ref{mstd};
@ref{stdfglm}; @ref{stdhilbert}.
@end iftex
@c ---------------------------------------
@node stdfglm, stdhilbert, std, Functions
@subsection stdfglm
@cindex stdfglm
@table @code
@item @strong{Syntax:}
@code{stdfglm (} ideal_expression@code{)}
@item @strong{Purpose:}
return a standard basis of an ideal in the basering, calculated via
the FGLM algorithm from the ordering "dp" (degrevlex) to the ordering
of the basering.
A standard basis is a set of generators such that
the leading terms generate the leading ideal.
@item @strong{Syntax:}
@code{stdfglm (} ideal_expression@code{,} string_expression @code{)}
@item @strong{Purpose:}
return a standard basis of an ideal in the basering, calculated via
the FGLM algorithm from the ordering "dp" (degrevlex) to the ordering
given by the second argument
@item @strong{Type:}
ideal
@item @strong{Example:}
@example
@c example
  ring r  = 0,(x,y,z),lp;
  ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
  ideal i1= stdfglm(i);         //uses fglm from "dp" to "lp"
  i1;
  ideal i2= stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
  i2;
@c example
@end example
@end table
@menu
* ideal::
* ring::
* option::        Sets certain strategies.
* hilb::
* facstd::
* mstd::
* std::
* stdhilbert::
@end menu
@iftex
See @ref{ideal}; @ref{ring}; @ref{option}; @ref{facstd}; @ref{mstd};
@ref{std}; @ref{stdhilbert}.
@end iftex
@c ---------------------------------------
@node stdhilbert, subst, stdfglm, Functions
@subsection stdhilbert
@cindex stdhilbert
@table @code
@item @strong{Syntax:}
@code{stdhilbert (} ideal_expression@code{)}
@*@code{stdhilbert (} ideal_expression@code{,} intvec_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
return a standard basis of an homogeneous ideal with respect to the
monomial ordering of the basering
(Hilbert driven standard basis computation).
(First the hilbert series will be computed (if not given))
A standard basis is a set of generators such that
the leading terms generate the leading ideal/module.
@*Use an optional
second argument as Hilbert series
(result of @code{hilb(i,1)}, see @ref{hilb}),
@item @strong{Example:}
@example
@c example
  ring  r = 0,(x,y,z),lp;
  ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
  ideal i1= stdhilbert(i); i1;
  // is in this case equivalent to:
  intvec v=1,0,0,-3,0,1,0,3,-1,-1;
  ideal i2=stdhilbert(i,v);
@c example
@end example
@end table
@menu
* ideal::
* ring::
* option::        Sets certain strategies.
* hilb::
* facstd::
* mstd::
* std::
* stdfglm::
@end menu
@iftex
See @ref{ideal}; @ref{ring}; @ref{option}; @ref{facstd}; @ref{mstd};
@ref{std}; @ref{stdfglm}.
@end iftex
@c ---------------------------------------
@node subst, syz, stdhilbert, Functions
@subsection subst
@cindex subst
@table @code
@item @strong{Syntax:}
@code{subst (} poly_expression@code{,} ring_variable@code{,} monomial @code{)}
@*@code{subst (} vector_expression@code{,} ring_variable@code{,} monomial @code{)}
@*@code{subst (} ideal_expression@code{,} ring_variable@code{,} monomial @code{)}
@*@code{subst (} module_expression@code{,} ring_variable@code{,} monomial @code{)}
@item @strong{Type:}
poly, vector, ideal or module (the same as the first argument)
@item @strong{Purpose:}
substitutes the ringvariable by the monomial (a polynomial of length <=1)
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  poly f=x2+y2+z2+x+y+z;
  subst(f,x,3/2);
  int a=1;
  subst(f,y,a);
  subst(f,y,z);
@c example
@end example
@end table
@menu
* poly expression::
* vector expression::
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{poly expression}; @ref{vector expression};
@ref{ideal expression}; @ref{module expression}.
@end iftex
@c -------------------------------------------------
@node syz, transpose, subst, Functions
@subsection syz
@cindex syz
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
compute the first syzygy (i.e. the module of relations of the given generators)
of the ideal/module
@item @strong{Example:}
@example
@c example
  ring R=0,(x,y),(c,dp);
  ideal i=x,y;
  syz(i);
@c example
@end example
@end table
@menu
* ideal expression::
* module expression::
@end menu
@iftex
See @ref{ideal expression}; @ref{module expression}.
@end iftex
@c ---------------------------------------
@node transpose, trace, syz, Functions
@subsection transpose
@cindex transpose
@table @code
@item @strong{Syntax:}
@code{transpose (} matrix_expression @code{)}
@*@code{transpose (} intmat_expression @code{)}
@item @strong{Type:}
type of the argument
@item @strong{Purpose:}
transpose a matrix
@item @strong{Example:}
@example
@c example
  ring R=0,x,dp;
  matrix m[2][3]=1,2,3,4,5,6;
  print(m);
  print(transpose(m));
@c example
@end example
@end table
@menu
* matrix expression::
@end menu
@iftex
See @ref{matrix expression}.
@end iftex
@c ---------------------------------------
@node trace, typeof, transpose, Functions
@subsection trace
@cindex trace
@table @code
@item @strong{Syntax:}
@code{trace (} matrix_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Syntax:}
@code{trace (} intmat_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
trace of a matrix or an intmat
@item @strong{Example:}
@example
@c example
  intmat m[2][2]=1,2,3,4;
  print(m);
  trace(m);
@c example
@end example
@end table
@menu
* matrix expression::
* intmat expression::
@end menu
@iftex
See @ref{matrix expression};
@ref{intmat expression}.
@end iftex
@c ---------------------------------------
@node typeof, var, trace, Functions
@subsection typeof
@cindex typeof
@table @code
@item @strong{Syntax:}
@code{typeof (} expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
return the type of an expression as string
@*(if the expression is an expression list:
the type of the first list element)
@*Possible types are: @code{
"ideal",
"int",
"intmat",
"intvec",
"list",
"map",
"matrix",
"module",
"number",
"none",
"package"}@footnote{reserved for
future extensions}@code{,
"poly",
"proc",
"qring",
"resoltion",
"ring",
"string",
"vector",
"?unknown type?"}
@item @strong{Example:}
@example
@c example
  int i = 9;
  string s = typeof(i);
  s;
  typeof(s);
@c example
@end example
@end table
@menu
* Expressions::
@end menu
@iftex
See @ref{Expressions}.
@end iftex
@c ---------------------------------------
@node var, varstr, typeof, Functions
@subsection var
@cindex var
@table @code
@item @strong{Syntax:}
@code{var (} int_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
return the n-th ring variable for a given integer n
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  var(2);
@c example
@end example
@end table
@menu
* ring::
* int expression::
* nvars::
* varstr::
@end menu
@iftex
See @ref{ring}, @ref{int expression}; @ref{nvars}; @ref{varstr}.
@end iftex
@c ---------------------------------------
@node varstr, vdim, var, Functions
@subsection varstr
@cindex varstr
@table @code
@item @strong{Syntax:}
@code{varstr (} ring_name @code{)}
@*@code{varstr (} int_expression @code{)}
@*@code{varstr (} ring_name@code{,} int_expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
return the list of the names of the ring variables
@*or the name of the n-th ring variable for a given integer n
@*@code{varstr(n)} is equivalent to @code{varstr(basering,n)}
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  varstr(r);
  varstr(r,1);
  varstr(2);
@c example
@end example
@end table
@menu
* ring::
* int expression::
* var::
* nvars::
* ordstr::
* charstr::
* parstr::
@end menu
@iftex
See @ref{ring}, @ref{int expression}; @ref{nvars}; @ref{var};
@ref{ordstr};
@ref{charstr};
@ref{parstr}.
@end iftex
@c ---------------------------------------
@node vdim, wedge, varstr, Functions
@subsection vdim
@cindex vdim
@table @code
@item @strong{Syntax:}
@code{vdim (} ideal_expression @code{)}
@*@code{vdim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
compute the vector space dimension of the ring (resp. free module)
modulo the ideal (resp. module)
generated by the initial terms of the given generators.
If the generators are  a standard basis,
this is the same as the vector space dimension of the ring (resp.
free module) modulo the ideal (resp. module).
@*If the ideal/module is not zero-dimensional, -1 will be returned
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y),ds;
  ideal i=x2+y2,x2-y2;
  ideal j=std(i);
  vdim(j);
@c example
@end example
@end table
@menu
* ideal::
* std::
* dim::
* degree::
* mult::
* kbase::
@end menu
@iftex
See @ref{ideal}; @ref{std}; @ref{dim}; @ref{degree}; @ref{mult}; @ref{kbase}.
@end iftex
@c ---------------------------------------
@node wedge, weight, vdim, Functions
@subsection wedge
@cindex wedge
@table @code
@item @strong{Syntax:}
@code{wedge (} matrix_expression@code{,} int_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
compute the n-th exterior power of matrix for a given integer n
@item @strong{Example:}
@example
@c example
  ring r;
  matrix m[2][3] = x,y,y,z,z,x;
  print(m);
  print(wedge(m,2));
@c example
@end example
@end table
@menu
* matrix::
* minor::
* int expression::
@end menu
@iftex
See @ref{matrix}; @ref{minor}; @ref{int expression}.
@end iftex
@c ---------------------------------------
@node weight, , wedge, Functions
@subsection weight
@cindex weight
@table @code
@item @strong{Syntax:}
@code{weight (} ideal_expression @code{)}
@*@code{weight (} module_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
compute an "optimal" weight vector for an ideal/module which may be used as
weight vector for the variables in order to speed up the standard basis
algorithm.   If the input is weighted homogeneous, a weight vector for
which the input is weighted homogeneous is found
@item @strong{Example:}
@example
@c example
  ring h1=32003,(t,x,y,z),dp;
  ideal i=
  9x8+y7t3z4+5x4y2t2+2xy2z3t2,
  9y8+7xy6t+2x5y4t2+2x2yz3t2,
  9z8+3x2y3z2t4;
  intvec e=weight(i);
  e;
  ring r=32003,(a,b,c,d),wp(e);
  map f=h1,a,b,c,d;
  ideal i0=std(f(i));
@c example
@end example
@end table
@menu
* ideal expression::
* intvec expression::
* qhweight::
@end menu
@iftex
See @ref{ideal expression}; @ref{intvec expression}; @ref{qhweight}.
@end iftex
@c ---------------------------------------
@node Control structures, Proc commands, Functions, Commands
@section Control structures
@cindex Control structures
@ifinfo
@*List of all supported control structures.
@end ifinfo
@menu
* if::
* else::
* while::
* break::
* for::
* continue::
@end menu
@c ---------------------------------------
@node break, continue, Control structures, Control structures
@subsection break
@cindex break
@table @code
@item @strong{Syntax:}
@code{break;}
@item @strong{Purpose:}
leave the innermost block of a for- or a while-construct
@item @strong{Example:}
@example
  while (1)
  @{
    @dots{}
    if ( @dots{} )  break; // leave the while block
  @}
@end example
@end table
@menu
* for::
* while::
* block::
@end menu
@iftex
See @ref{block}; @ref{while}; @ref{for}.
@end iftex
@c ---------------------------------------
@node continue, else, break, Control structures
@subsection continue
@cindex continue
@table @code
@item @strong{Syntax:}
@code{continue;}
@item @strong{Purpose:}
is only valid inside a @code{for} construct, skips the rest
of this loop and jumps to the beginning of the block
@item @strong{Note:}
Unlike the C-construct it @strong{does not execute the increment statement}
@code{continue} is mainly for internal use
@item @strong{Example:}
@example
  for (int i = 1 ; i<=10; i=i+1)
  @{
     @dots{}
     if (i==3) @{ i=8;continue; @}
       // skip the rest if i is 3 and
       // continue with the next i: 8
     i;
  @}
  @expansion{} 1
  @expansion{} 2
  @expansion{} 8
  @expansion{} 9
  @expansion{} 10
@end example
@end table
@menu
* for::
* block::
@end menu
@iftex
See @ref{block}; @ref{block}.
@end iftex
@c ---------------------------------------
@node else, for, continue, Control structures
@subsection else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} block @code{else} block
@item @strong{Purpose:}
conditional execution of a block, only valid after an `if`
@item @strong{Example:}
@example
  int i=3;
  if (i > 5)
  @{
    "i is bigger than 5";
  @}
  else
  @{
    @dots{}
    "i is smaller than 6";
  @}
  @expansion{} i is bigger than 5
@end example
@end table
@menu
* if::
* block::
@end menu
@iftex
See @ref{if}; @ref{block}.
@end iftex
@c ---------------------------------------
@node for, if, else, Control structures
@subsection for
@cindex for
@table @code
@item @strong{Syntax:}
@code{for (} init@code{;} boolean_expression@code{;} iterate@code{)} block
@*
@*init is a command, init is executed first.
@*boolean_expression is evaluated, each time before the block gets executed.
@*iterate is a command, iterate is executed at the end of the block.
@*@code{break;} will leave the innermost @code{for} construct.
@item @strong{Purpose:}
repetitive, conditional execution of a command block
@item @strong{Example:}
@example
  // sum of 1 to 10:
  int s=0;
  for (int i=1; i<=10; i=i+1)
  @{
     s=s+i;
  @}
  s;
  @expansion{} 55
@end example
@end table
@menu
* block::
* boolean expression::
* while::
* if::
* break::
@end menu
@iftex
See @ref{block}; @ref{boolean expression}; @ref{while}; @ref{if};
@ref{break}; @ref{continue}.
@end iftex
@c ---------------------------------------
@node if, while, for, Control structures
@subsection if
@cindex if
@cindex else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} block
@*@code{if (} boolean_expression @code{) break;}
@*@code{if (} boolean_expression @code{)} block @code{else} block
@item @strong{Purpose:}
conditional execution of a block
@item @strong{Example:}
@example
  int i = 9;
  matrix m [i][i];
  if (i > 5 and typeof(m) == "matrix")
  @{
    m[i][i] = i;
  @}
  else
  @{
    if (i<5)
    @{
      "index i=",i," is too small";
    @}
  @}
@end example
@end table
@menu
* block::
* boolean expression::
@end menu
@iftex
See @ref{block}; @ref{boolean expression}.
@end iftex
@c ---------------------------------------
@node while, ,if ,Control structures
@subsection while
@cindex while
@table @code
@item @strong{Syntax:}
@code{while (}boolean_expression@code{)} block
@item @strong{Purpose:}
repetitive, conditional execution of block
@*@code{break} will leave the innermost @code{while} construct.
@item @strong{Example:}
@example
  int i = 9;
  while (i>0)
  @{
     // @dots{} // do something for i=9,8,7,6,5,4,3,2,1
     i = i - 1;
  @}
  while (1)
  @{
     // @dots{} // do something forever
     if (i == -5) // but leave the loop if i is -5
     @{
       break;
     @}
  @}
@end example
@end table
@menu
* boolean expression::
* for::
* while::
* break::
@end menu
@iftex
See @ref{block}; @ref{boolean expression}; @ref{break}.
@end iftex
@c ----------------------------------------
@node Proc commands, Other commands, Control structures, Commands
@section Proc commands
@cindex Proc commands
@menu
* exit::
* export::
* keepring::
* return::
@end menu
@tex
See @ref{proc commands}.
@end tex

@c ---------------------------------------
@c @node exit, export, Proc commands, Proc commands
@iftex
@subsection exit
@cindex exit
@cindex quit
@table @code
@item @strong{Syntax:}
@code{exit;}
@*@code{quit;}
@item @strong{Purpose:}
quit @sc{Singular},
works also from inside a proc or from an interrupt
@c @item @strong{Example:}
@c  quit;
@end table
@c @iftex
@c See @ref{Expressions}.
@c @end iftex
@c ---------------------------------------
@c @node export, keepring, exit, Proc commands
@subsection export
@cindex export
@table @code
@item @strong{Syntax:}
@code{export} name@code{;}
@*@code{export} list_of_names @code{;}
@item @strong{Purpose:}
convert a local variable to a global one
@item @strong{Example:}
@example
  proc p1
  @{
    int i,j;
    intmat m;
    export i,j,m;
  @}
  p1();listvar();
  @expansion{} // m                    [0]  intmat 1 x 1
  @expansion{} // j                    [0]  int 0
  @expansion{} // i                    [0]  int 0
@end example
@c  quit;
@end table
@c @iftex
@c See @ref{Expressions}.
@c @end iftex
@c ---------------------------------------
@c @node keepring, return, export, Proc commands
@subsection keepring
@cindex keepring
@table @code
@item @strong{Syntax:}
@code{keepring} name@code{;}
@item @strong{Purpose:}
change the base ring to another (already defined) ring
in the next (upper) level; can only be used in procedures
@item @strong{Example:}
@example
  proc P1
  @{
    ring r=0,x,dp;
    keepring r;
  @}
  ring r1= 0,y,dp;
  P1();
  nameof(basering);
  @expansion{} r
@end example
@end table
@c ---------------------------------------
@c @node return, , keepring, Proc commands
@subsection return
@cindex return
@table @code
@item @strong{Syntax:}
@code{return (} expression_list @code{);}
@*@code{return ( );}
@item @strong{Type:}
any
@item @strong{Purpose:}
return the result(s) of a procedure
@*should only be used in a procedure
@item @strong{Example:}
@example
  proc p2
  @{
    int i,j;
    for(i=1;i<=10;i++)
    @{
      j=j+i;
    @}
    return(j);
  @}    
  // other examples:
  return ( 0 );
  return("NIL");
  return(m);
  return(i(1..5));
@end example
@end table
@c @iftex
See @ref{Expressions}; @ref{proc}.
@c @end iftex
@menu
* Expressions::
* proc::
@end menu
@end iftex

@c ---------------------------------------
@node Other commands, System variables, Proc commands, Commands
@section Other commands
@cindex Other commands
@ifinfo
@*List of other supported commands.
@end ifinfo
@menu
* attrib::
* close::
* dbprint::
* degree::
* dump::
* eval::
* execute::
* filecmd::
* getdump::
* help::
* kill::
* killattrib::
* LIB::
* listvar::
* monitor::
* open::
* option::
* pause::
* print::
* quote::
* setring::
* system::
* type::
* write::
@end menu
@c ---------------------------------------
@node attrib, close, Other commands, Other commands
@subsection attrib
@cindex attrib
@table @code
@item @strong{Syntax:}
@code{attrib (} name @code{)}
@item @strong{Purpose:}
display the attribute list of the @emph{name}
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=std(maxideal(2));
  attrib(I);
@c example
@end example
@item @strong{Syntax:}
@code{attrib (} name @code{,} string_expression @code{)}
@item @strong{Type:}
any
@item @strong{Purpose:}
return the value of the attribute @emph{string_expression} of the @emph{name}.
If the attribut is not defined for this variable, return the empty string.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=std(maxideal(2));
  attrib(I,"isSB");
  // although maxideal(2) is a standard basis,
  // Singular does not know it:
  attrib(maxideal(2), "isSB");
@c example
@end example
@item @strong{Syntax:}
@code{attrib (} name@code{,} string_expression@code{,} expression @code{)}
@item @strong{Purpose:}
sets the attribute @emph{string_expression} of the @emph{name}
to the value @emph{expression}
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=std(maxideal(2));
  vdim(I);
  attrib(I,"isSB",0);  // the standard basis attribute is set to 0
  vdim(I);
@c example
@end example
@item @strong{Remark:}
An attribute may be described by any string_expression, but some are reserved.
Only the reserved attributes are used by the kernel of @sc{Singular}.
@sp 1
@item @strong{Reserved attributes:}
(not all are used at the moment)
@table @asis
@item @code{isSB}
standard basis - set by @code{std}, used by @code{lift}, @code{dim},
@code{degree}, @code{mult}, @code{hilb}, @code{vdim}, @code{kbase}
@item @code{isHomog}
the weight vector for homogeneous or quasihomogeneous ideals/modules
@item @code{isCI}
complete intersection
@item @code{isCM}
Cohen-Macaulay  module
@item @code{withSB}
value of type ideal/module is std
@item @code{withHilb}
value of type intvec is hilb(_,1) (see @ref{hilb})
@item @code{withRes}
value of type list is a free resolution
@item @code{withDim}
value of type int is the dimension (see @ref{dim})
@item @code{withMult}
value of type int is the multiplicity (see @ref{mult})
@item @code{D}
object is an differential operator, if set to 1;
@*object is in a module, if set to 0
@*only valid in a dring (see @ref{dring}).
@end table
@end table
@c @menu
@c * Expressions::
@c @end menu
@c @iftex
@c See @ref{Expressions}.
@c @end iftex
@c ---------------------------------------
@node close, dbprint, attrib , Other commands
@subsection close
@cindex close
@table @code
@item @strong{Syntax:}
@code{close (} link_expression @code{)}
@item @strong{Purpose:}
close a link
@item @strong{Example:}
@example
  LIB "general.lib";
  link l="MPtcp:launch";
  open(l); // start Singular "server" on localhost in batchmode
  close(l); // shut down Singular server
@end example
@end table
@menu
* links::
* link::
* open::
@end menu
@iftex
See @ref{links}, @ref{link}; @ref{open}.
@end iftex
@c ---------------------------------------
@node dbprint, degree, close, Other commands
@subsection dbprint
@cindex dbprint
@table @code
@item @strong{Syntax:}
@code{dbprint (} int_expression@code{,} expression_list @code{)}
@item @strong{Purpose:}
debug print of a list of expressions.
The print command is applied to each expression
if int_expression is positive.
@code{dbprint} may also be used in procedures
in order to print results subject to certain
conditions.
@item @strong{Syntax:}
@code{dbprint (} expression@code{)}
@item @strong{Purpose:}
debug print of an expressions.
The print command is applied to the expression
if @code{printlevel>voice}.
@item @strong{Example:}
@example
@c example
  int debug=0;
  intvec i=1,2,3;
  dbprint(debug,i);
  debug=1;
  dbprint(debug,i);
@c example
@end example
@end table
@menu
* print::
* voice::
* printlevel::
* Debugging tools::
@end menu
@iftex
See @ref{print}; @ref{voice}; @ref{printlevel}; @ref{Debugging tools}.
@end iftex
@c ---------------------------------------
@node degree, dump, dbprint, Other commands
@subsection degree
@cindex degree
@table @code
@item @strong{Syntax:}
@code{degree (} ideal_expression @code{)}
@*@code{degree (} module_expression @code{)}
@item @strong{Purpose:}
compute the (Krull) dimension, codimension and the multiplicity
of the ideal/module generated by the leading monomials of the input and
print it.   This is equal to the dimension, codimension and multiplicity
of the ideal/module if the input is a standard basis with respect to a
degree ordering.
@item @strong{Example:}
@example
  ring r3=32003,(x,y,z),ds;
  int a =11;
  int b =10;
  int c =3;
  int t =1;
  poly f =x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
    +x^(c-2)*y^c*(y2+t*x)^2;
  ideal i= jacob(f);
  ideal i0=std(i);
  degree(i0);
  @expansion{} //codimension 3
  @expansion{} //dimension 0
  @expansion{} //multiplicity 314
@end example
@end table
@menu
* ideal::
* std::
* dim::
* vdim::
* mult::
@end menu
@iftex
See @ref{ideal}; @ref{std}; @ref{dim}; @ref{vdim}; @ref{mult}.
@end iftex
@c ---------------------------------------
@node dump, eval, degree, Other commands
@subsection dump
@cindex dump
@table @code
@item @strong{Syntax:}
@code{dump (} link @code{);}
@item @strong{Purpose:}
Dumps (i.e. write in one "message" or "block") the state of the Singular
session (i.e., all defined variables and their values) to the specified
link (which must be either an Ascii or MP link). 
@item @strong{Example:}
@example
@c example
  int i=3;
  dump("");
@c example
@end example
@item @strong{Restrictions:}
For Ascii links, integer matricies contained in lists are  dumped as
integer list elements (and not as integer matricies). Furthermore, links
themselfes are not dumped.
@end table
@menu
* links::
* getdump::
* write::
@end menu
@iftex
See @ref{links}, @ref{getdump}, @ref{write}, .
@end iftex
@c ---------------------------------------
@node eval, execute, dump, Other commands
@subsection eval
@cindex eval
@table @code
@item @strong{Syntax:}
@code{eval (} expression @code{)}
@item @strong{Purpose:}
evaluate (quoted) expressions. Within a quoted expression, the
quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
effect of exactly one quoter). Used with @code{quote} and @code{write}.
@item @strong{Example:}
@example
@c @c example
  link l="MPfile:w example.mp";
  ring r=0,(x,y,z),ds;
  ideal i=maxideal(3);
  ideal j=x7,x2,z;
  // compute i+j before writing, but not std
  // this writes 'std(ideal(x3,...,z))'
  write (l, quote(std(eval(i+j))));
  option(prot);
  close(l);
  // now read it in again and evaluate
  // read(l) forces to compute 'std(ideal(x3,...,z))'
  read(l);
  close(l);
@c @c example
@end example
@end table
@menu
* quote::
* write::
@end menu
@iftex
See @ref{quote}; @ref{write}.
@end iftex
@c ---------------------------------------
@node execute, filecmd, eval, Other commands
@subsection execute
@cindex execute
@table @code
@item @strong{Syntax:}
execute string_expression
@item @strong{Purpose:}
execute a string containing a sequence of @sc{Singular} commands.
@*@strong{Note:} The string will be inserted into your input
stream at the next line break, @emph{NOT} after the @code{;} !  Hence, execute
should be the only command on a line.   execute should be avoided in
procedures whenever possible since it may give rise to name conflicts.
Moreover, such procedures cannot be precompiled (something
@sc{Singular} will provide in the future).
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal i=x+y,z3+22y;
  write(">save_i",i);
  ring r0=0,(x,y,z),Dp;
  string s="ideal k="+read("save_i")+";";
  s;
  execute s; // define the ideal k
  k;
@c example
@end example
@end table
@c ---------------------------------------
@node filecmd, getdump, execute, Other commands
@subsection Input from files
@cindex filecmd
@cindex <
@table @code
@item @strong{Syntax:}
@code{< "}@file{filename}@code{";}
@item @strong{Purpose:}
input will come from new file @file{filename}
@item @strong{Example:}
@example
  < "lib"; //read in the file lib
@end example
@end table
@c ---------------------------------------
@node getdump, help, filecmd, Other commands
@subsection getdump
@cindex getdump
@table @code
@item @strong{Syntax:}
@code{getdump (} link @code{);}
@item @strong{Purpose:}
reads the contents of the entire file/link and restores all variables
from it. For Ascii links, @code{getdump} is equivalent to a
@code{execute read (} link @code{);} command. For MP links,
@code{getdump} should only be used on data which was previously
@code{dump}'ed. 
@item @strong{Example:}
@example
@c example
  int i=3;
  dump(":w example.txt");
  kill i;
  getdump("example.txt");
  i;
@c example
@end example
@item @strong{Restrictions:} 
@code{getdump} is not supported fro DBM links, or for a link connecting
to @code{stdin} (standard input).
@end table
@menu
* links::
* dump::
* read::
@end menu
@iftex
See @ref{links}, @ref{dump}, @ref{read}.
@end iftex
@c ---------------------------------------
@node help, kill, getdump, Other commands
@subsection help
@cindex help
@table @code
@item @strong{Syntax:}
@code{help;}
@*@code{help} command_name @code{;}
@item @strong{Purpose:}
provide help information, using the texinfo facility
@*to get help about help, press @code{?}
@cindex ?
@item @strong{Note:}
@code{?} may be used instead of @code{help}.
@item @strong{Example:}
@example
  help ring;
  help;
@end example
@end table
@c ---------------------------------------
@node kill, killattrib, help, Other commands
@subsection kill
@cindex kill
@table @code
@item @strong{Syntax:}
@code{kill} name@code{;}
@*@code{kill} list_of_names @code{;}
@item @strong{Purpose:}
delete variables
@item @strong{Example:}
@example
@c example
  int i=3;
  ring r= 0,x,dp;
  poly p;
  listvar();
  kill i,r;
  i;
  listvar();
@c example
@end example
@end table
@c ---------------------------------------
@node killattrib, LIB, kill, Other commands
@subsection killattrib
@cindex killattrib
@table @code
@item @strong{Syntax:}
@code{killattrib (} name@code{,} string_expression @code{);}
@item @strong{Purpose:}
delete the attribute given as the second argument
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),lp;
  ideal i=maxideal(1);
  attrib(i,"isSB",1);
  attrib(i);
  killattrib(i,"isSB");
  attrib(i);
@c example
@end example
@end table
@menu
* attrib::
@end menu
@iftex
See @ref{attrib}.
@end iftex
@c ---------------------------------------
@node LIB, listvar, killattrib, Other commands
@subsection LIB
@cindex LIB
@table @code
@item @strong{Syntax:}
@code{LIB} string_expression@code{;}
@item @strong{Purpose:}
read a library of procedures (proc) from a file. If the given
filename does not start with @kbd{.} or @kbd{/}, the following directories ares
searched for the file: the current directory,
the directories given in the environment variable
@code{SINGULARPATH}@footnote{@code{SPATH} on MS-DOS},
@code{usr/local/share/Singular}
Only a directory of the library is loaded, the body of the proc
is read during the first call of this proc. This minimizes
the memory consumption of unused procedures.
@item @strong{Example:}
@example
  LIB "lib"; // the names of the procedures in the
             // file lib are now known to @sc{Singular}
@end example
@end table
@menu
* LIB in a library::
* string expression::
* proc::
* procedures and Libraries::
* Library Index:: all standard libraries.
@end menu
@iftex
See @ref{LIB in a library}; @ref{proc}; @ref{procedures and Libraries};
@ref{string expression}; @ref{Library Index}.
@end iftex
@c ---------------------------------------
@node listvar, monitor, LIB, Other commands
@subsection listvar
@cindex listvar
@table @code
@item @strong{Syntax:}
@code{listvar();}
@*@code{listvar(} type_name @code{);}
@*@code{listvar(} ring_name @code{);}
@*@code{listvar(} name @code{);}
@*@code{listvar( all );}
@item @strong{Purpose:}
list all (user-)defined names:
@*@code{listvar()}: all reachable names except procedures
@*@code{listvar(}type_name@code{)}: all reachable names of the given type
@*@code{listvar(}ring_name@code{)}: all names which belong to the given ring
@*@code{listvar(} name @code{)}: the object with the given name
@*@code{listvar(all)}: all names except procedures
@*the actual base ring is marked with an @code{*}
@item @strong{Example:}
@example
  proc t1 @{ @}
  proc t2 @{ @}
  ring s;
  poly ss;
  ring r;
  poly f=x+y+z;
  int i=7;
  ideal I=f,x,y;
@end example
@example
  listvar(all);
  @expansion{} // i               int 7
  @expansion{} // r               *ring
  @expansion{} //     I               ideal, 3 generators
  @expansion{} //     f               poly x+y+..., 3 monomials
  @expansion{} // s               ring
  @expansion{} //     ss              poly
@end example
@example
  listvar();
  @expansion{} // i               int 7
  @expansion{} // r               *ring
  @expansion{} //     I               ideal, 3 generators
  @expansion{} //     f               poly x+y+..., 3 monomials
  @expansion{} // s               ring
@end example
@example
  listvar(r);
  @expansion{} // I               ideal, 3 generators
  @expansion{} // f               poly x+y+..., 3 monomials
  listvar(ring);
  @expansion{} // r               *ring
  listvar(poly);
  @expansion{} // f               poly x+y+..., 3 monomials
  listvar(I);
  @expansion{} // I               ideal, 3 generators
  listvar(proc);
  @expansion{} // t2              proc
  @expansion{} // t1              proc
  listvar(t1);
  @expansion{} // t1              proc
@end example
@end table
@c ---------------------------------------
@node monitor, open, listvar, Other commands
@subsection monitor
@cindex monitor
@table @code
@item @strong{Syntax:}
@code{monitor (} string_expression @code{)}
@*@code{monitor (} string_expression@code{,} string_expression @code{)}
@item @strong{Purpose:}
start/stop recording all user input and/or program output into a file
The second argument describe what to log: @code{"i"} means input,
@code{"o"} means output, @code{"io"} for both.
@*The default for the second argument is @code{"i"}.
@*Each @code{monitor} command closes the old monitor file
and opens the file given by the first string expression.
@*@code{monitor ("")} turns off recording.
@item @strong{Example:}
@example
@c example
  monitor("doe.tmp");
  ring r;
  poly f=x+y+z;
  int i=7;
  ideal I=f,x,y;
  monitor("");
@c example
@end example
@end table
@c ---------------------------------------
@node open, option, monitor, Other commands
@subsection open
@cindex open
@table @code
@item @strong{Syntax:}
open ( link_expression )
@item @strong{Purpose:}
open a link
@item @strong{Example:}
@example
  LIB "general.lib";
  link l="MPtcp:launch";
  open(l); // start Singular "server" on localhost in batchmode
  close(l); // shut down Singular server
@end example
@end table
@menu
* links::
* link::
* close::
@end menu
@iftex
See @ref{links}, @ref{link}; @ref{close}.
@end iftex
@c ---------------------------------------
@node option, pause, open, Other commands
@subsection option
@cindex option
@table @code
@item @strong{Syntax:}
@code{option ();}
@item @strong{Purpose:}
list all defined options
@item @strong{Syntax:}
@code{option (} option_name @code{);}
@item @strong{Purpose:}
set an option
@*To disable an option, use the prefix @code{no}.
@item @strong{Syntax:}
@code{option ( get );}
@item @strong{Purpose:}
dump the state of all options to an intvec
@item @strong{Syntax:}
@code{option ( set,} int_expression @code{);}
@item @strong{Purpose:}
restores the state of all options from an intvec (produced by @code{option(get)})
@sp 1
@item @strong{Values:}
@table @asis
@item @code{none}
reset all options to the default
@item @code{returnSB}
the functions @code{syz},@code{intersect},@code{quotient},@code{modulo} return a standard base instead
of a generating set.  This option should not be used for @code{lift}.
@item @code{fastHC}
try to find HC (highest corner of the staircase) as fast as possible
during a standard basis computation (only used for local orderings)
@item @code{interrupt}
allow fast interruption of standard basis computation
@item @code{intStrategy}
avoid divisions (of coefficients) during standard basis computations
@item @code{minRes}
special (additional) minimizing during computations (res,mres),
@*assumes homogeneous case and degree-compatible ordering
@item @code{morePairs}
create addditional (useless) pairs to speed up computation in some cases
@item @code{notRegularity}
disable the regularity bound for res/mres (see @ref{regularity})
@item @code{notSugar}
disable the sugar strategy
@item @code{prot}
protocol showing progress during standard basis computation
@item @code{redSB}
compute reduced standard basis
@item @code{redTail}
reduction of the tails of polynomials during standard basis computations
@item @code{sugarCrit}
use criteria similar to the homogeneous case to keep more useless pairs
@item @code{weightM}
automatically compute suitable weights for the weighted ecart and the
weighted sugar method
@item The following options have to be set without the option command:
@item @code{multBound}
a multiplicity bound is set (see @ref{multBound})
@item @code{degBound}
a degree bound is set (see @ref{degBound})
@item @code{Imap}
show the mapping of variables with the imap command
@item @code{loadLib}
show loading of libraries (default)
@item @code{debugLib}
warn about syntax errors during loading of libraries
@item @code{loadProc}
show loading of procedures from libraries
@item @code{mem}
show memory usage in square brackets
@item @code{prompt}
show prompt (@code{>} resp. @code{.}) if ready for input (default)
@item @code{reading}
show the number of characters read from a file
@item @code{redefine}
warn about variable redefinitions (default)
@item @code{usage}
show correct usage in error messages (default)
@end table
@item @strong{Example:}
@example
@c example
  option(prot);
  option();
  option(notSugar);
  option();
  option(noprot);
  option();
  option(none);
  option();
  ring r=0,x,dp;
  degBound=22;
  option();
  intvec i=option(get);i;
  option(none);
  option(set,i);
  option();
@c example
@end example
@end table
@menu
* degBound::
* multBound::
* std::
@end menu
@iftex
See @ref{degBound}; @ref{multBound}; @ref{std}.
@end iftex
@c ---------------------------------------
@node pause, print, option, Other commands
@subsection pause
@cindex pause
@table @code
@item @strong{Syntax:}
@code{pause;}
@item @strong{Purpose:}
pause the execution of a procedure until the return key is pressed
@item @strong{Example:}
@example
  // the procedure will continue if return is pressed:
  "press the return key to continue"; pause;
  @expansion{} press the return key to continue
  @expansion{} pause>

@end example
@end table
@c ---------------------------------------
@node print, quote, pause, Other commands
@subsection print
@cindex print
@table @code
@item @strong{Syntax:}
@code{print (} expression @code{);}
@*@code{print (} expression@code{,} format_string @code{);}
@item @strong{Purpose:}
pretty print of expressions, especially useful for matrices, modules
and vectors
@*The second form uses a string to determine the format.
@*At the moment only the "betti" format is used:
@table @code
@item "betti"
displays the graded Betti numbers of
@tex
$R^n/M$, if $R$ denotes the basering and if $M$ is a homogeneous submodule of $R^n$:
@end tex
@ifinfo
R^n/M, if R denotes the basering and if M is a homogeneous submodule of R^n:
@end ifinfo
@*The entry d at (i,j) is the minimal number of generators in degree i+j of
the j-th syzygy module of
@tex
$R^n/M$ (the 0-th (resp.1-st) syzygy module of $R^n/M$ is $R^n$ (resp. $M$))
@end tex
@ifinfo
R^n/M (the 0-th (resp.1-st) syzygy module of R^n/M is R^n (resp. M))
@end ifinfo
@end table
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  module m=[1,y],[0,x+z];
  m;
  print(m);  // the columns generate m
  intmat M=betti(mres(m,0));
  print(M,"betti");
@c example
@end example
@end table
@menu
* dbprint::
* short::
* type::
* betti::
@end menu
@iftex
See @ref{dbprint}; @ref{short}; @ref{type}; @ref{betti}.
@end iftex
@c ---------------------------------------
@node quote, setring, print, Other commands
@subsection quote
@cindex quote
@table @code
@item @strong{Syntax:}
@code{quote (} expression @code{)}
@item @strong{Purpose:}
prevent expresions from evaluation. Within a quoted expression, the
quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
effect of exactly one quoter). Used with @code{write}.
@item @strong{Example:}
@example
  link l="MPfile:w example.mp";
  ring r=0,(x,y,z),ds;
  ideal i=maxideal(3);
  ideal j=x7,x2,z;
  // compute i+j before writing, but not std
  write (l, quote(std(eval(i+j))));
  option(prot);
  close(l);
  // now read it in again and evaluate:
  read(l);
  close(l);
@end example
@end table
@menu
* write::
* eval::
@end menu
@iftex
See @ref{write}; @ref{eval}.
@end iftex
@c ---------------------------------------
@node setring, system, quote, Other commands
@subsection setring
@cindex setring
@table @code
@item @strong{Syntax:}
@code{setring} ring_name@code{;}
@item @strong{Purpose:}
change the base ring to another (already defined) ring
@item @strong{Example:}
@example
@c @c example
  ring r1=0,(x,y),lp;
  // the base ring is r1
  ring r2=32003,(a(1..8)),ds;
  // the base ring is r2
  setring r1;
  // the base ring is again r1
@c @c example
@end example
@item @strong{Use in proc:}
All changes of the base ring by a definition
of a new ring or a setring command in a proc are local to this proc.
@end table
@menu
* ring::
* keepring::
@end menu
@iftex
See @ref{ring}; @ref{keepring}.
@end iftex
@c ---------------------------------------
@node  system, type, setring, Other commands
@subsection system
@cindex system
@table @code
@item @strong{Syntax:}
@code{system (} expression_list @code{)}
@sp 1
the first expression must be of type string and selects the desired function.
@*@code{system} may return a result
@item @strong{Purpose:}
interface to internal data and the operating system
@*Not all functions will work on every platform.
@item @strong{functions}
@code{system("sh"},string_expression @code{)} is the shell escape,
  returns the return code of the shell@*
@code{system("pid")} return the process number (for creating unique names)@*
@code{system("getenv",}string_expression@code{)}
  return shell environment variable given as the second argument@*
@code{system("tty")} reset the terminal@*
@code{system("version")} return the version number of  @sc{Singular}
(type int)@*
@code{system("random"},int_expression @code{)} reset the random generator to the given value@*
@c @code{system("writemat"},file_name,matrix_expression@code{)} append a matrix
@c in the Macaulay format to the file.@*
@code{system("gen")} return the generating element of the multiplicative
group of Z/p\@{0@} (as int) where p is the characteristic of the basering@*
@code{system("HC")} return the order of the highest corner of the last @code{std}
computation or 0.
@item @strong{Example for UNIX:}
@example
  // a listing of the current directory:
  system("sh","ls");
  // execute a shell, return to Singular with exit
  system("sh","sh");
  string unique_name="/tmp/xx"+string(system("pid"));
  unique_name;
  @expansion{} /tmp/xx4711
  system("getenv","PATH");
  @expansion{} /bin:/usr/bin:/usr/local/bin
@end example
@item @strong{Example for MSDOS:}
@example
  // a listing of the current directory:
  system("sh","dir");
  // execute a shell, return to Singular with exit:
  system("sh","command");
  string unique_name="/tmp/xx"+string(system("pid"));
  unique_name;
  @expansion{} /tmp/xx0
@end example
@end table
@c @menu
@c @end menu
@iftex
@c See @ref{}; @ref{}; @ref{}; @ref{}; @ref{}.
@end iftex
@c ---------------------------------------
@node type, write, system, Other commands
@subsection type
@cindex type
@table @code
@item @strong{Syntax:}
@code{type} name@code{;}
@*expression;
@item @strong{Purpose:}
list the [name, level, type and] value of a variable
@item @strong{Example:}
@example
@c example
  int i=3;
  i;
  type i;
@c example
@end example
@end table
@menu
* Expressions::
@end menu
@iftex
See @ref{Expressions}.
@end iftex
@c ---------------------------------------
@node  write, ,type, Other commands
@subsection write
@cindex write
@table @code
@item @strong{Syntax:}
@code{write (} link@code{,} expression_list @code{);}
@*@code{write} ( link , key , value ) // DBM links, only
@item @strong{Purpose:}
Write data to a link. 
@*If the link is of type @code{Ascii}, all expressions are converted to
strings  (and separated by a newline character) before they are
written (as a consequence, only such values which can be converted to a
string can be written to an  @code{Ascii} link). 
@*For MP links,
ring-dependent expressions are written together with a ring
description. To prevent an evaluation of the expression before it is
written, the @code{quote} command (possibly together with @code{eval})
can be used. A @code{write} blocks (i.e. does not return), as long as a
MPtcp link is nor ready for writing. 
@*For DBM links, @code{write} inserts (key, value) into the
data base.
@item @strong{Example:}
@example
  //write the lines with the values of the variables f and i
  //then the value of m+a into the file "outfile"
  write(":w outfile",f,i,m+a);
  string filename=":a outfile";
  //now append the string "that was f,i,m+a" (without the quotes)
  // at the end of the file "outfile"
  write(filename,"that was f,i,m+a");
  // saving and retrieving data:
  ring r=32003,(x,y,z),dp;
  ideal i=x+y,z3+22y;
  write(":w save_i",i);// this writes x+y,z3+22y to the file save_i

  ring r=32003,(x,y,z),dp;
  string s=read("save_i");  //creates the string x+y,z3+22y
  execute "ideal k="+s+";"; // this defines an ideal k which@*
                            // is equal to i.
@end example
@end table
@menu
* read::
* links::
* Expressions::
* expression list::
* quote::
* eval::
* dump::
@end menu
@iftex
See @ref{read}, @ref{links}, @ref{Expressions}; @ref{expression list};
@ref{quote}; @ref{eval}; @ref{dump}.
@end iftex
@c ---------------------------------------
@node System variables, , Other commands, Commands
@section System variables
@cindex System variables
@ifinfo
@*List of all system variables.
@end ifinfo
@menu
* alternating::
* degBound::
* echo::
* minpoly::
* multBound::
* noether::
* printlevel::
* short::
* timer::
* TRACE var::
* voice::
@end menu
@c ---------------------------------------
@node alternating, degBound, System variables, System variables
@subsection alternating
@cindex alternating
@table @code
@item @strong{Syntax:}
@code{alternating =} int_expression@code{;}
@*int_variable @code{= alternating;}
@item @strong{Purpose:}
describes the position of the first alternating variable in the current
base ring, thus creating the tensor
product of a polynomial ring with an exterior algebra.
@*Remark: Setting @code{alternating=1;} defines the exterior algebra.
@item @strong{Note:}
These algebras are only available in those versions of
@sc{Singular} which are compiled with the SRING option.
The SRING version is
significantly slower for usual (commutative) ring operations.
@item @strong{Example:}
@example
  // define the exterior algebra in 3 variables x, y, z
  ring r=0,(x,y,z),dp;
  alternating=1;
  y*x;
  @expansion{} -1*xy
@end example
@end table
@menu
@strong{See:}
* int expression::
* ring::
@end menu
@iftex
See @ref{ring}; @ref{int expression}.
@end iftex
@c -----------------------------------------------------
@node degBound, echo, alternating, System variables
@subsection degBound
@cindex degBound
@table @code
@item @strong{Syntax:}
@code{degBound =} int_expression@code{;}
@*int_variable @code{ degBound;}
@item @strong{Purpose:}
The standard basis computation is stopped if the total
(weighted) degree
exceeds @code{degBound}
@*(should not be used for a global ordering with  inhomogeneous input)
@*Reset this bound by setting @code{degBound} to 0
@item @strong{Example:}
@example
  degBound = 7;
  option();
  @expansion{} //options for 'std'-command: degBound
  ideal j=std(i);
  degBound;
  @expansion{} 7
  degBound = 0; //resets degree bound to infinity
@end example
@end table
@menu
@strong{See:}
* int expression::
* option::
@end menu
@iftex
See @ref{int expression}; @ref{option}.
@end iftex
@c -----------------------------------------------------
@node echo, minpoly, degBound, System variables
@subsection echo
@cindex echo
@table @code
@item @strong{Syntax:}
@code{echo =} int_expression@code{;}
@*int_variable @code{= echo;}
@item @strong{Purpose:}
input will be echoed if @code{echo >= voice}.
@*echo is a local setting for a script and defaulted to 0.
@*echo does not affect the output of commands
@item @strong{Example:}
@c this example cannot be a computed one - echo interferes with -e
@example
  echo = 1;
  int i = echo;
  @expansion{} int i = echo;
@end example
@end table
@menu
@strong{See:}
* int expression::
* voice::
@end menu
@iftex
See @ref{int expression}; ref{voice}.
@end iftex
@c -----------------------------------------------------
@node minpoly, multBound, echo, System variables
@subsection minpoly
@cindex minpoly
@table @code
@item @strong{Syntax:}
@code{minpoly =} number_expression@code{;}
@*number_variable @code{= minpoly;}
@item @strong{Purpose:}
describe the coefficient field of the current basering as
an algebraic extension with the minimal polynomial equal to @code{minpoly}.
Setting the @code{minpoly} should be the first command after
defining the ring. 
@*@strong{Warning:} @sc{Singular} does not check whether the given
polynomial is irreducible!
@item @strong{Example:}
@example
@c example
  //(Q[i]/(i^2+1))[x,y,z]:
  ring Cxyz=(0,i),(x,y,z),dp;
  minpoly=i^2+1;
  i2;
@c example
@end example
@end table
@menu
@strong{See:}
* ring::
@end menu
@iftex
See @ref{ring}.
@end iftex
@c -----------------------------------------------------
@node multBound, noether, minpoly, System variables
@subsection multBound
@cindex multBound
@table @code
@item @strong{Syntax:}
@code{multBound =} int_expression@code{;}
@* int_variable @code{= multBound;}
@item @strong{Purpose:}
The standard basis computation is stopped if the ideal is
zerodimensional in a ring with local ordering
and its multiplicity (@code{mult}) is lower than @code{multBound}.
@*Reset this bound by setting @code{multBound} to 0
@item @strong{Example:}
@example
  multBound = 20;
  option();
  @expansion{} //options for 'std'-command: multBound
  ideal j=std(i);
  multBound;
  @expansion{} 20
  multBound = 0;//disbales multBound
@end example
@end table
@menu
@strong{See:}
* int expression::
* option::
@end menu
@iftex
See @ref{int expression}; @ref{option}.
@end iftex
@c -----------------------------------------------------
@node noether, printlevel, multBound, System variables
@subsection noether
@cindex noether
@table @code
@item @strong{Syntax:}
@code{noether =} poly_expression@code{;}
@*poly_variable@code{= noether;}
@item @strong{Purpose:}
The standard basis computation in local rings
cuts off  all monomials above
(in the sense of the monomial ordering)
the monomial @code{noether} during the computation.
@*Reset @code{noether} by setting @code{noether} to 0
@item @strong{Example:}
@example
@c example
  ring R=32003,(x,y,z),ds;
  ideal i=x2+y^12,y13;
  std(i);
  noether = x^11;
  std(i);
  noether = 0;//disables noether
@c example
@end example
@end table
@menu
@strong{See:}
* poly expression::
* degBound::
* std::
@end menu
@iftex
See @ref{poly expression}; @ref{std}.
@end iftex
@c -----------------------------------------------------
@node printlevel, short, noether, System variables
@subsection printlevel
@cindex printlevel
@table @code
@item @strong{Syntax:}
@code{printlevel =} int_expression@code{;}
@*int_variable @code{= printlevel;}
@item @strong{Purpose:}
set the debug level for dbprint.
If @code{printlevel} >= @code{voice} @code{dbprint} is equivalent to
@code{print}, otherwise nothing will be printed.
@item @strong{Example:}
@example
@c example
  printlevel=0;
  dbprint(1);
  printlevel=voice;
  dbprint(1);
@c example
@end example
@end table
@menu
@strong{See:}
* int expression::
* dbprint::
* voice::
@end menu
@iftex
See @ref{int expression}; @ref{dbprint}; @ref{voice}.
@end iftex
@c -----------------------------------------------------
@node short, timer, printlevel, System variables
@subsection short
@cindex short
@table @code
@item @strong{Syntax:}
@code{short =} int_expression@code{;}
@*int_variable @code{= short;}
@item @strong{Purpose:}
the output of monomials will be in the short manner,
if @code{short} is nonzero. A C-like notion is used, if short is zero.
Both notations may be used as input.
@*The default depends on the names of the ring variables
(0 if there are names of variables longer than 1 character, 1 otherwise). Every
change of the base ring sets @code{short} and will overwrite
the previous setting.
@item @strong{Example:}
@example
@c example
  ring r=23,x,dp;
  int save=short;
  short = 1;
  2x2,x2;
  short = 0;
  2x2,x2;
  short=save;//resets short to the previous value
@c example
@end example
@end table
@c -----------------------------------------------------
@node timer, TRACE var, short, System variables
@subsection timer
@cindex timer
@table @code
@item @strong{Syntax:}
@code{timer =} int_expression@code{;}
@*int_variable @code{= timer;}
@item @strong{Purpose:}
the time used for each command will be printed if timer >0 and if this
time is bigger than approx. 0.5 sec.
@*timer is defaulted to 0
@*How to use timer in order to measure the time for a sequence of commands,
see example below.
@item @strong{Example:}
@example
@c example
  timer = 1; // The time of each command is printed
  int t=timer;
  ring r=0,(x,y,z),dp;
  poly p=(x+2y+3z+4xy+5xz+6yz)^20;
  // timer as int_expression:
  timer-t;  // returns the time used in sec
            // since t was set to timer
@c example
@end example
@end table
@c ---------------------------------------
@node TRACE var, voice, timer, System variables
@subsection TRACE
@cindex TRACE

@table @code
@item @strong{Syntax:}
@code{TRACE =} int_expression@code{;}
@*int_variable @code{= TRACE;}
@item @strong{Purpose:}
set level of debugging
@* @code{TRACE=1} :
messages about entering and leaving of procedures are displayed
@* @code{TRACE=3} :
messages about entering and leaving of procedures together with
line numbers are displayed
@* @code{TRACE=4} : each line is echoed and the interpretation of commands
in this line is suspended until the user presses @code{<RETURN>}
@*@code{TRACE} is defaulted to 0
@*@code{TRACE} does not affect the output of commands
@item @strong{Example:}
@example
@c example
  TRACE = 1;
  LIB "general.lib";
  sum(1..100);
@c example
@end example
@end table
@menu
* int expression::
@end menu
@iftex
See @ref{int expression}.
@end iftex
@c ---------------------------------------
@node voice, ,TRACE var, System variables
@subsection voice
@cindex voice

@table @code
@item @strong{Syntax:}
int_variable @code{= voice;}
@item @strong{Purpose:}
level of nesting of procedures
@item @strong{Example:}
@example
@c example
  voice;
@c example
  proc p
  @{
    voice;
  @}
  @expansion{} 2
@end example
@end table
@c ---------------------------------------
@node procedures and Libraries, Tricks and Pitfalls, Commands, Top
@c @chapter Libraries
@chapter procedures and libraries
@cindex libraries
@cindex procedures
@include library.tex

@c ----------------------------------------------------------
@node Tricks and Pitfalls, Examples, procedures and Libraries, Top
@chapter Tricks and Pitfalls
@cindex Tricks and Pitfalls

@menu
* Limitations::
* Integer division::
* Monomials and Precedence::
* Behaviour of continue::
* Evaluation of logical expressions::
@end menu
@c -------------------------------------------------------------------------
@node Limitations,Integer division,,Tricks and Pitfalls
@section Limitations
@cindex Limitations

@sc{Singular} has the following limitations:
@table @bullet
@item
the characteristic of a prime field must be less than 32004
@item
the (weighted) degree of a monomial must be smaller than 2147483648
@item
the exponent of a ring variable must be smaller than 32768
@item
a ring must have 505 variables or less
@*(501 on a DEC Alpha)
@item
integers (of type @code{int}) have the limited range
from -2147483647 to 2147483647
@c @item
@c a token (in the input) must have 16383 characters or less.
@c @*(Tokens are strings, blocks of statements, numbers)
@c @*This does not apply to proc in libraries but to blocks
@c within a procedure
@item
the length of an identifier is unlimited but @code{listvar}
displays only the first 20 characters
@c @item
@c the interpretation of text between a closing @code{@}} and the end of the line is undefined. (Therefore do not put anything but spaces between @code{@}} and the end of the line.)
@end table

@c -------------------------------------------------------------------------
@node Integer division,Monomials and Precedence,Limitations,Tricks and Pitfalls
@section Integer division
@cindex Integer division
@cindex mod
@cindex div

A sequence of digits and @code{/} without spaces is of type number.
With spaces it is an expression of type ints
(and @code{/} is the integer division).
To avoid confusion use the operand @code{div}.
@example
@c example
  ring r=32002,x,dp;
  3/2;
  3 / 2;
  3 div 2;
  number(3) / number(2);
  number a=3;
  number b=2;
  a / b;
  a div b;
@c example
@end example
@c -------------------------------------------------------------------------
@node Monomials and Precedence,Behaviour of continue,Integer division,Tricks and Pitfalls
@section Monomials and Precedence
@cindex Monomials and Precedence

The computation of a monomial has precedence over all operators:
@example
@c example
  ring r=0,(x,y),dp;
  xy^2;
  x*y^2;
@c example
@end example
@c -------------------------------------------------------------------------
@node Behaviour of continue,Evaluation of logical expressions,Monomials and Precedence,Tricks and Pitfalls
@section Behaviour of continue
@cindex continue

Unlike the C-construct @code{continue}
@strong{does not execute the increment statement}.
@code{continue} is mainly for internal use.

@c -------------------------------------------------------------------------
@node Evaluation of logical expressions,,Behaviour of continue,Tricks and Pitfalls
@section Evaluation of logical expressions
@cindex and
@cindex or

@strong{All} arguments of a logical expressions are first
evaluated and then the value of the logical expression is
determined. For example, the logical expressions @code{(a || b)} is
evaluated by first evaluating @code{a} and @code{b}, even though the value of
@code{b} has no influence on the value of @code{(a || b)}. Note that
this is different from the left-to-right evaluation of logical
expressions (as found in most programming languages like C) which, for
example, determine the @code{(1 || b)} without evaluating @code{b}.

@c ------------------------------------------------------------------------
@node Examples, Library Index, Tricks and Pitfalls, Top
@include examples.tex
@c ----------------------------------------------------------
@node Library Index, Library Function Index, Examples, Top
@chapter Library Index
@cindex Library Index
@cindex LIBs

@sc{Singular} comes with a set of standard libraries:
@menu
* standard_lib:: extensions of singular kernel
* all_lib:: load all other libraries
* general_lib:: procedures of general type
* matrix_lib:: procedures for matrix operations
* sing_lib:: procedures for computing invariants of singularities
* elim_lib:: procedures for elimination, saturation and blowing up
* inout_lib:: procedures for manipulating in- and output
* random_lib:: procedures of random/sparse  matrix and poly operations
* deform_lib:: procedures for computing miniversal deformation
* homolog_lib:: procedures for homological algebra
* poly_lib:: procedures for manipulating polynomials and ideals
* factor_lib:: procedures for calling external factorizer (UNIX)
* ring_lib:: procedures for manipulating rings and maps
* finvar_lib:: procedures to calculate invariant rings & more
* primdec_lib:: procedures for primary decomposition
* invar_lib:: procedures to compute the ring of invariants
* tex_lib:: procedures for typeseting in TeX
* hnoether_lib:: procedures for the Hamburger-Noether-development
* classify_lib:: procedures for classifying hypersurface singularities
@end menu
@c ----------------------------------------------------------
@node standard_lib, all_lib, Library Index, Library Index
@section standard_lib
@cindex standard_lib
The library @code{standard.lib} provides extensions to the 
set of built-in commands and will be automatically loaded
during the start of @code{Singular}.
It contains:
@menu
* stdfglm::
* stdhilbert::
@end menu
@iftex
@*@code{stdfglm}:@ref{stdfglm};
@*@code{stdhilbert}:@ref{stdhilbert}.
@end iftex
@c ----------------------------------------------------------
@node all_lib, general_lib, standard_lib, Library Index
@section all_lib
@cindex all_lib
@c lib  all.lib
@c ----------------------------------------------------------
@node general_lib, matrix_lib, all_lib, Library Index
@section general_lib
@cindex general_lib
@c lib  general.lib
@c ----------------------------------------------------------
@node matrix_lib, sing_lib, general_lib, Library Index
@section matrix_lib
@cindex matrix_lib
@c lib matrix.lib
@c ----------------------------------------------------------
@node sing_lib, elim_lib, matrix_lib, Library Index
@section sing_lib
@cindex sing_lib
@c lib sing.lib
@c ----------------------------------------------------------
@node elim_lib, inout_lib, sing_lib, Library Index
@section elim_lib
@cindex elim_lib
@c lib elim.lib
@c ----------------------------------------------------------
@node inout_lib, random_lib,elim_lib, Library Index
@section inout_lib
@cindex inout_lib
@c lib inout.lib
@c ----------------------------------------------------------
@node random_lib, deform_lib, inout_lib, Library Index
@section random_lib
@cindex random_lib
@c lib random.lib
@c ----------------------------------------------------------
@node deform_lib,homolog_lib,random_lib, Library Index
@section deform_lib
@cindex deform_lib
@c lib deform.lib
@c ----------------------------------------------------------
@node homolog_lib,poly_lib,deform_lib, Library Index
@section homolog_lib
@cindex homolog_lib
@c lib homolog.lib
@c ----------------------------------------------------------
@node poly_lib,factor_lib,homolog_lib, Library Index
@section poly_lib
@cindex poly_lib
@c lib poly.lib
@c ----------------------------------------------------------
@node factor_lib,ring_lib,poly_lib, Library Index
@section factor_lib
@cindex factor_lib
@c lib factor.lib
@c ----------------------------------------------------------
@node ring_lib,finvar_lib,factor_lib, Library Index
@section ring_lib
@cindex ring_lib
@c lib ring.lib
@c ----------------------------------------------------------
@node finvar_lib,primdec_lib,ring_lib, Library Index
@section finvar_lib
@cindex finvar_lib
@c lib finvar.lib
@c ----------------------------------------------------------
@node primdec_lib,invar_lib,finvar_lib, Library Index
@section primdec_lib
@cindex primdec_lib
@c lib primdec.lib
@c ----------------------------------------------------------
@node invar_lib,tex_lib,primdec_lib, Library Index
@section invar_lib
@cindex invar_lib
@c lib invar.lib
@c ---------------------------------------------------------
@node tex_lib,hnoether_lib,invar_lib, Library Index
@section tex_lib
@cindex tex_lib
@c lib tex.lib
@c ---------------------------------------------------------
@node hnoether_lib,classify_lib,tex_lib, Library Index
@section hnoether_lib
@cindex hnoether_lib
@c lib hnoether.lib
@c ---------------------------------------------------------
@node classify_lib,,hnoether_lib, Library Index
@section classify_lib
@cindex classify_lib
@c lib classify.lib
@c ----------------------------------------------------------
@node Library Function Index, Index, Library Index, Top
@chapter Library Function Index
@printindex fn
@c ----------------------------------------------------------
@node Index, ,Library Function Index, Top
@chapter Index
@printindex cp
@c ---------------------------------------------------------
@contents
@bye
