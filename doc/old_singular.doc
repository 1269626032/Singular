@node Introduction, Getting started, Preface, Top
@chapter Introduction
@cindex Introduction


@sc{Singular} is a computer algebra system designed for special needs
in commutative algebra and algebraic geometry, with special features for
singularity theory.
@sc{Singular} can compute with ideals and modules
generated by polynomials or polynomial vectors over polynomial
rings or, more generally, over the localization of a
polynomial ring with respect to any ordering on the set of monomials
which is compatible with the semigroup structure.
There is also the possibility to do standard basis calculations and
hence computations of resolutions in modules over
supercommutative superalgebras
and Weyl algebras if @sc{Singular} is compiled with the appropriate options.
Hence, there is a wide range of applications in local and global algebraic
geometry (but @sc{Singular} is not limited to these areas).

We tried to set up the user interface as a consistent and flexible
language:
@enumerate
@item commands end with a semicolon (@code{;}), they are not
bound to one line
@item types of objects are numbers, polynomials, ideals, vectors, modules,
(polynomial) matrices, maps and integers, integer vectors and matrices, strings, lists,
(communication) links
@item there is an automatic type conversion whenever it is useful
@item the system is capable of executing procedures
with parameters, local variables
and return values
@item there are libraries of useful functions from several areas
@item this manual (and other documenation)
is also available as online information
@c @item @dots{} and much more documentation
@end enumerate
@c --------------------------------------
@section Background

@sc{Singular} performs algebraic manipulations on numbers, polynomials, ideals,
rings, modules, matrices and maps between rings.
The baserings are polynomial rings or localizations hereof over a field
(e.g finite fields, the rationals, reals, algebraic extensions,
transcendental extensions) or quotient rings with respect to an ideal.
The main objects in @sc{Singular} are ideals and modules,
one of the main algorithms is a general standard basis
algorithm with respect to
any semigroup ordering. This includes Buchberger's algorithm
(if the ordering is a wellordering) and Mora's algorithm (if the ordering is
a tangent cone ordering) as special cases.
Other algorithms include computing modules of syzygies,
finite free resolutions, Hilbert-Poincare series, etc.
The first implementation of the tangent cone algorithm
was done in Modula 2 at the Humboldt
University of Berlin by Gerhard Pfister and Hans
@tex
 Sch\"onemann
@end tex
@ifinfo
 Schoenemann
@end ifinfo
 in 1986.
@c It was mainly able to compute certain special invariants of singularities.
In September 1991 it became a joint project of the Humboldt University of
Berlin and the University of Kaiserslautern.
Since 1994 the development of @sc{Singular} is continued at Kaiserslautern.
@c The goal was to have all the
@c well known algorithms for computing in
@c nonhomogeneous ideals in polynomial and powers series rings.
The need for a new system arose from
the investigation of mathematical problems
coming from singularity theory which none of the existing systems
were able to compute.
Later we included an algorithm for multivariate polynomial factorization
in order to perform efficiently primary decomposition of ideals.
The need for solving big systems of polynomial equations, orginating
from practical problems in microelectronics, let us implement FGLM-techniques;
further algorithms for this purpose are to be implemented.
Thus, we hope to offer a useful system
for dealing with local and global computational aspects
of systems of polynomial equations.

@c ---------------------------------------
@section Notations

@code{Typewriter style} is used for @sc{Singular}  input and output,
@expansion{} in front of a line indicates output. @code{//} makes
the rest of the line a comment.
@c ---------------------------------------
@node Getting started,Command Syntax,Introduction, Top
@include start.tex
@c ---------------------------------------
@node Command Syntax,Expressions,Getting started, Top
@chapter Command Syntax
@cindex Command Syntax

@menu
* How to enter and exit::
* General syntax::
* Singular prompt and error recovery::
* Special characters::
* Usage of Names::
* Monomial orderings::
@end menu
@c -------------------------------------------------------------------------
@c @node How to enter and exit -- command line options,General syntax,,Command Syntax
@node How to enter and exit ,General syntax,,Command Syntax
@section How to enter and exit

@*To start @sc{Singular}, enter @code{Singular} at the system prompt.
@*You will get a header with the version name, the compilation date
and a short remark how to get help on
@sc{Singular}.
Enter @code{help;} to get the online manual at the @sc{Singular} prompt
@code{>}.
Commands are always ended with a @code{;} (semicolon) and @code{<ENTER>}.
Spaces and commas are always considered as separators. 
@*To exit @sc{Singular} enter @code{quit;}, @code{exit;} or @code{$}.


@sc{Singular} may also be started with command-line options and with 
filenames as arguments. More generally, the synopsis of @sc{Singular} is
@*@code{  Singular  [options] [file1 [file2 ...]] }
@*with the options (which can be given in both, their long and
short format):
@table @asis

@item @code{-b},@code{--batch} 
Run in MP batch mode. Opens a TCP/IP connection with host specified by
@code{--MPhost} at the port specified by @code{--MPport}. Input is read
from and output is written to this connection in the MP format.

@item @code{-h},@code{--help} 
Print a short help message and exit.

@item @code{-q},@code{--quiet}
Do not print start-up banner and warnings and redirect stderr (all error
messages)  to stdout (normal output channel).

@item @code{-t},@code{--no-tty} 
Do not redefine the terminal characteristics (useful for batch
processes, see @ref{Editing input}).  

@item @code{-v},@code{--version}             
Print extended information about the version and configuration of
@sc{Singular}  (used optional parts, compilation date, start of random
generator etc.). This information should be included if a user reports
an error to the authors.

@item @code{-e},@code{--echo[=VAL]} 
Set value of variable @code{echo} to @code{VAL} (integer in the range 0
.. 9). Without an argument, @code{echo} is set to 1, which echoes all
input coming from a file. By default, the value of @code{echo} is 0. See
also @ref{System variables}.

@item @code{-c},@code{--execute=STRING} 
Execute @code{STRING} as a (sequence) of @sc{Singular} commands on
start-up after the @code{.singularrc} file is executed, but prior to
executing the files given on the command line.

@item @code{-r},@code{--random=SEED}         
Seed (i.e., set initial value of) pseudo random generator with integer
(integer) @code{SEED} (integer). If this option is not given, then the
random generated is seeded with a time-based @code{SEED} (e.g., the
number of seconds since January, 1, 1970, on Unix systems).

@item @code{-u},@code{--user-option=STRING}
Returns @code{STRING} on @code{system("--user-option")}. This is useful
for passing arbitrary arguments (like filenames) from the command line to 
the @sc{Singular} interpreter (i.e. top-level of @sc{Singular}).

@item @code{--no-stdlib}
Do not load the library @code{standard.lib} on start-up. By default,
this library is loaded on start-up.

@item @code{--no-rc}               
Do not execute the @code{.singularrc} file on start-up. By default,
@sc{Singular} searches first in the current directory and then in the
home directory of the user for a file named @code{.singularrc}. If it is 
found, then it is executed after the library @code{standard.lib} is
loaded and prior to executing the string specified by
@code{--user-option}.

@item @code{--min-time=SECS}
If the @code{timer} variables is set, do only report times larger than
@code{SECS} seconds (@code{SECS} needs to be a floating point number
greater than 0). By default, this value is set to 0.5 (i.e., half a
second).

@item @code{--MPport=PORT} 
Use @code{PORT} as default port number for MP connections (whenever not
further specified) . This option is mandatory when the @code{--batch}
option is given. See also @ref{MPtcp links}.

@item @code{--MPhost=HOST}
Use @code{HOST} as default host for MP connections (whenever not
further specified) . This option is mandatory when the @code{--batch}
option is given. See also @ref{MPtcp links}.

@item @code{--ticks-per-sec=TICKS} 
Sets unit of timer to @code{TICKS} per second (i.e. the value reported by 
the @code{timer} variable multiplied by @code{TICKS} gives the time in
seconds.By default, this value is 1.

@end table
@*On start-up, @sc{Singular} 
@enumerate
@item 
loads the library @code{standard.lib} (provided the @code{--no-stdlib}
was not given)

@item
searches the current directory and then the
home directory of the user for a file named @code{.singularrc} and
executes it, if found (provided the @code{--no-rc} options was not
given)

@item 
executes the files @code{file1}, @code{file2} ...  (given on the command
line) in that order. 
@end enumerate

Unless otherwise specified, @sc{Singular} locates all (data) files and
libraries by first searching for them in the current working directory,
and then by searching through all the directories specified by the
environment variable @code{SINGULARPATH} (@code{SPATH} on DOS-based
systems) and finally by searching through some default directories
(e.g., @code{/usr/local/share/Singular}).

@c --------------------------------------------------------------------------
@node General syntax,Singular prompt and error recovery,How to enter and exit,Command Syntax
@section General syntax
@cindex General syntax
@cindex =
Every object in @sc{Singular} has a type, a value, a (possibly empty) name
and a (possibly empty) attribute list
(see @ref{typeof}; @ref{nameof}; @ref{attrib}).

@sc{Singular} output in examples is indicated with the sign @expansion{}
in front of it.

@strong{Example:}
@example
@c example
  int i=3;
  typeof(i); // type
  nameof(i); // name
  i;         // value
  attrib(i); //attributes
@c example
@end example
@*All input is case-sensitive.
@*Everything is built around expressions.
@*The general form of a command is (with optional parts in square brackets):
@itemize @bullet
@item
a @strong{definition}:
@*   type_name name [ @code{=} expression ] @code{;}
@* @strong{Example:}
@example
  ring r;              // creates the default ring
  poly f = x^2 + y^3 ; // define polynomial f=x^2+y^3
  poly g=xy+z2;        // define polynomial g=x*y+z^2
  ideal I = f,g;       // ideal generated by f and g
  matrix m[3][3];      // creates a 3 x 3 zero matrix
  int i=2;             // define the integer i and set i to 2
@end example
@item
an @strong{assignment}:
@*   name  @code{=} expression @code{;}
@*   name @code{=} expression_list @code{;}
@* @strong{Example:}
@example
  f = x^2 + y^2 ;      //overwrites the old value of f
  I = jacob(f);
  f,g = I[1],x^2+y^2 ; //overwrites the old values of f and g
@end example
@item
a @strong{command}:
@*   command_name [ @code{(} argument_list @code{)} ] @code{.}
@* @strong{Example:}
@example
  degree(I);
@end example
@item
a @strong{print command}:
@*   expression @code{;}
@*   @code{type} name @code{;}
@*   @code{print(} expression @code{);}
@* @strong{Example:}
@example
@c example
  int i=2; i;
  type i;              // name [ level ] type value
  print(i);
@c example
@end example
@end itemize
@c ---------------------------------------
@node Singular prompt and error recovery,Special characters,General syntax,Command Syntax
@section Singular prompt and error recovery
@cindex Singular prompt and error recovery
@cindex prompt
@cindex error recovery
The @sc{Singular} prompt @code{>}
asks the user for input of a command, while the prompt @code{.}
asks the user for input of missing parts of a command (remember the
semicolon @code{;} at the end of every command). If your input
is erroneous @sc{Singular} may miss the semicolon.
(It may be missed because @code{Singular} needs first a @code{"} or @code{@}}.)
On the other hand additional @code{;} will not harm @sc{Singular}:
extra semicolons are interpreted as empty statements.
@c -----------------------------------------
@node Special characters,Usage of Names,Singular prompt and error recovery,Command Syntax
@section Special characters
@cindex Special characters
The following characters/operators have special meanings:
@table @asis
@item @code{!}
synonymous to @code{not}
@item @code{&&}
synonymous to @code{and}
@item @code{||}
synonymous to @code{or}
@item @code{<>},@code{!=}
not equal: e.g. @code{if (i<>j)...}
@item @code{>=}
bigger or equal
@item @code{>}
bigger
@item @code{<=}
smaller or equal
@item @code{<}
smaller, but also used for file input (@ref{filecmd})
@item @code{=}
assignment: e.g. @code{int i=4711;}
@item @code{==}
equal: e.g. @code{if (i==j)...}
@item  @code{[}, @code{]}
indices in strings, integer vectors, ideals, matrices, polynomials and lists
and to build (poly) vectors: e.g. @code{ s[3], m[1,3], i[1..3],[f,g+x,0,0,1]}
@item  @code{(}, @code{)}
in expressions, for indexed names and for argument lists
@item  @code{+}
addition
@item  @code{-}
subtraction
@item  @code{*}
multiplication
@item  @code{/}
division for numbers (coefficients of polynomials) and polynomials
@item  @code{%}
integer modulo
@item  @code{^}, @code{**}
power, exponentiation
@item  @code{@@}
is a letter
@item  @code{#}
the reserved name of a list of not specified parameters in procedures
(see @ref{procedures and Libraries}).
@item  @code{"}
to start and end string constants
@item  @code{`}
to start and end name substitution
@item  @code{?}
is equivalent to @code{help}
@item  @code{;}
the separator for statements
@item  @code{,}
the separator for expression lists and function arguments
@item  @code{//}
makes the rest of the line a comment
@item  @code{\}
escape character for @code{"} within strings (see @ref{string expression})
@item  @code{..}
construct an intvec from start and end (see @ref{intvec expression})
@item  @code{::}
access identifiers within packages (complete name is package_name::identifier)
@item  @code{$}
ends @code{Singular}
@end table
@c ---------------------------------------
@node  Usage of Names, Monomial orderings, Special characters, Command Syntax
@section Usage of Names
@menu
* Reserved names::
* User defined names::
* Names in proc::
@end menu
@c ---------------------------------------
@node Reserved names, User defined names, ,Usage of Names
@subsection Reserved names

The following names are predefined commands or variables
and cannot be used otherwise:@*
@code{alternating},
@code{and},
@code{attrib},
@code{bareiss},
@code{basering},
@code{break},
@code{char},
@code{char_series},
@code{charstr},
@code{cleardenom},
@code{close},
@code{continue},
@code{contract},
@code{coef},
@code{coeffs},
@code{dbprint},
@code{def},
@code{defined},
@code{deg},
@code{degBound},
@code{degree},
@code{delete},
@code{det},
@code{diff},
@code{dim},
@code{div},
@code{dring},
@code{dump},
@code{echo},
@code{else},
@code{eval},
@code{exit},
@code{execute},
@code{export},
@code{extgcd},
@code{facstd},
@code{factorize},
@code{fetch},
@code{fglm},
@code{find},
@code{finduni},
@code{for},
@code{forif},
@code{freemodule},
@code{gcd},
@code{gen},
@code{getdump},
@code{help},
@code{hilb},
@code{homog},
@code{ideal},
@code{if},
@code{imap},
@code{indepSet},
@code{insert},
@code{int},
@code{interred},
@code{intersect},
@code{intmat},
@code{intvec},
@code{jacob},
@code{jet},
@code{kbase},
@code{keepring},
@code{kill},
@code{killattrib},
@code{koszul},
@code{lead},
@code{leadcoef},
@code{leadexp},
@code{LIB},
@code{lift},
@code{liftstd},
@code{link},
@code{list},
@code{listvar},
@code{map},
@code{matrix},
@code{maxideal},
@code{memory},
@code{minbase},
@code{minor},
@code{minpoly},
@code{minres},
@code{mod},
@code{module},
@code{monitor},
@code{mres},
@code{mstd},
@code{mult},
@code{multBound},
@code{nameof},
@code{names},
@code{ncols},
@code{newline},
@code{NF},
@code{noether},
@c @code{NOT},
@code{not},
@code{npars},
@code{nrows},
@code{number},
@code{nvars},
@code{open},
@code{or},
@code{ord},
@code{ordstr},
@code{option},
@code{package},
@code{pagelength},
@code{pagewidth},
@code{par},
@code{parameter},
@code{pardeg},
@code{parstr},
@code{pause},
@code{poly},
@code{preimage},
@code{prime},
@code{print},
@code{printlevel},
@code{proc},
@code{prune},
@code{qhweight},
@code{qring},
@code{quit},
@code{quote},
@code{quotient},
@code{random},
@c @code{rank},
@code{read},
@code{reduce},
@code{regularity},
@code{res},
@code{reservedName},
@code{resolution},
@code{resultant},
@code{return},
@code{ring},
@code{rtimer},
@code{rvar},
@code{setring},
@code{short},
@code{simplify},
@code{size},
@code{sortvec},
@code{sres},
@code{status},
@code{std},
@code{string},
@code{subst},
@code{system},
@code{syz},
@code{test},
@code{timer},
@code{TRACE},
@code{trace},
@code{transpose},
@code{type},
@code{typeof},
@code{var},
@code{varstr},
@code{vdim},
@code{vector},
@code{verbose},
@code{voice},
@code{wedge},
@code{weight},
@code{while},
@code{whileif},
@code{write}.

You  get a list of the reserved names by @code{reservedName();},
see @ref{reservedName}.
@c ---------------------------------------
@node User defined names, Names in proc, Reserved names, Usage of Names
@subsection User defined names

User defined global names start with a letter and consist only of letters and
digits.
They must not coincide with reserved names (keywords) and should not interfere
with monomials. All names are case sensitive.
Indexed names are built as
name followed by @code{(} int_expression @code{)}.
A list of indexed names can be built as a name followed by
@code{(} int_expression @code{)}.
@example
@c example
  ring R;
  int jindex=3;
  ideal j(3);
  ideal j(jindex);     // is equivalent with the above
  ideal j(2)=x;
  j(2..3);
@c example
@end example
@c ---------------------------------------
@node Names in proc, , User defined names, Usage of Names
@subsection Names in proc
@cindex Names in proc
@cindex local names

All variables are local to the procedure they are defined in.
These names cannot interfere with names in other
proc and are automatically deleted after having executed
the proc.
Names can be made global by @code{export} (see @ref{export}).
These global names will not be deleted automatically.
@example
  proc xxx
  @{
    int k=4;        //defines a local variable k
    int result=k+2;
    export result;  //defines the global variable "result".
  @}
@end example
If you type @code{listvar(all);} after having executed a proc you will
see that the variable @code{result} is still there while @code{k}
has been deleted.

The parameters of a proc can be accessed by their position, i.e.
@code{#[1]} for parameter 1 up
to the number of arguments.
Procedures can define argument lists, see @ref{procedures and Libraries}.
While interpreting a proc without a parameter list
there is a special variable:
@code{#} (of type list) holds all arguments,
@code{size(#)} is the number of arguments the proc was called with.
@example
  if (size(#) > 0)  @{ int i=#[size(#)]; @}
  //assign the last argument to the local variable i
@end example
Internally parameters and local variables are stored using
the nesting level,
you will see the nesting level
if you do a @code{listvar();} command inside a proc.
@c ---------------------------------------------------------------------------
@node Monomial orderings, , Usage of Names, Command Syntax
@section Monomial orderings
@cindex Monomial orderings
@tex
A monomial ordering (term ordering) on $K[x_1, \ldots, x_n]$ is
a total ordering $<$ on the
set of monomials (power products) $\{x^\alpha|\alpha \in \bf{N}^n\}$
which is compatible with the
natural semigroup structure, i.e.\ $x^\alpha < x^\beta$ implies $x^\gamma
x^\alpha < x^\gamma x^\beta$ for any $\gamma \in \bf{N}^n$.
We do not require
$<$ to be  a wellordering.
@end tex
@ifinfo
A monomial ordering (term ordering) on $[x_1, ..., x_n] is
a total ordering < on the
set of monomials (power products) @{x^a | a in N^n@}
which is compatible with the
natural semigroup structure, i.e. x^a < x^b implies x^c*x^a < x^c*x^b for any
c in N^n.
We do not require
< to be  a wellordering.
@end ifinfo
See the literature cited in @ref{Introduction}, (section 'Background').

@sc{Singular} offers the following monomial orderings which are implemented
in an effective way:
@menu
* global orderings:: lp, dp, wp, Dp, Wp.
* local orderings:: ls, ds, ws, Ds, Ws.
* module orderings:: c, C.
* matrix orderings:: M.
* product orderings::
* extra weight vector:: a.
@end menu
@iftex
@itemize @bullet
@item
global orderings or p-orderings: @code{lp, dp, Dp, wp, Wp} (p refers to polynomial ring)
@item
local orderings or s-orderings: @code{ls, ds, Ds, ws, Ws} (s refers to series ring)
@item
module orderings @code{c, C} (ordering of the components of a vector)
@item
matrix orderings @code{M} (may be used to define any allowed ordering)
@item
any of the above orderings may be combined to yield product or
block orderings.
@item
ordering @code{a} (inserting an extra weight vector)
@end itemize
@end iftex

@tex
Global orderings are wellorderings (i.e.\ $1 < x_i$ for each variable
$x_i$), local orderings satisfy $1 > x_i$ for each variable.   If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not wellorderings.

If $K$ is the groundfield, $x = (x_1, \ldots, x_n)$ the
variables and $<$ a monomial ordering, then {\bf Loc K}$[x]$ denotes the
localization of $K[x]$ with respect to the multiplicatively closed set $\{1 +
g \mid g = 0$ or $g \in K[x]\backslash \{0\}$ and $L(g) < 1\}$.   $L(g)$
denotes the leading monomial of $g$, i.e.\ the biggest monomial of $g$ with
respect to $<$.   The result of any computation which uses standard basis
computations has to be interpreted in {\bf Loc K}$[x]$ (like @code{std, syz, res,
mres, sres, mult, degree, dim, hilb, mstd}, etc.).
@end tex
@ifinfo
Global orderings are wellorderings (i.e.1 < x_i for each variable
x_i), local orderings satisfy 1 > x_i for each variable.
If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not wellorderings.

If K is the groundfield, x = (x_1, @dots{}, x_n) the
variables and < a monomial ordering, then Loc K[x] denotes the
localization of K[x] with respect to the multiplicatively closed set @{1 +
g | g = 0 or g in K[x]\@{0@} and L(g) < 1@}.   L(g)
denotes the leading monomial of g, i.e. the biggest monomial of g with
respect to <.   The result of any computation which uses standard basis
computations has to be interpreted in Loc K[x] (like @code{std, syz, res,
mres, sres, mult, degree, dim, hilb, mstd}, etc.).
@end ifinfo
@c --------------------------------------------------------------------------
@node global orderings, local orderings, , Monomial orderings
@subsection global orderings
@cindex global orderings

For all these orderings: Loc K[x] = K[x]

@table @asis
@item lp:
lexicographical ordering.
@*
@ifinfo
x^a < x^b  <==> there is an i,  1 <= i <= n :
@* a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@end ifinfo
@tex
$x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
\alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i <
\beta_i$.
@end tex
@item dp:
degree reverse lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) < deg(x^b), where deg(x^a) = a_1 + @dots{} + a_n,
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_n = b_n, @dots{}, a_(i+1) = b_(i+1), a_i > b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{$x^\alpha < x^\beta \Leftrightarrow $}$ \deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{$x^\alpha < x^\beta \Leftrightarrow$}$\alpha_n = \beta_n,
    \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i$.
@end tex
@item Dp:
degree lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) < deg(x^b)
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\alpha_1 = \beta_1,
    \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i$.
@end tex
@item wp:
weighted reverse lexicographical ordering.
@*
@ifinfo
 wp(w_1, @dots{}, w_n), w_i
@end ifinfo
@tex
${\tt wp}(w_1, \ldots, w_n),\; w_i$
@end tex
 positive integers,
 is defined as @code{dp}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@item Wp:
weighted lexicographical ordering.
@*
@ifinfo
 Wp(w_1, @dots{}, w_n), w_i
@end ifinfo
@tex
${\tt Wp}(w_1, \ldots, w_n),\; w_i$
@end tex
 positive integers,
 is defined as @code{Dp}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@end table
@c --------------------------------------------------------------------------
@node local orderings, module orderings, global orderings, Monomial orderings
@subsection local orderings
@cindex local orderings

For ls, ds, Ds and, if the weights are positive integers, also for ws and
Ws,  we have
@ifinfo
Loc K[x] = K[x]_(x),
@end ifinfo
@tex
$Loc\, K[x] = K[x]_{(x)}$,
@end tex
 the localization of K[x] at the
maximal ideal
@ifinfo
 (x_1, @dots{}, x_n).
@end ifinfo
@tex
\ $(x_1, ..., x_n)$.
@end tex

@table @asis
@item ls:
negative lexicographical ordering.
@*
@ifinfo
x^a < x^b  <==> there is an i,  1 <= i <= n :
@* a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i > b_i.
@end ifinfo
@tex
$x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
\alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i >
\beta_i$.
@end tex
@item ds:
negative degree reverse lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) > deg(x^b), where deg(x^a) = a_1 + @dots{} + a_n,
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_n = b_n, @dots{}, a_(i+1) = b_(i+1), a_i > b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow$ } $\deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\alpha_n = \beta_n,
    \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i$.
@end tex
@item Ds:
negative degree lexicographical ordering.
@*
@ifinfo
x^a < x^b <==>
@* deg(x^a) > deg(x^b)
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@end ifinfo
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$,
where $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ or
@end tex
@*@tex
    \phantom{$ x^\alpha < x^\beta \Leftrightarrow$ }$ \deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:$
@end tex
@*@tex
    \phantom{$ x^\alpha < x^\beta \Leftrightarrow$ } $\alpha_1 = \beta_1,
    \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i$.
@end tex
@item ws:
(general) weighted reverse lexicographical ordering.
@*
@ifinfo
 ws(w_1, @dots{}, w_n), w_1
@end ifinfo
@tex
${\tt ws}(w_1, \ldots, w_n),\; w_1$
@end tex
 a nonzero integer,
@ifinfo
w_2,@dots{},w_n
@end ifinfo
@tex
$w_2,\ldots,w_n$
@end tex
 any integer (including 0),
 is defined as @code{ds}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@item Ws:
(general) weighted lexicographical ordering.
@*
@ifinfo
 Ws(w_1, @dots{}, w_n), w_1
@end ifinfo
@tex
${\tt Ws}(w_1, \ldots, w_n),\; w_1$
@end tex
 a nonzero integer,
@ifinfo
w_2,@dots{},w_n
@end ifinfo
@tex
$w_2,\ldots,w_n$
@end tex
 any integer (including 0),
 is defined as @code{Ds}
 but with
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@end table

@c --------------------------------------------------------------------------
@node module orderings, matrix orderings, local orderings, Monomial orderings
@subsection module orderings
@cindex module orderings

@sc{Singular} offers also orderings on the set of ``monomials''
@ifinfo
@{ x^a*gen(i) | a in N^n, 1 <= i <= r @} on Loc K[x]^r = Loc K[x]gen(1)
+ @dots{} + Loc K[x]gen(r), where gen(1), @dots{}, gen(r) denote the canonical
generators of Loc K[x]^r, the r-fold direct sum of Loc K[x].
@end ifinfo
@tex
$\{ x^a gen(i) | a \in N^n, 1 \leq i \leq r \}$ on Loc K$[x]^r$ = Loc K[x]$gen(1)
+ \ldots +$Loc K[x]$gen(r)$, where $gen(1), \ldots, gen(r)$ denote the canonical
generators of Loc K[x]$^r$, the r-fold direct sum of Loc K[x].
@end tex

We have two possibilities, either to give priority to the component of a
vector of
@ifinfo
Loc K[x]^r
@end ifinfo
@tex
\ $Loc K[x]^r$\
@end tex
or (which is the default in @sc{Singular}) to give priority
to the coefficients.
The orderings @code{(<,c)} and @code{(<,C)} give priority to the coefficients;
@code{(c,<)} and @code{(C,<)} give priority to the components.
@*Let < be any of the monomial orderings of Loc K[x] as above.

@table @asis
@item (<,C):
@ifinfo
<_m = (<,C) denotes the module ordering (giving priority to the coefficients):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* x^a < x^b
@* or
@* x^a = x^b  and  i < j.
@end ifinfo
@tex
$<_m = (<,C)$ denotes the module ordering (giving priority to the coefficients):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow x^\alpha < x^\beta$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $x^\alpha = x^\beta $ and $ i < j$.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), ds;
  // the same as ring r = 0, (x,y,z), (ds, C);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example

@item (C,<):
@ifinfo
<_m = (C, <) denotes the module ordering (giving priority to the
component):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* i<j
@* or
@* i = j and x^a < x^b.
@end ifinfo
@tex
$<_m = (C, <)$ denotes the module ordering (giving priority to the component):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad   $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow i < j$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{$\quad \quad x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $ i = j $ and $ x^\alpha < x^\beta $.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), (C,lp);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example

@item (<,c):
@ifinfo
<_m = (<,c) denotes the module ordering (giving priority to the coefficients):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* x^a < x^b
@* or
@* x^a = x^b  and  i > j.
@end ifinfo
@tex
$<_m = (<,c)$ denotes the module ordering (giving priority to the coefficients):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow x^\alpha < x^\beta$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{\quad \quad $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $x^\alpha = x^\beta $ and $ i > j$.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), (lp,c);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example

@item (c,<):
@ifinfo
<_m = (c, <) denotes the module ordering (giving priority to the
component):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* i>j
@* or
@* i = j and x^a < x^b.
@end ifinfo
@tex
$<_m = (c, <)$ denotes the module ordering (giving priority to the component):
@end tex
@iftex
@*
@end iftex
@tex
\quad \quad   $x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow i > j$,
@end tex
@iftex
@*
@end iftex
@tex
    \phantom{$\quad \quad x^\alpha gen(i) <_m x^\beta gen(j) \Leftrightarrow $}
      or $ i = j $ and $ x^\alpha < x^\beta $.
@end tex

@strong{Example:}
@example
@c example
  ring r = 0, (x,y,z), (c,lp);
  [x+y2,z3+xy];
  [x,x,x];
@c example
@end example
@end table

@ifinfo
The output of a vector v in K[x]^r with components v_1,
@dots{}, v_r has the format v_1 * gen(1) + @dots{} + v_r * gen(r)
@end ifinfo
@tex
The output of a vector $v$ in $K[x]^r$ with components $v_1,
\ldots, v_r$ has the format $v_1 * gen(1) + \ldots + v_r * gen(r)$
@end tex
unless the ordering starts with @code{c}.
@ifinfo
In this case a vector will be written as [v_1, @dots{}, v_r].
@end ifinfo
@tex
In this case a vector will be written as $[v_1, \ldots, v_r]$.
@end tex
In all cases @sc{Singular} can read the
input in both formats.

@c --------------------------------------------------------------------------
@node matrix orderings, product orderings, module orderings,Monomial orderings
@subsection matrix orderings
@cindex matrix orderings

Let M be an invertible n x n matrix with integer coefficients and
@ifinfo
M_1, @dots{}, M_n
@end ifinfo
@tex
M$_1, \ldots,$ M$_n$
@end tex
 the rows of M.

The M-ordering < is the following:
@ifinfo
x^a < x^b <==> there exists an i: 1 <= i <= n :
M_1*a = M_1*b, @dots{}, M_(i-1)*a = M_(i-1)*b, M_i*a < M_i*b.
@end ifinfo
@tex
$x^a < x^b \Leftrightarrow$  there exists an $i: 1 <= i <= n :$
M$_1*a = $M$_1*b, \ldots, $M$_{i-1}*a = $M$_{i-1}*b$ and M$_i*a < $M$_i*b$.
@end tex

Thus,
@ifinfo
x^a < x^b
@end ifinfo
@tex
$x^a < x^b$
@end tex
if and only if M*a is smaller than M*b
with respect to the lexicographical ordering.

It is known that any monomial ordering can be represented by a matrix M in
GL(n,R), but, of course, only integer coefficients are of relevance in
practice.

The following matrices represent (for 3 variables) the global and
local orderings defined above (note that the matrix is not uniquely determined
by the ordering):

@ifinfo
@table @asis
@item lp:
 1   0   0
@* 0   1   0
@* 0   0   1
@item dp:
 1   1   1
@* 0   0  -1
@* 0  -1   0
@item Dp:
 1   1   1
@* 1   0   0
@* 0   1   0
@item wp(1,2,3):
 1   2   3
@* 0   0  -1
@* 0  -1   0
@item Wp(1,2,3):
 1   2   3
@* 1   0   0
@* 0   1   0
@item ls:
-1   0   0
@* 0  -1   0
@* 0   0  -1
@item ds:
-1  -1  -1
@* 0   0  -1
@* 0  -1   0
@item Ds:
-1  -1  -1
@* 1   0   0
@* 0   1   0
@item ws(1,2,3):
-1  -2  -3
@* 0   0  -1
@* 0  -1   0
@item Ws(1,2,3):
-1  -2  -3
@* 1   0   0
@* 0   1   0
@end table
@end ifinfo
@tex

lp:
$\left(\matrix{
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 0 & 0 & 1 \cr
 }\right)$
\quad dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

ls:
$\left(\matrix{
-1 & 0 & 0 \cr
 0 &-1 & 0 \cr
 0 & 0 &-1 \cr
 }\right)$
\quad ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$
@end tex

Product orderings represented by  a matrix:

@ifinfo
@table @asis
@item (dp(3), wp(1,2,3)):
1  1  1  0  0  0
@*0  0  -1  0  0  0
@*0  -1  0  0  0  0
@*0  0  0  1  2  3
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@item (Dp(3), ds(3)):
1  1  1  0  0  0
@*1  0  0  0  0  0
@*0  1  0  0  0  0
@*0  0  0  -1  -1  -1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@end table
@end ifinfo
@tex
@table @asis
@item (dp(3), wp(1,2,3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@item (Dp(3), ds(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@end table
@end tex

Orderings with extra weight vector (see below) represented by  a matrix:

@ifinfo
@table @asis
@item (dp(3), a(1,2,3),dp(3)):
1  1  1  0  0  0
@*0  0  -1  0  0  0
@*0  -1  0  0  0  0
@*0  0  0  1  2  3
@*0  0  0  1  1  1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@item (a(1,2,3,4,5),Dp(3), ds(3)):
1  2  3  4  5  0
@*1  1  1  0  0  0
@*1  0  0  0  0  0
@*0  1  0  0  0  0
@*0  0  0  -1  -1  -1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@end table
@end ifinfo
@tex
@table @asis
@item (dp(3), a(1,2,3),dp(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  1&  1&  1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@item (a(1,2,3,4,5),Dp(3), ds(3)):
$\left(\matrix{
1&  2&  3&  4&  5&  0 \cr
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0 & -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@end table
@end tex

@*@strong{Example}:
@example
@c example
  ring r = 0, (x,y,z), M(1, 0, 0,
                         0, 1, 0,
                         0, 0, 1);
@c example
@end example
@*which may also be written as:
@example
@c example
  intmat m[3][3]=1, 0, 0, 0, 1, 0, 0, 0, 1;
  m;
  ring r = 0, (x,y,z), M(m);
  r;
@c example
@end example

If the ring has n variables and the matrix contains less than n x n entries
an error message is given, if there are more entries,
the last ones will be ignored.

@strong{WARNING:} @sc{Singular}
does not check whether the matrix has full rank.   In such a case some
computations might not terminate, others might give a nonsense result.

Having these matrix orderings @sc{Singular} can compute standard bases for
any monomial ordering which is compatible with the natural semigroup structure.
In practice the global and local orderings together with block orderings should be
sufficient in most cases. These orderings are faster than the corresponding
matrix orderings, since evaluating a matrix product is time consuming.

@c --------------------------------------------------------------------------
@node product orderings, extra weight vector, matrix orderings, Monomial orderings
@subsection product orderings
@cindex product orderings

Let
@ifinfo
x = (x_1, @dots{}, x_n) = x(1..n) and y = (y_1, @dots{}, y_m) =
y(1..m)
@end ifinfo
@tex
$x = (x_1, \ldots, x_n) = x(1..n)$ and $y = (y_1, \ldots, y_m) =
y(1..m)$
@end tex
 be two ordered sets of variables,
@ifinfo
<_1 a monomial
ordering on Loc K[x] and <_2 a monomial ordering on Loc K[y].   The product
ordering (or block ordering) < = (<_1,<_2) on Loc K[x,y] is the following:
@*x^a y^b < x^A y^B <==>
@*x^a <_1 x^A
@*or
@*x^a = x^A  and  y^b <_2 y^B.
@end ifinfo
@iftex
@tex
$<_1$ a monomial
ordering on $Loc K[x]$ and $<_2$ a monomial ordering on $Loc K[y]$.   The product
ordering (or block ordering) $<\ := (<_1,<_2)$ on $Loc K[x,y]$ is the following:
@end tex
@*@tex
\quad \quad $x^a y^b < x^A y^B \Leftrightarrow x^a <_1 x^A$
@end tex
@*@tex
\phantom{\quad \quad $x^a y^b < x^A y^B \Leftrightarrow$}
or $x^a = x^A$ and $y^b <_2 y^B$.
@end tex
@end iftex

Inductively one defines the product ordering of more than two monomial
orderings.

In @sc{Singular}, any of the above global orderings, local orderings or matrix
ordering may be combined (in an arbitrary manner and length) to a product
ordering.   E.g. @code{(lp(3), M(1, 2, 3, 1, 1, 1, 1, 0, 0), ds(4), ws(1,2,3))}
defines: @code{lp} on the first 3 variables, the matrix ordering
@code{M(1, 2, 3, 1, 1, 1, 1, 0, 0)} on the next 3 variables,
@code{ds} on the next 4 variables and
@code{ws(1,2,3)} on the last 3 variables.

@c --------------------------------------------------------------
@node extra weight vector, , product orderings, Monomial orderings
@subsection extra weight vector
@cindex extra weight vector

@ifinfo
a: a(w_1, @dots{}, w_n),
@end ifinfo
@tex
a:\quad ${\tt a}(w_1, \ldots, w_n),\; $
@end tex
@ifinfo
w_1,@dots{},w_n
@end ifinfo
@tex
$w_1,\ldots,w_n$
@end tex
 any integer (including 0), defines
@ifinfo
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@end ifinfo
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@*
@ifinfo
x^a < x^b <== deg(x^a) < deg(x^b)
@end ifinfo
@tex
    $$x^\alpha < x^\beta \Leftarrow \deg(x^\alpha) < \deg(x^\beta),$$
@end tex
@ifinfo
@*
x^a > x^b <== deg(x^a) > deg(x^b)
@end ifinfo
@tex
    $$x^\alpha > x^\beta \Leftarrow \deg(x^\alpha) > \deg(x^\beta)$$
@end tex
@*An extra weight vector does not define a monomial ordering by itself:
it can only be used in combination with other orderings
to insert an extra line of weights into the ordering
matrix.
@*@strong{Example}:
@example
  ring r = 0, (x,y,z), (a(1,2,3),
                       wp(4,5,2));
  ring s = 0, (x,y,z), (a(1,2,3),dp);
  ring q=  0, (a,b,c,d),(lp(1),a(1,2,3),ds);
@end example
@c ---------------------------------------------------------------------------
@node Expressions, Commands, Command Syntax, Top
@chapter Expressions
@cindex Expressions
@menu
* string expression::
* int expression::
* boolean expression::
* intvec expression::
* intmat expression::
* rings::
* poly expression::
* number expression::
* ideal expression::
* vector expression::
* module expression::
* matrix expression::
* list expression::
* links::
* procedures::
* maps::
* untyped definitions::
* expression list::
* block::
@* operations
* implicit type conversions::
* type casting::
@end menu
@c @* operations between expression T.B.C.
@c @* implicit casts of expressions T.B.C.
@c @* defaults of expressions T.B.C.
@c --------------------------------------
@node string expression, int expression, Expressions, Expressions
@section string expession
@cindex string expression
@cindex newline

@c ------------------------------
@node string functions, ,string expression, string expression
@subsection string functions
@cindex string functions
@c ------------------------------
@node boolean expression, intvec expression,int expression,Expressions
@section boolean expression
@cindex boolean expression
@c ------------------------------
@node intvec expression, intmat expression, boolean expression,Expressions
@section intvec expression
@cindex intvec expression

@c ------------------------------
@node intvec functions, , intvec expression, intvec expression
@subsection intvec functions
@cindex intvec functions
@c ------------------------------
@node intmat expression, rings, intvec expression,Expressions
@section intmat expression
@cindex intmat expression

@c ------------------------------
@node intmat functions, , intmat expression, intmat expression
@subsection intmat functions
@cindex intmat functions
@c ------------------------------
@node rings, poly expression, intmat expression, Expressions
@section rings
@cindex rings
Every number, polynomial, vector, ideal, module and every matrix
(but not intmat)
in @sc{Singular} must be defined over a
base ring which is a polynomial ring over a field
or a localization hereof
(depending on the monomial ordering, see @ref{Monomial orderings})
or a quotient ring (factor ring) hereof modulo a standard basis.
The @code{ring} (resp. @code{qring} for quotient ring) command informs
@code{@sc{Singular}} about the coefficient field,
the names of indeterminants and the monomial ordering.
A definition of a ring sets this ring as the actual base ring.
The reserved word @code{basering} is an alias for the actual ring.
All subsequent definitions of
polynomials, vectors, ideals, modules and matrices
refer to this ring and are "local" to it
until a new ring is defined with a @code{ring} or a @code{qring}
or @code{setring} command.
Access to objects belonging to other rings
is only possible via a ring map,
i.e. via @code{map}, @code{imap} or @code{fetch}
(@code{imap} and @code{fetch} require that the rings are similiar enough).
@enumerate
@item
Coefficient fields are Z/p (p a prime <= 32003),
Galois fields GF(q) (q<=32761),
Q (the rational numbers), algebraic or transcedental extensions of Z/p or Q,
and real numbers (floats)
@item
The indeterminants (variables) of polynomials are names or indexed names
(e.g. @code{x,y} or @code{x(0),x(2),...} or @code{a(1..5)} for
@code{a(1),...,a(5)} or @code{b(5..1)} for @code{b(5),...,b(1)}
or @code{x1,x2,y1,y2}).
The set of indeterminants is always ordered.
@item
Monomial orderings are
the lexicographical ordering (@code{lp, ls}),
the degree reverse lexicographical ordering with weights 1 (@code{dp, ds})
or arbitrary weights (@code{wp, ws}),
the degree lexicographical ordering with weights 1 (@code{Dp, Ds})
or arbitrary weights (@code{Wp, Ws}),
or the matrix ordering (@code{M}).

The orderings @code{ls,ds,Ds,ws,Ws} describe orderings in series
rings; @code{lp,dp,Dp,wp,Wp} orderings in polynomial rings.
The orderings @code{lp,ls,dp,ds,wp,ws,Dp,Ds,Wp,Ws} can be combined
(yielding a block ordering).
They can also be combined with the special orderings @code{c, C}
(ordering of the components of a vector) and @code{a}
(inserting a weight vector into the order matrix).
See @ref{Monomial orderings}.
@end enumerate
See @ref{ring}; @ref{setring}; @ref{qring}; @ref{maps};
@ref{fetch}.
There are versions of @sc{Singular} which offer the
possibility to work in
supercommutative superalgebras (which includes exterior algebras)
or in Weyl algebras.
Such rings can be defined with @code{ring} and @code{alternating}
(supercommutative superalgebras) resp. with
@code{dring} (Weyl algebras). (See @ref{alternating}; @ref{dring}.)
@c ---------------------------------------
@node poly expression, number expression, rings,Expressions
@section poly expression
@cindex poly expression

@c ------------------------------
@node poly operations, poly functions, poly expression, poly expression
@subsection poly operations
@cindex poly operations
@c ------------------------------
@node poly functions, ,poly operations, poly expression
@subsection poly functions
@cindex poly functions
@c ---------------------------------------
@node number expression, ideal expression, poly expression,Expressions
@section number expression
@cindex number expression

@c ------------------------------
@node number operations, , , number expression
@subsection number operations
@cindex number operations
@c ------------------------------
@node ideal expression, vector expression, number expression,Expressions
@section ideal expression
@cindex ideal expression

@c ------------------------------
@node ideal operations, ideal functions, ideal expression, ideal expression
@subsection ideal operations
@cindex ideal operations
@c ------------------------------
@node ideal functions, ,ideal operations, ideal expression
@subsection ideal functions
@cindex ideal functions
@c ---------------------------------------
@node vector expression, module expression, ideal expression,Expressions
@section vector expression
@cindex vector expression

@c ------------------------------
@node vector operations, vector functions, vector expression, vector expression
@subsection vector operations
@cindex vector operations
@c ------------------------------
@node vector functions, ,vector operations, vector expression
@subsection vector functions
@cindex vector functions
@c ------------------------------
@node module expression, matrix expression, vector expression,Expressions
@section module expression
@cindex module expression

@c ------------------------------
@node module operations, module functions, module expression, module expression
@subsection module operations
@cindex module operations
@c ------------------------------
@node module functions, ,module operations, module expression
@subsection module functions
@cindex module functions
@c ---------------------------------------
@node matrix expression, list expression, module expression,Expressions
@section matrix expression
@cindex matrix expression

@c ------------------------------
@node matrix operations, matrix functions, matrix expression, matrix expression
@subsection matrix operations
@cindex matrix operations
@c ------------------------------
@node matrix functions, ,matrix operations, matrix expression
@subsection matrix functions
@cindex matrix functions
@c ---------------------------------------
@node list expression, links, matrix expression,Expressions
@section list expression
@cindex list expression

@c ------------------------------
@node list operations, list functions, list expression, list expression
@subsection list operations
@cindex list operations
@c ------------------------------
@node list functions, ,list operations, list expression
@subsection list functions
@cindex list functions
@c ---------------------------------------
@node links, procedures, list expression, Expressions
@section links
@cindex links

@table @code
@item @strong{Defintion:}
@*link_expression = previously declared link
@*link_expression = property_string @code{+} name_string
@*where
@*property_string = @code{""}, or type_string @code{+ ":" +} mode_string
@code{+ " "}
@*and
@*type_string = @code{""}, or @code{"Ascii"}, or @code{"MPfile"}, or
@code{"MPtcp"}, or @code{"DBM"}
@end table

@menu
* Link operations::
* Ascii links::
* MP links::
* DBM links::
@end menu
@iftex
See @ref{Ascii links}; @ref{MP links};  @ref{DBM links};
@end iftex

@c ---------------------------------------
@node Link operations, Ascii links, links, links
@subsection Link operations
@cindex Link operations
@c ---------------------------------------
@node Ascii links, MP links, Link operations, links
@subsection Ascii links
@cindex Ascii links
Via Ascii links data that can be converted to a string can be written
into files for storage or communcation with other programs. The data is
written in plain Ascii format. The output format of polynomials is done
w.r.t. the value of the global variable @ref{short}. Reading
from an Ascii links returns a string - conversion into other data is up to
the user.

Ascii links provide also the possibility to read from
@code{stdin} / write to @code{stdout}: the empty string as filename
denotes the terminal.
@table @code
@item @code{type_string:}
@code{"Ascii"} or @code{""}
@item @code{mode_string:}
@*@code{""}  // mode is set by first read/write
@*@code{"a"} // append mode (default for writing)
@*@code{"w"} // overwrite mode
@*@code{"r"} // read mode
@item @code{name_string:}
filename
@item @strong{Operations:}
@ref{open}, @ref{close}, @ref{status}, @ref{read}, @ref{write},
@ref{dump}, @ref{getdump}.
@item @strong{Restrictions:}
An Ascii link can be used either for reading or for writing, but not for
both at the same time. A @code{close} command must be used before a
change of i/o direction.

Types without a conversion to @code{string} cannot be written.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  link l=":w example.txt";     // type is Ascii, mode is overwrite
  l;
  status(l, "name");           // name is example.txt
  status(l, "open", "yes");    // link is not yet opened
  ideal i=maxideal(2);
  write (l,1,";",2,";","ideal i=",i,";");
  status(l, "open", "yes");    // now link is open
  status(l, "mode");           // for writing 
  write("example.txt","int j=5;");// data is appended to file
  read("example.txt");         // data is returned as string
  close(l);                    // link is closed
  execute read(l);             // read string is executed
  status(l, "open", "yes");    // now link is open
  status(l, "mode");           // in read mode
  close(l);                    // link is closed
  // dump vars overwriting previous file content:
  dump(":w example.txt");
  kill r;
  getdump("example.txt");      // get dump from file
  dump("");                    // dump to stdout
@c example
@end example

@end table
@c ---------------------------------------
@node MP links, DBM links, Ascii links, links
@subsection MP links
@cindex MP links
@menu
* MPfile links::
* MPtcp links::
@end menu

@c ---------------------------------------
@node MPfile links, MPtcp links, MP links, MP links
@subsubsection MPfile links
@cindex MPfile links
MPfile links provide the possibility to store data in a file using the
binary MP format. Read and write operations are very fast compared to
Ascii links. Therefore, for storing large amounts of data, MPfile links
should be used, instead of Ascii links. Unlike Ascii links, data read
from MPfile links is returned as expressions one at a time, and not as a
string containing the entire content of the file. Furthermore, ring
dependent data is stored together with a ring description. Therefore,
reading ring-dependent data might change the current ring.

@table @code
@item @code{type_string:}
@code{"MPfile"}
@item @code{mode_string:}
@code{""} // mode is set by first read/write
@*@code{"a"} // append mode (default for writing)
@*@code{"w"} // overwrite mode
@*@code{"r"} // read mode
@item @code{name_string:}
filename
@item @strong{Operations:}
@ref{open}, @ref{close}, @ref{status}, @ref{read}, @ref{write},
@ref{dump}, @ref{getdump}, @ref{quote}, @ref{eval}.
@item @strong{Restrictions:}
An MP file link can be used either for reading or for writing, but not for
both at the same time. A @code{close} command must be used before a
change of i/o direction.
@item @strong{Example:}
@example
@c example
  ring r;
  link l="MPfile:w example.mp"; // type=MPfile, mode=overwrite
  l;
  status(l, "name"); // name is example.mp; link is not yet opened
  ideal i=maxideal(2);
  write (l,1, i, "hello world");// write three expressions
  status(l, "open", "yes");     // now link is open
  status(l, "mode");            // in write mode
  write(l,4);                   // append one more expression
  close(l);                     // link is closed
  read(l);                      // only first expression is read
  status(l, "open", "yes");     // now link is open
  status(l, "mode");            // for reading
  kill r;
  def i = read(l);              // second expression
  listvar();                    // notice that current ring was set
  def s = read(l);              // third expression
  close(l);                     // link is closed
  dump("MPfile:w example.mp");  // dump everything to example.mp
  kill basering, s; listvar();  // kill all vars
  getdump("MPfile: example.mp");// get dump from file
@c example
@end example
@end table
@c ---------------------------------------
@node MPtcp links, , MPfile links, MP links
@subsubsection MPtcp links
@cindex MPtcp links
MPtcp links give the possibility to exchange data in the binary MP
format between two processes which may run on the same or different
computers. MPtcp links can be opened in four different modes: listen,
connect, launch, and fork. 

@*Opening an MPtcp link in listen mode blocks
until a connection to the specified port was made by a connect
call. Opening a MPtcp link in connect mode, supposes that an application
is listening for a connection at the specified host and port. 

@*Opening an MPtcp link in launch mode, launches the specified
application (using rsh, i.e., the application to launch must either be
given with an absolute pathname, or must be in a directory contained in
the search path) on the specified host.  The launching side (client)
"listens" at a chosen port, until the launched (server) application
which was launched with the additional command line arguments "--MPmode
connect --MPhost hostname --MPport portnumber" (hostname and portnumber
are substituted by their respective values) does a connect call. To
launch @sc{Singular} in server mode, the command line option @code{-b}
must be added.

@*Opening an MPtcp link in fork mode, forkes a child of the current
@sc{Singular}, which will take the role of a server, i.e. after the
connection between the parent (client) and child (server) is
established, the child @sc{Singular} goes into server mode. All
variables and their values which existed in the parent
@sc{Singular} befor the fork link was opened, are inherited by the child
(i.e. forked) @sc{Singular}. 

@*To arrange the
evaluation of an expression by a server, the expression must be quoted,
so that a local evaluation is prevented (otherwise, the expression is
evaluated first, and the result of the evaluation is written, instead of
the expression which is to be evaluated).

If @sc{Singular} is in server mode, the value of the variable
@code{mp_ll} is the MPtcp link connecting to the client and
@sc{Singular} is in an infinite read-eval-write loop until the
connection is closed from the client side (by closing its connecting
link). Reading and writing is done to the link @code{mp_ll} -- after an
expression is read, it is evaluated and the result of the evaluation is
written back.  That is, for each expression which was written to the
server, there is exactly one expression written back (which might be an
"empty" expression, if the evaluation on the server side does not return
a value).

MPtcp links should explicitely be opened before being used. MPtcp links
are bidirectional, i.e., can be be used for both, writing and
reading. Reading from an MPtcp link blocks until data was written to
that link. The @code{status} command can be used to check whether there
is data to read. 

@table @code
@item type_string:
@code{"MPtcp"}
@sp 1
@item mode_string:
@code{"fork"}
@*@code{""} // default MPtcp mode is fork
@item mode_string:
@code{"launch"}
@item name_string:
host_spec @code{+} application_spec
@sp 1
@item mode_string:
@code{"listen"}
@item name_string:
port_spec
@sp 1
@item mode_string:
@code{"connect"}
@item name_string:
host_spec @code{+} port_spec
@sp 1
@item application_spec
@code{""} // "Singular -b" is used as default MPapplication
@*@code{" --MPapplication "+} application // application to launch; must be in search path
@item host_spec
@code{""} // localhost is used as default MPhost
@*@code{" --MPhost "} hostname // used host for connection
@item port_spec
@code{" --MPport "} portnumber // string specifying the port to use
@sp 1
@item @strong{Operations:}
@ref{open}, @ref{close}, @ref{status}, @ref{read}, @ref{write},
@ref{dump}, @ref{getdump}, @ref{quote}, @ref{eval}.
@item @strong{Example:}
@example
@c example
  LIB "general.lib"; // needed for "which" and "killall" commands
  // MPtcp:launch link for launching Singular in batch modus
  // on the local host 
  link l="MPtcp:launch";
  open(l); 
  l; // notice that link is ready for writing but not for reading
  ring r; ideal i=x2+y,xyz+z,x2+y2;
  write (l,quote(std(eval(i)))); // std(i) is computed on server
  // server wrote result back -- ready for reading
  def j = read(l);   // result of computation on server is read
  j;
  write(l, quote(std(i)));
                     // std of polynomial "i" is computed on server
  def k = read(l);   // result of computation is read
  k; basering;       // notice that a new ring was created and set
  listvar(all);
  write(l, killall); read(l);
                     // write killall procedure to server
  // and kill everything in server, but links (need to protect mp_ll)
  write(l, quote(killall("not", "link"))); read(l); 
  write(l, quote(getdump(mp_ll))); // server gets dump 
  dump(l);           //  dump is written to server (includes proc's)
  read(l);           // result of previous write-command is read
  killall("not", "link"); killall("proc");
                     // kills eveything, but links
  write(l, quote(dump(mp_ll))); // server writes dump
  getdump(l);        // dump is read from server
  read(l);           // result of previous write-command is read
  close(l);          // server is shut down
  listvar(all);      // same state as we had before "killall()"
  l = "MPtcp:";      // fork link declaration
  open(l); l;        // Notice that name is "parent"
  // and name of forked link is "child"
  write(l, quote(status(mp_ll, "name")));
  read(l);
  write(l, quote(i)); // Child inherited vars and their values
  read(l);
  close(l);          // shut down forked child
@c example
@end example
@end table
@c ---------------------------------------
@node DBM links, , MP links, links
@subsection DBM links
@cindex DBM links
DBM links provide access to data stored in a data base
(using the unix dbm or gdbm library).

@table @code
@item @code{type_string:}
@code{"DBM"}
@item @code{mode_string:}
@code{""} // mode is set by first read to "r"
@*@code{"r"} // read mode
@*@code{"rw"} // read and overwrite mode
@item @code{arguments:}
filename
@item @strong{Usage}
@code{read} ( link ) @expansion{} string
@*returns the key of the next entry of the data base
@sp 1
@code{read} ( link , key ) @expansion{} string
@*@code{read} returns the value to the key from the data base
@sp 1
@code{write} ( link , key , value )
@*inserts the pairs of strings (key, value) into the data base
(requires mode @code{"rw"})
@sp 1
@code{write} ( link , key )
@*delete the pair with key @code{key} from the data base
(requires mode @code{"rw"})
@item @strong{Restrictions:}
Arguments to @code{read} and @code{write} must be strings.
@item @strong{Example:}
@example
@c example
  link dbmLink="DBM:rw example";
  write(dbmLink,"1","abc");
  write(dbmLink,"3","XYZ");
  write(dbmLink,"2","ABCc");
  dbmLink;
  close(dbmLink);
  // read all keys (till empty string):
  read(dbmLink);
  read(dbmLink);
  read(dbmLink);
  read(dbmLink);
  // read data corresponding to key "1"
  read(dbmLink,"1");
  // read all data:
  read(dbmLink,read(dbmLink));
  read(dbmLink,read(dbmLink));
  read(dbmLink,read(dbmLink));
  // close
  close(dbmLink);
@c example
@end example
@end table
@c ---------------------------------------
@node procedures, maps, links, Expressions
@section procedures
@cindex procedures

Procedures are user defined functions with an arbritrary number of arguments
of any type which return a result.
They contain sequences of @sc{Singular} commands in a special format.
Procedures are used to extend the set of functions with your own functions.
Procedures are kept in the main memory (or in library files, see @ref{LIB}).
You can also store more than one procedure in a single file
(see @ref{procedures and Libraries}).
(E.g. the file @code{sing.lib} may contain the procedures @code{milnor} and @code{tjurina}.
After reading @code{sing.lib} the functions @code{milnor} and @code{tjurina} may be used
as if they were @sc{Singular} functions.) @*
Procedures can be "called" like a normal function by
typing their name followed by the list of arguments
in parentheses. If the procedure is not already in
main memory it will be loaded and kept there. The call then executes
the sequence of commands stored in the specified procedure.
@* See @ref{proc}; @ref{LIB}.
@c ---------------------------------------
@node untyped definitions, expression list, maps, Expressions
@section untyped definitions
@cindex untyped definitions

Objects may also be defined without a type: they get their
type from the first assignment to them.
E.g. @code{ideal i=x,y,z; def j=i^2;} defines the ideal @code{i^2}
with the name @code{j}.
@*Note: Unlike other assignments a ring as an untyped object
is not a copy but another reference to the same ring.
@example
  ring r;
  def s=basering;
  setring s;
@end example
defines a ring @code{s} which is just another reference (or name)
for the @code{basering}. This is useful if the basering
is not local to the procedure (so it cannot be accessed by its name)
but you need a name for it (e.g. for a use with @code{setring} or @code{map}).
@code{setring r;} does not work in this case, because
@code{r} may not be local to the procedure.
@* See @ref{def}.
@c ---------------------------------------
@node expression list, block, untyped definitions,Expressions
@section expression list
@cindex expression list
An expression list is any comma separated list of expressions.
@*@strong{Example:}
@example
@c example
  ring r;
  poly f=x2-y3;
  int i=37;
  string s1="abc";
  string s2="def";
  string s=s1,s2; // typecast from expression list to string
  s;
  s1,s2;
  f,i,s;
@c example
@end example
@c ------------------------------
@node block,implicit type conversions,expression list,Expressions
@section block
@cindex block
A block is a sequence of commands surrounded by @{ and @}. Blocks
are used for proc, if, else, while and for statements.
@example
  @{
     command;
     @dots{}
  @}
@end example
@menu
* if::
* for::
* while::
* proc::
@end menu
@iftex
See @ref{if}; @ref{for}; @ref{while}; @ref{proc}
@end iftex
@c ------------------------------
@node implicit type conversions, type casting, block, Expressions
@section implicit type conversions
@cindex implicit type conversions
Assignments convert the type of an expression to the type
of the left-hand side of the assignment.
Operations, which require certain
types of operands can also implicitly convert the type of an
expression (e.g. you can multiply a polynomial by an integer because
the integer is automatically converted to polynomial).
Possible conversions are:
@* @sp 1
@enumerate
@item
@code{int} @expansion{} @code{poly}
@item
@code{int} @expansion{} @code{number}
@item
@code{number} @expansion{} @code{poly}
@item
@code{int} @expansion{} @code{vector}
(i @expansion{} i*gen(1))
@item
@code{poly} @expansion{} @code{vector}
(p @expansion{} p*gen(1))
@item
@code{int} @expansion{} @code{intvec}
@item
@code{intvec} @expansion{} @code{intmat}
@item
@code{matrix} @expansion{} @code{module}
@item
@code{vector} @expansion{} @code{module}
@item
@code{ideal} @expansion{} @code{module}
@item
@code{ideal} @expansion{} @code{matrix}
@item
@code{vector} @expansion{} @code{matrix}
@item
@code{module} @expansion{} @code{matrix}
@item
@code{intvec} @expansion{} @code{matrix}
@item
@code{intmat} @expansion{} @code{matrix}
@item
@code{string} @expansion{} @code{proc}
@item
@code{resolution} @expansion{} @code{list}
@item
@code{list} @expansion{} @code{resolution}.
@end enumerate

Note that type conversions do not act transitively.
@c ---------------------------------
@node type casting, ,implicit type conversions,Expressions
@section type casting
@cindex type casting
An expression can be converted to another type by using a type name
as a function returning this type.
Possible type castings are:
@enumerate
@item
to @code{string} from @code{int}, @code{number}, @code{poly}, @code{vector},
 @code{ideal}, @code{matrix}, @code{module}, @code{map}, @code{proc}
@item
to @code{int} from @code{number}, @code{poly}
@item
to @code{number} from @code{poly}
@item
to @code{poly} from @code{int}, @code{number}
@item
to @code{ideal} from @code{vector}, @code{poly},
@code{matrix}, @code{int}, @code{number}
@item
to @code{ideal} from expression lists of @code{poly},
@code{int}, @code{number}. (The list may be empty)
@item
to @code{ideal} from @code{matrix}, @code{vector}, @code{poly}, @code{module}
@item
to @code{matrix} from @code{module}, @code{ideal}, @code{vector}.
@* There are two forms to convert something to a matrix:
if @code{matrix(xx)} is used then the size of the matrix will
be determined by xx.
But @code{matrix(xx,a,b)} may also be used - the result is
an a x b matrix.
@item
to @code{intvec} from expression lists of @code{int}. (The list may be empty)
@item
to @code{module} from expression lists of @code{vector}
@code{int}, @code{number}, @code{poly}. (The list may be empty)
@item
to @code{module} from @code{matrix}, @code{vector}, @code{ideal}.
@item
to @code{list} from expression lists of any type. (The list may be empty)
@end enumerate
@strong{Examples:}
@example
@c example
  ring r=0,x,(c,dp);
  number(3x);
  number(poly(3));
  ideal i=1,2,3,4,5,6;
  print(matrix(i));
  print(matrix(i,3,2));
  vector v=[1,2];
  print(matrix(v));
  module(matrix(i,3,2));
@c example
@end example
@c ---------------------------------------
@node Commands, procedures and Libraries, Expressions, Top
@chapter Commands
@cindex Commands
@ifinfo
@*List of all supported commands.
@end ifinfo
@menu
* Declaration commands::
* Functions::
* Control structures::
* Proc commands::
* Other commands::
* System variables::
@end menu
@c ---------------------------------------
@node Declaration commands, Functions, Commands, Commands
@section Declaration commands
@cindex Declaration commands

The general syntax for a declaration command is
@*
  type name [ @code{=} expression ] @code{;}
@*
where type stands for one of the data types of @sc{Singular},
name for the name of the object you are creating and expression
is any expression of the type or one that can be converted to the type
of the object (see @ref{Expressions}).
The expression is defaulted whenever possible. @*
It is possible to redefine or overwrite an already existing object
(as an object of the same type).
A redefinition will
first set the variable to the default value and then compute the expression.
The difference between redefinition and overwriting is shown in the following
example:
@*
@*@strong{Example:}
@example
@c example
  int i=3;
  i=i+1;        // overwriting
  i;
  int i=i+1;   // redefinition
  i;
@c example
@end example
@ifinfo
@*List of all supported declaration commands.
@end ifinfo
@menu
* int::
* string::
* intvec::
* intmat::
* ring::
* poly::
* number::
* ideal::
* vector::
* module::
* matrix::
* map::
* qring::
* dring::
* list::
* def::
* proc::
* link::
@end menu
@c ---------------------------------------
@node int, string, Declaration commands, Declaration commands
@subsection int
@cindex int

@menu
* int expression::
@end menu
@iftex
See @ref{int expression}.
@end iftex
@c ---------------------------------------
@node string, intvec, int, Declaration commands
@subsection string
@cindex string

@menu
* string expression::
@end menu
@iftex
See @ref{string expression}.
@end iftex
@c ---------------------------------------
@node intvec, intmat, string, Declaration commands
@subsection intvec
@cindex intvec

@menu
* intvec expression::
@end menu
@iftex
See @ref{intvec expression}.
@end iftex
@c ---------------------------------------
@node intmat, ring, intvec, Declaration commands
@subsection intmat
@cindex intmat

@menu
* intmat expression::
@end menu
@iftex
See @ref{intmat expression}.
@end iftex
@c ---------------------------------------
@node ring, poly, intmat, Declaration commands
@subsection ring
@cindex ring
@cindex basering

@table @code
@item @strong{Syntax:}
@example
  @code{ring} name @code{=} field@code{,}
              @code{(} names_of_ring_variables @code{),}
              @code{(} ordering @code{);}
@end example
@item @strong{Default:}
@example
  32003,(x,y,z),dp;
@end example
@item @strong{Purpose:}
define a base ring for polynomials, ideals, vectors, modules
and matrices and set it as the actual basering

All advanced algorithm in @sc{Singular} require a ring.
The last defined ring is the basering until a new ring is defined
or until it is changed with @code{setring} or @code{keepring} or
it gets killed.

The coefficient field is given by either
@table @bullet
@item
the characteristic (0 or a prime <= 32003)
@item
an expression_list of the characteristic and
the names of  parameters.
If there is only one parameter you may define a minimal polynomial for it
to work in an algebraic extension of Q or F(p).
See @ref{minpoly}
@item
an expression_list of the number of element
(a small prime characteristic p to the power of a small exponent n) and a
name for a primitive element (generating the multiplicative group).
The maximal values for p and n depend on the files in the directory @code{gftables}.
They define the finite field with p^n elements.
@item
the name @code{real}. The field elements will be the machine floating
point numbers.
@end table
@*If you write a  characteristic which is not a prime,
it is automatically converted
to the next lower prime or you receive an error message.

The names of ring variables
are like variable names (comma separated).

The ordering is a list
of blockorderings which have an order keyword
(lp, ls, dp, ds, Dp, Ds, wp, ws, Wp, Ws, M, c, a) and an optional number of variables
(for lp, ls, dp, ds, Dp, Ds) or a list of
weights (for wp, ws, Wp, Ws, a and M).
If none of the orderings C or c (order by components) is given,
C will be appended at the end of the list of orderings.
@*
If one element of the list consists of only one entry, the parentheses may
be omitted.
@item @strong{Example:}
@example
  ring r =
  32003,       // coefficient field: Z/32003
  ( x,y,z ),   // names for variables
  ds;          // monomial ordering
               // (degrevlex in a series ring)
               // parenthesis of lists with only one element
               // are optional
@end example
@example
  ring r2=10,(x(1..6)),(lp(2),dp(4));
               // defines a ring with name r2,
               // (10 is substituted by the next lower prime)
               // coefficient field: Z/7
               // variables x(1),x(2),..,x(6)
               // which is the polynomial ring (Z/7)[x(1),..,x(6)]
               // with lexicographical ordering on x(1) and x(2)
               // and then
               // degree reverse lexicographical on x(3)..x(6)
@end example
@example
  ring r3=0,(x,y,z,a,b,c),(ds(3), dp(3));
               // defines a ring with name r3,
               // coefficient field Q
               // variables x,y,z,a,b,c
               // which is the ring (Q[a,b,c])[x,y,z]_(x,y,z)
@end example
@example
  ring r4=0,(x,y,z),(c,dp);
               // defines a ring with name r4,
               // coefficient field Q (rationals)
               // variables x,y,z
               // which is the polynomial ring Q[x,y,z]
               // with ordering of vectors by
               // first number of the component and then
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r5=(7,a),(x,y,z),dp;
               // defines a ring with name r5,
               // coefficient field K=(Z/7)(a)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // with ordering
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r6=(7,a),(x,y,z),dp;
  minpoly=a^2+a+3;
               // defines a ring with name r6,
               // coefficient field K=(Z/7)[a]/a^2+a+3
               // (the finite field with 49 elements)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // with ordering
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r7=(7^2,a),(x,y,z),dp;
                // defines a ring with name r7,
                // the same ring as r6
                // this option is offered for
                // a few powers of primes
                // (see file gftable/49)
                // the computations are faster
                //   in this representation
@end example
@example
  ring r8=(181,A,B,Z),(x,y,z),dp;
               // defines a ring with name r8
               // coefficient field K=Z/181(A,B,Z)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r9=real,(x,y,z),dp;
               // defines a ring with name r9
               // coefficient field R
               // (represented as floating point numbers)
               // variables x,y,z
               // which is the polynomial ring R[x,y,z]
               // degree reverse lexicographical on x,y,z
  number n=1.7e+2; // input format of real numbers
@end example

@item @strong{Note:}
Computations in rings with one parameter are faster
than computations with more parameters. (Cancellation of common factors
are only implemented in the first case)

@* Computation over the field @code{real} has computing errors because
of rounding.
@item @strong{Use in proc:}
All changes of the base ring by a definition
of a new ring or a setring command in a proc are local to this proc
(i.e. will not affect the calling procedure)
unless a @code{keepring} command is used.
@end table
@menu
* Baserings and ground fields::
* ring::
* Monomial orderings::
* qring:: define quotient rings
* dring:: define Weyl algebras
* charstr:: the coefficient field
* npars:: number of parameters
* nvars:: number of variables
* ordstr:: the monomial ordering
* parstr:: the parameters
* par:: the parameter as number
* varstr:: the ring variables
* var:: the ring variables as poly
* setring:: a local ring change
* keepring:: ring change in the next (upper) level
@end menu
@iftex
See @ref{Baserings and ground fields}; @ref{ring}; @ref{Monomial orderings};
@ref{qring}; @ref{alternating}; @ref{dring}; @ref{charstr}; @ref{npars};
@ref{nvars}; @ref{ordstr};
@ref{varstr}; @ref{var}; @ref{setring}; @ref{keepring}.
@end iftex
@c ---------------------------------------
@node poly, number, ring, Declaration commands
@subsection poly
@cindex poly

@menu
* poly expression::
@end menu
@iftex
See @ref{poly expression}.
@end iftex
@c ---------------------------------------
@node number, ideal, poly, Declaration commands
@subsection number
@cindex number

@menu
* number expression::
@end menu
@iftex
See @ref{number expression}.
@end iftex
@c ---------------------------------------
@node ideal, vector, number, Declaration commands
@subsection ideal
@cindex ideal

@menu
* ideal expression::
* poly expression::
@end menu
@iftex
See @ref{ideal expression}; @ref{poly expression}.
@end iftex
@c ---------------------------------------
@node vector, module, ideal, Declaration commands
@subsection vector
@cindex vector

@menu
* vector expression::
* module expression::
@end menu
@iftex
See @ref{vector expression}; @ref{module expression}.
@end iftex
@c ---------------------------------------
@node module, matrix, vector, Declaration commands
@subsection module
@cindex module

@menu
* module expression::
* vector expression::
@end menu
@iftex
See @ref{module expression};
@ref{vector expression}.
@end iftex
@c ---------------------------------------
@node matrix, map, module, Declaration commands
@subsection matrix
@cindex matrix

@menu
* matrix expression::
* poly expression::
@end menu
@iftex
See @ref{matrix expression}; @ref{poly expression}.
@end iftex
@c ---------------------------------------
@node  qring, dring, map, Declaration commands
@subsection qring
@cindex qring

@table @code
@item @strong{Syntax:}
@code{qring} name @code{=} ideal_expression @code{;}
@item @strong{Purpose:}
define a quotient ring as the base ring modulo a standard basis

The ideal must be a standard basis.
The qring command performs a change of the base ring to this
new ring.
@item @strong{Default:}
none
@item @strong{Example:}
@example
@c example
  ring r1=32003,(x,y,z),dp;
  ideal i=std(ideal(x,y));
  qring q=i;
  basering;
  std(ideal(x+y,x+y+z,z));
@c example
@end example
@end table
@menu
* ideal expression::
* ring::
@end menu
@iftex
See @ref{ideal expression}; @ref{ring}.
@end iftex
@c ---------------------------------------
@node  list, def, dring, Declaration commands
@subsection list
@cindex list

@menu
* type casting::
* expression list::
* list expression::
@end menu
@iftex
See @ref{type casting}; @ref{expression list}; @ref{list expression}.
@end iftex

@strong{Note:} If one element of a list belongs to a ring, the whole
list belongs to that ring.
@c ---------------------------------------
@node  def, proc, list, Declaration commands
@subsection def
@cindex def

@table @code
@item @strong{Syntax:}
@code{def} name @code{=} expression @code{;}
@item @strong{Purpose:}
define an object of the same type as the right-hand side
@item @strong{Default:}
none
@item @strong{Note:}
This is useful if the right-hand side may be of
variable type as a consequence of a computation (e.g. ideal or module or
matrix ..)
@item @strong{Example:}
@example
@c example
  def i=2;
  typeof(i);
@c example
@end example
@end table
@menu
* untyped definitions::
* typeof::
@end menu
@iftex
See @ref{untyped definitions}; @ref{typeof}.
@end iftex
@c ---------------------------------------
@node proc, link, def,  Declaration commands
@subsection proc
@cindex proc
@table @code
@item @strong{Syntax:}
@code{proc} name block
@*@code{proc} name parameter_list block
@item @strong{Purpose:}
define a new function
@item @strong{Default:}
none
@item @strong{Example (for a procedure without an argument list):}
@example
  // this proc tests if it is called with exactly one argument n
  // and print the numbers 1 to n
  // If the proc is called without an argument or with more
  //  than one argument, a message is displayed
  // # is a reserved name and denotes the list of arguments,
  // #[i] is the i-th argument
  proc print_n
  @{
    if (size(#) != 1)
    @{
      "USAGE: print_n ( int_expression );";
      return();
    @}
    int i;
    for(i=1;i<=#[1];i=i+1)
    @{
      i;
    @}
  @}

  print_n();
  @expansion{} USAGE: print_n ( int_expression );
  print_n(1+2);
  @expansion{} 1
  @expansion{} 2
  @expansion{} 3
  print_n(1,2);
  @expansion{} USAGE: print_n ( int_expression );
@end example
@end table
For a description of the paramter_list see @ref{parameter list}.
A convenient and recommended way to define procedures is to prepare a file
(see @ref{procedures and Libraries})
and read this file with the @code{LIB} command.
The difference between procedures from libraries and
other procedures is the missing help and example part
which may be provided in a library file.
@menu
* LIB::
* procedures and Libraries::
* procedures::
* proc in a library::
* Examples::
* block::
* return::
@end menu
@iftex
See @ref{LIB}; @ref{procedures}; @ref{Examples}; @ref{block}; @ref{return}.
@end iftex
@c ---------------------------------------
@node link,,proc,  Declaration commands
@subsection link
@cindex link
@table @code
@item @strong{Syntax:}
@code{link} name @code{=} string_expression @code{;}
@item @strong{Purpose:}
defines a new communcation link
@item @strong{Default:}
stdin/stdout
@item @strong{Example:}
@example
  link l=":w example.txt";
  int i=22;
  string s="An int follows:";
  write(l,s,i);
  l;
  close(l);
  read(l);
  l;
  read(l);
  close(l);
@end example
@end table
@menu
* links::
* read::
* write::
* open::
* close::
@end menu
@iftex
See @ref{links}; @ref{read}; @ref{write}; @ref{open}; @ref{close}.
@end iftex
@c ---------------------------------------
@c ---------------------------------------
@node procedures and Libraries, Tricks and Pitfalls, Commands, Top
@chapter procedures and libraries
@cindex libraries
@cindex procedures
@include library.tex

@c ----------------------------------------------------------
@node Library Index, Library Function Index, Examples, Top
@chapter Library Index
@cindex Library Index
@cindex LIBs

@sc{Singular} comes with a set of standard libraries:
@menu
* standard_lib:: extensions of singular kernel
* all_lib:: load all other libraries
* general_lib:: procedures of general type
* matrix_lib:: procedures for matrix operations
* sing_lib:: procedures for computing invariants of singularities
* elim_lib:: procedures for elimination, saturation and blowing up
* inout_lib:: procedures for manipulating in- and output
* random_lib:: procedures of random/sparse  matrix and poly operations
* deform_lib:: procedures for computing miniversal deformation
* homolog_lib:: procedures for homological algebra
* poly_lib:: procedures for manipulating polynomials and ideals
* factor_lib:: procedures for calling external factorizer (UNIX)
* ring_lib:: procedures for manipulating rings and maps
* finvar_lib:: procedures to calculate invariant rings & more
* primdec_lib:: procedures for primary decomposition
* invar_lib:: procedures to compute the ring of invariants
* tex_lib:: procedures for typeseting in TeX
* hnoether_lib:: procedures for the Hamburger-Noether-development
* classify_lib:: procedures for classifying hypersurface singularities
@end menu
@c ----------------------------------------------------------
@node standard_lib, all_lib, Library Index, Library Index
@section standard_lib
@cindex standard_lib
The library @code{standard.lib} provides extensions to the 
set of built-in commands and will be automatically loaded
during the start of @code{Singular}.
It contains:
@menu
* stdfglm::
* stdhilbert::
@end menu
@iftex
@*@code{stdfglm}:@ref{stdfglm};
@*@code{stdhilbert}:@ref{stdhilbert}.
@end iftex
@c ----------------------------------------------------------
@node all_lib, general_lib, standard_lib, Library Index
@section all_lib
@cindex all_lib
@c lib  all.lib
@c ----------------------------------------------------------
@node general_lib, matrix_lib, all_lib, Library Index
@section general_lib
@cindex general_lib
@c lib  general.lib
@c ----------------------------------------------------------
@node matrix_lib, sing_lib, general_lib, Library Index
@section matrix_lib
@cindex matrix_lib
@c lib matrix.lib
@c ----------------------------------------------------------
@node sing_lib, elim_lib, matrix_lib, Library Index
@section sing_lib
@cindex sing_lib
@c lib sing.lib
@c ----------------------------------------------------------
@node elim_lib, inout_lib, sing_lib, Library Index
@section elim_lib
@cindex elim_lib
@c lib elim.lib
@c ----------------------------------------------------------
@node inout_lib, random_lib,elim_lib, Library Index
@section inout_lib
@cindex inout_lib
@c lib inout.lib
@c ----------------------------------------------------------
@node random_lib, deform_lib, inout_lib, Library Index
@section random_lib
@cindex random_lib
@c lib random.lib
@c ----------------------------------------------------------
@node deform_lib,homolog_lib,random_lib, Library Index
@section deform_lib
@cindex deform_lib
@c lib deform.lib
@c ----------------------------------------------------------
@node homolog_lib,poly_lib,deform_lib, Library Index
@section homolog_lib
@cindex homolog_lib
@c lib homolog.lib
@c ----------------------------------------------------------
@node poly_lib,factor_lib,homolog_lib, Library Index
@section poly_lib
@cindex poly_lib
@c lib poly.lib
@c ----------------------------------------------------------
@node factor_lib,ring_lib,poly_lib, Library Index
@section factor_lib
@cindex factor_lib
@c lib factor.lib
@c ----------------------------------------------------------
@node ring_lib,finvar_lib,factor_lib, Library Index
@section ring_lib
@cindex ring_lib
@c lib ring.lib
@c ----------------------------------------------------------
@node finvar_lib,primdec_lib,ring_lib, Library Index
@section finvar_lib
@cindex finvar_lib
@c lib finvar.lib
@c ----------------------------------------------------------
@node primdec_lib,invar_lib,finvar_lib, Library Index
@section primdec_lib
@cindex primdec_lib
@c lib primdec.lib
@c ----------------------------------------------------------
@node invar_lib,tex_lib,primdec_lib, Library Index
@section invar_lib
@cindex invar_lib
@c lib invar.lib
@c ---------------------------------------------------------
@node tex_lib,hnoether_lib,invar_lib, Library Index
@section tex_lib
@cindex tex_lib
@c lib tex.lib
@c ---------------------------------------------------------
@node hnoether_lib,classify_lib,tex_lib, Library Index
@section hnoether_lib
@cindex hnoether_lib
@c lib hnoether.lib
@c ---------------------------------------------------------
@node classify_lib,,hnoether_lib, Library Index
@section classify_lib
@cindex classify_lib
@c lib classify.lib
@c ----------------------------------------------------------
@node Library Function Index, Index, Library Index, Top
@chapter Library Function Index
@printindex fn
@c ----------------------------------------------------------
@node Index, ,Library Function Index, Top
@chapter Index
@printindex cp
@c ---------------------------------------------------------
@contents
@bye
