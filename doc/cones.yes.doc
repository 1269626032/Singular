@comment -*-texinfo-*-
@comment this file contains the cone/fan definitions

@c -------------------------------------------------------------------
@node cone, fan, User defined types, Data types
@section cone
@cindex cone

In order to use convex objects in Singular, Singular has to be build from sources
together with gfanlib, a C++ library for convex geometry by Anders N. Jensen.
Please check the readme file for installation instructions.
Alternatively, the library @code{gfanr.lib} provides this C++ library and an interface to it.

In the finite dimensional real vector space R^n, a convex rational polyhedral
cone, in short ``cone'', is the convex set generated by finitely many half-lines,
which in turn are generated by rational, and hence integer, points. It may or may not
contain whole subspace of R^n (e.g. entire lines). The biggest subspace contained in
a cone is called ``lineality space''. Modulo its lineality space, each cone is
generated by a distinct minimal set of half lines, which are referred to as
``rays''. Alternatively, a cone can be represented as a set of points satisfying
a system homogeneous rational, and hence integer, linear inequalities and equations.
These two characterizations of cones are the two main ways of defining cones in
Singular (@pxref{coneViaPoints}, @pxref{coneViaInequalities}).

@smallexample
LIB"gfan.lib";
cone c;                             // ambient dim 0, no equations,
                                    // no inequalities
cone c = 17;                        // ambient dim 17, no equations,
                                    // no inequalities
@end smallexample

See @ref{gfan_lib}.
@c --------------------------------------------------------------------------------
@node fan, polytope, cone, Data types
@section fan
@cindex fan

In order to use convex objects in Singular, Singular has to be build from sources
together with gfanlib, a C++ library for convex geometry by Anders N. Jensen.
Please check the readme file for installation instructions.
Alternatively, the library @code{gfanr.lib} provides this C++ library and an interface to it.

A polyhedral fan is a collection of cones closed under taking intersections and
faces.

@smallexample
  fan f;                              // ambient dim 0, no cones, lineality
                                      // space = ambient space
  fan f = emptyFan(int n);            // ambient dim = n, no cones,
                                      // symmetry subgroup = <e>
  fan f = n;                          // synonymous convenience method for
                                      // 'fan f = emptyFan(n)'
  fan f = emptyFan(
                 optional intmat G);  // symmetry group generated by rows of
                                      // G; ambient dim = number of columns
                                      // of G
            // Here a row r = r_1, ...r_n represents the permutation
            // which takes i to r_i. SINGULAR will check for the validity
            // of the provided rows, i.e. whether @{r_1,...,r_n@} = @{1,...,n@}
  fan f = fullFan(int n);             // ambient dim = n, the fan consists of
                                      // one cone which equals the ambient
                                      // space, symmetry subgroup = <e>
  fan f = fullFan(
                 optional intmat G);  // symmetry group generated by rows of
                                      // G; ambient dim = number of columns
                                      // of G; the fan consists of one cone
                                      // which equals the ambient space
@end smallexample

See also @ref{gfan_lib}.
@c --------------------------------------------------------------------
@node polytope, pyobject, fan, Data types
@section polytope
@cindex polytope

In order to use convex objects in Singular, Singular has to be build from sources
together with gfanlib, a C++ library for convex geometry by Anders N. Jensen.
Please check the readme file for installation instructions.

In R^n, a rational convex polytope (in short ``polytope'') is a set of points
satisfying a system rational, and hence integer, linear inequalities and equations.
It is internally realised as a cone in R^(n+1) intersected with the hyperplane,
in which the first coordinate equals 1.

See @ref{polymakeInterace_lib} for details.

@menu
* polytopeViaPoints::
* polytopeViaInequalities::
@end menu
@c --------------------------------------------------------------------------------
@node polytopeViaPoints,polytopeViaInequalities,,polytope
@subsection polytopeViaPoints
@cindex polytopeViaPoints
@table @code
@item @strong{Syntax:}
@code{polytopeViaPoints(} intmat V @code{)}
@*@code{polytopeViaPoints(} intmat V, int flags @code{)}
@item @strong{Type:}
polytope
@item @strong{Purpose:}
polytope which is the intersection of the cone generated by the row vectors of V
with the hyperplane, in which the first coordinate equals 1;
flags may be 0 or 1,
if flags is 1, then program assumes that each row vector of M generates a ray in the cone,
if flags is 0, then program computes that information itself.
@item @strong{Example:}
@smallexample
@c example
LIB"gfan.lib";
// This is a polytope in R^2 generated by (0,0), (1,0), (0,1), (0,0);
intmat V[4][3]=
1,0,0,
1,1,0,
1,0,1,
1,1,1;
polytope p=polytopeViaPoints(V);
p;
// This is a polytope in R^2 generated by (1/2,2/3), (3/4,4/5), (5/6,6/7):
intmat V[3][3]=
6,3,4,
20,15,16,
42,35,36;
polytope p=polytopeViaPoints(V);
p;
// This polytope is the positive orthant in R^2:
// (0,1,0) and (0,0,1) imply that the polytope is unbounded in that direction
intmat V[3][3]=
1,0,0,
0,1,0,
0,0,1;
polytope p=polytopeViaPoints(V);
p;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node polytopeViaInequalities,polytope related functions,polytopeViaPoints,polytope
@subsection polytopeViaInequalities
@cindex polytopeViaInequalities
@table @code
@item @strong{Syntax:}
@code{polytopeViaInequalities(} intmat IE @code{)}
@*@code{polytopeViaInequalities(} intmat IE, intmat E @code{)}
@*@code{polytopeViaInequalities(} intmat IE, intmat E, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself.
@item @strong{Example:}
@smallexample
@c example
LIB"gfan.lib";
intmat IE[2][3]=
1,0,0,
0,1,0;
intmat E[1][3]=
0,0,1;
polytope p=polytopeViaInequalities(IE,E);
p;
@c example
@end smallexample
@end table

@c --------------------------------------------------------------------
