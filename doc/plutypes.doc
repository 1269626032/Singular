@comment -*-texinfo-*-
@comment $Id: plutypes.doc,v 1.2 2002-12-20 14:11:26 levandov Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plureference.info
@node Top, Data types
@menu
* Data types::
@end menu

@node Data types, Functions and system Variables, General concepts, Top
@chapter Data types
%**end
@end ignore

@cindex expression list
This chapter explains all data types of @sc{Singular} in
alphabetical order. For every type, there is a description of the
declaration syntax as well as information about how to build expressions
of certain types.

The term expression list in @sc{Singular} refers to any comma separated
list of expressions.

For the general syntax of a declaration see @ref{General command syntax}.

@menu
* ideal::
* list::
* map::
* module::
* poly::
* qring::
* resolution::
* ring::
@ifset namespaces
* package::
@end ifset
@end menu


@c ---------------------------------------
@node ideal, list, Data types, Data types
@section ideal
@c@cindex ideal
@cindex  untyped definitions 

Ideals are represented as lists of polynomials which are interpreted as
left generators of  the ideal. For two-sided ideals see @ref{twostd}. 


Like polynomials they
can only be defined or accessed with respect to a basering.

@strong{Note:} @code{size} counts only the non-zero generators of an ideal
whereas @code{ncols} counts all generators. 


@menu
* ideal declarations::
* ideal expressions::
* ideal operations::
* ideal related functions::
@end menu

@c ---------------------------------------
@node ideal declarations, ideal expressions, ideal, ideal
@subsection ideal declarations
@cindex ideal declarations

@table @strong
@item Syntax:
@code{ideal} name @code{=} list_of_poly_and_ideal_expressions @code{;}
@*@code{ideal} name @code{=} ideal_expression @code{;}

@item Purpose:
defines an ideal.

@item Default:
0

@item Example:
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  poly s1 = x2;
  poly s2 = y3;
  poly s3 = z;
  ideal i =  s1, s2-s1, 0,s2*s3, s3^4;
  i;
  size(i);
  ncols(i);
@c example
@end smallexample
@end table

@c ------------------------------
@node ideal expressions, ideal operations, ideal declarations, ideal
@subsection ideal expressions
@cindex ideal expressions

An ideal expression is:
@enumerate
@item
an identifier of type ideal
@item
a function returning ideal
@item
ideal expressions combined by the arithmetic operations
@code{+} or @code{*}
@item
a power of an ideal expression (operator @code{^} or @code{**})
@*Note that the computation of the product @code{i*i} involves
all products of generators of @code{i} while @code{i^2} involves
only the different ones, and is therefore faster.
@item
a type cast to ideal
@end enumerate

@*@strong{Example:}
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  ideal m = maxideal(1);
  m;
  poly f = x2;
  poly g = y3;
  ideal i = x*y*z , f-g, g*(x-y) + f^4 ,0, 2x-z2y;
  ideal M = i + maxideal(10);
  timer =0;
  i = M*M;
  timer;
  ncols(i);
  timer =0;
  i = M^2;
  ncols(i);
  timer;
  i[ncols(i)];
  vector v = [x,y-z,x2,y-x,x2yz2-y];
  ideal j = ideal(v);
@c example
@end smallexample

@c ------------------------------
@node ideal operations, ideal related functions, ideal expressions, ideal
@subsection ideal operations
@cindex ideal operations

@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
multiplication (with ideal, poly, vector, module; simplification in case of
multiplication with ideal)

@item @code{^}
exponentiation (by a non-negative integer)

@item ideal_expression @code{[} intvec_expression @code{]}
are polynomial generators of the ideal, index 1 gives the first generator.
@end table

@strong{Note:} For simplification of an ideal, see also ???
@c @ref{simplify}.

@*@strong{Example:}
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  ideal I = 0,x,0,1;
  I;
  I + 0;    // simplification
  ideal J = I,0,x,x-z;;
  J;
  I * J;   //  multiplication with simplification
  I*x;
  vector V = [x,y,z];
  print(V*I);
  ideal m = maxideal(1);
  m^2;
  ideal II = I[2..4];
  II;
@c example
@end smallexample

@c ------------------------------
@node ideal related functions, list  , ideal operations, ideal
@subsection ideal related functions
@cindex ideal related functions

@table @code
@item char_series
irreducible characteristic series (see @ref{char_series})
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item contract
contraction by an ideal (see @ref{contract})
@item diff
partial derivative (see @ref{diff})
@item degree
multiplicity, dimension and codimension of the ideal of leading terms (see @ref{degree})
@item dim
Krull dimension of basering modulo the ideal of leading terms (see @ref{dim})
@item eliminate
elimination of variables (see @ref{eliminate})
@item facstd
factorizing Groebner basis algorithm (see @ref{facstd})
@item factorize
ideal of factors of a polynomial (see @ref{factorize})
@item fglm
Groebner basis computation from a Groebner basis w.r.t.@: a different
ordering (see @ref{fglm})
@item finduni
computation of univariate polynomials lying in a zero dimensional ideal
(see @ref{finduni})
@item groebner
Groebner basis computation (a wrapper around @code{std,stdhilb,stdfglm},...)
(see @ref{groebner})
@item highcorner
computes the smallest monomial not contained in the ideal.
The ideal has to be zero-dimensional.
(see @ref{highcorner})
@item homog
homogenization with respect to a variable (see @ref{homog})
@item hilb
Hilbert series of a standard basis (see @ref{hilb})
@item indepSet
sets of independent variables of an ideal (see @ref{indepSet})
@item interred
interreduction of an ideal (see @ref{interred})
@item intersect
ideal intersection (see @ref{intersect})
@item jacob
ideal of all partial derivatives resp.@: jacobian matrix (see @ref{jacob})
@item jet
Taylor series up to a given order (see @ref{jet})
@item kbase
vector space basis of basering modulo ideal of leading terms
(see @ref{kbase})
@item koszul
Koszul matrix (see @ref{koszul})
@item lead
leading terms of a set of generators (see @ref{lead})
@item lift
lift-matrix (see @ref{lift})
@item liftstd
standard basis and transformation matrix computation (see @ref{liftstd})
@item lres
free resolution for homogeneous ideals (see @ref{lres})
@item maxideal
power of the maximal ideal at 0 (see @ref{maxideal})
@item minbase
minimal generating set of a homogeneous ideal, resp.@: module, or an ideal, resp.@: module, in a local ring
(see @ref{minbase})
@item minor
set of minors of a matrix (see @ref{minor})
@item modulo
represents
@tex
$(h1+h2)/h1 \cong h2/(h1 \cap h2)$
@end tex
@ifinfo
(h1+h2)/h1=h2/(h1 intersect h2)
@end ifinfo
(see @ref{modulo})
@item mres
minimal free resolution of an ideal resp.@: module w.r.t. a minimal set of generators of the given ideal resp.@: module
(see @ref{mres})
@item mstd
standard basis and minimal generating set of an ideal (see @ref{mstd})
@item mult
multiplicity, resp.@: degree, of the ideal of leading terms (see @ref{mult})
@item ncols
number of columns (see @ref{ncols})
@item preimage
preimage under a ring map (see @ref{preimage})
@item qhweight
quasihomogeneous weights of an ideal (see @ref{qhweight})
@item quotient
ideal quotient (see @ref{quotient})
@item reduce
normalform with respect to a standard basis (see @ref{reduce})
@item res
free resolution of an ideal resp.@: module but not changing the given ideal resp.@: module
(see @ref{res})
@item simplify
simplify a set of polynomials (see @ref{simplify})
@item size
number of non-zero generators (see @ref{size})
@item sortvec
permutation for sorting ideals resp@:. modules (see @ref{sortvec})
@item sres
free resolution of a standard basis (see @ref{sres})
@item std
standard basis computation (see @ref{std})
@item stdfglm
standard basis computation with fglm technique (see @ref{stdfglm})
@item stdhilb
Hilbert driven standard basis computation (see @ref{stdhilb}
@item subst
substitute a ring variable (see @ref{subst})
@item syz
computation of the first syzygy module (see @ref{syz})
@item vdim
vector space dimension of basering modulo ideal of leading terms
(see @ref{vdim})
@item weight
optimal weights (see @ref{weight})
@end table








@c ---------------------------------------
@node list, map,  ideal, Data types
@c link, Data types
@section list
@cindex list

Lists are arrays whose elements can be of any type (including ring and
qring). If one element belongs to a ring the whole list belongs to that
ring. This applies also to the special list @code{#}. The expression
@code{list()} is the empty list.

Note that a list stores the objects itself and not the names.  Hence, if
@code{L} is a list, @code{L[1]} for example has no name.  A name, say
@code{R}, can be created for @code{L[1]} by @code{def R=L[1];}. To store
also the name of an object, say @code{r}, it can be added to the list
with @code{nameof(r);}. Rings and qrings may be objects of a list.

@strong{Note}: Unlike other assignments a ring as an element of a list
is not a copy but another reference to the same ring.

@menu
* list declarations::
* list expressions::
* list operations::
* list related functions::
@end menu

@c ------------------------------
@node list declarations, list expressions, list, list
@subsection list declarations
@cindex list declarations

@table @strong
@item Syntax:
@code{list} name @code{=} expression_list@code{;}
@*@code{list} name @code{=} list_expression@code{;}

@item Purpose:
defines a list (of objects of possibly different types).

@item Default:
empty list

@item Example:
@smallexample
@c example
  list l=1,"str";
  l[1];
  l[2];
  ring r;
  listvar(r);
  ideal i = x^2, y^2 + z^3;
  l[3] = i;
  l;
  listvar(r);     // the list l belongs now to the ring r
@c example
@end smallexample
@end table

@c ------------------------------
@node list expressions, list operations, list declarations, list
@subsection list expressions
@cindex list expressions

A list expression is:
@enumerate
@item
the empty list @code{list()}
@item
an identifier of type list
@item
a function returning list
@item
list expressions combined by the arithmetic operation @code{+}
@item
a type cast to list
@end enumerate

@c ref
See @ref{Type conversion and casting}.
@c ref

@*@strong{Example:}
@smallexample
@c example
  list l = "hello",1;
  l;
  l = list();
  l;
  ring r =0,x,dp;
  factorize((x+1)^2);
  list(1,2,3);
@c example
@end smallexample

@c ------------------------------
@node list operations, list related functions, list expressions, list
@subsection list operations
@cindex list operations

@table @asis
@item @code{+}
concatenation
@item @code{delete}
deletes one element from list, returns new list
@item @code{insert}
inserts or appends a new element to list, returns a new list
@item list_expression @code{[} int_expression @code{]}
is a list entry; the index 1 gives the first element.
@end table

@*@strong{Example:}
@smallexample
@c example
  list l1 = 1,"hello",list(-1,1);
  list l2 = list(1,2,3);
  l1 + l2;          // one new list
  list l3 =_;
  l1,l2;            // two lists
  l2[2];
@c example
@end smallexample

@c ------------------------------
@node list related functions,  , list operations, list
@subsection list related functions
@cindex list related functions

@table @code
@item bareiss
returns a list of a matrix (lower triangular) and
of an intvec (permutations of columns, see @ref{bareiss})
@item betti
Betti numbers of a resolution (see @ref{betti})
@item delete
deletes an element from a list (see @ref{delete})
@item facstd
factorizing Groebner basis algorithm (see @ref{facstd})
@item factorize
list of factors of a polynomial (see @ref{factorize})
@item insert
inserts or appends a new element to a list (see @ref{insert})
@item lres
free resolution (see @ref{lres})
@item minres
minimize a free resolution (see @ref{minres})
@item mres
minimal free resolution of an ideal, resp.@: module w.r.t. 
a minimal set of generators of the first module (see @ref{mres})
@item names
list of all userdefined variable names (see @ref{names})
@item res
free resolution of an ideal, resp.@: module (see @ref{res})
@item size
number of entries (see @ref{size})
@item sres
free resolution of an ideal, resp.@: module, given by a standard base (see @ref{sres})
@end table


@c ---------------------------------------
@node map, module, list,  Data types
@section map
@cindex map

Maps are ring maps from a preimage ring into the basering.

@strong{Note:}
@itemize @bullet
@item
the target of a map is @strong{ALWAYS} the actual basering
@item
the preimage ring is stored "by name", that means, maps can only be
used in such contexts, where the name of the preimage ring can be
resolved (i.e., there might be problems for rings/maps defined in
subprocedures). See also @ref{Identifier resolution}, @ref{Names in
procedures}.
@end itemize

Maps between rings with different coefficient fields are
possible and listed below.

Canonically realized are
@itemize @bullet
@item
@tex
$Q \rightarrow  Q(a, \ldots)$
@end tex
@ifinfo
Q -> Q(a,..)
@end ifinfo

@item
@tex
$Q \rightarrow R$
@end tex
@ifinfo
Q -> R
@end ifinfo

@item
@tex
$Q \rightarrow  C$
@end tex
@ifinfo
Q -> C
@end ifinfo

@item
@tex
$Z/p \rightarrow  (Z/p)(a, \ldots)$
@end tex
@ifinfo
Z/p ->(Z/p)(a,...)
@end ifinfo

@item
@tex
$Z/p \rightarrow  GF(p^n)$
@end tex
@ifinfo
Z/p -> GF(p^n)
@end ifinfo

@item
@tex
$Z/p \rightarrow  R$
@end tex
@ifinfo
Z/p -> R
@end ifinfo

@item
@tex
$R \rightarrow C$
@end tex
@ifinfo
R -> C
@end ifinfo
@end itemize

Possible are furthermore
@itemize @bullet
@item
@tex
% This is quite a hack, but for now it works.
$Z/p \rightarrow Q,
\quad
[i]_p \mapsto i \in [-p/2, \, p/2]
\subseteq Z$
@end tex
@ifinfo
Z/p -> Q : [i]_p -> i in [-p/2, p/2] in Z
@end ifinfo
@item
@tex
$Z/p \rightarrow Z/p^\prime,
\quad
[i]_p \mapsto i \in [-p/2, \, p/2] \subseteq Z, \;
i \mapsto [i]_{p^\prime} \in Z/p^\prime$
@end tex
@ifinfo
Z/p -> Z/p' : [i]_p in Z/p -> i in [-p/2,p/2] in Z, i -> [i]_p' in Z/p'
@end ifinfo
@item
@tex
$C \rightarrow R, \quad$ the real part
@end tex
@ifinfo
C -> R : the real part
@end ifinfo
@end itemize

Finally, in Singular we allow the mapping from rings
with coefficient field Q to rings whose ground fields 
have finite characteristic:

@itemize @bullet
@item
@tex
$Q \rightarrow Z/p$
@end tex
@ifinfo
Q -> Z/p
@end ifinfo

@item
@tex
$Q \rightarrow (Z/p)(a, \ldots)$
@end tex
@ifinfo
Q -> (Z/p)(a,..)
@end ifinfo
@end itemize
In these cases the denominator and the numerator 
of a number are mapped separately by the usual
map from Z to Z/p, and the image of the number 
is built again afterwards by division. It is thus
not allowed to map numbers whose denominator is 
divisible by the characteristic of the target 
ground field, or objects containing such numbers. 
We, therefore, strongly recommend using such 
maps only to map objects with integer coefficients. 


@menu
* map declarations::
* map expressions::
* map operations::
* fetch::
* imap::
* subst::
@end menu
@iftex
See @ref{imap}; @ref{fetch}; @ref{subst}.
@end iftex

@c ------------------------------
@node map declarations, map expressions, map, map
@subsection map declarations
@cindex map declarations

@table @strong
@item Syntax:
@code{map} name @code{=} preimage_ring_name @code{,} ideal_expression @code{;}
@*@code{map} name @code{=} preimage_ring_name @code{,} list_of_poly_and_ideal_expressions @code{;}
@*@code{map} name @code{=} map_expression @code{;}

@item Purpose:
defines a ring map from preimage_ring to basering.
@* Maps the variables of the preimage ring to the generators of the ideal.
If the ideal contains less elements than variables in the
preimage_ring the remaining variables are mapped to 0, if the ideal contains
more elements these are ignored.
The image ring is always the actual basering.
For the mapping of coefficients from different fields see @ref{map}.

@item Default:
none

@item Note:
There are standard mappings for maps which are close to the identity
map: @code{fetch} and @code{imap}.

The name of a map serves as the function which maps objects from the
preimage_ring into the basering.  These objects must be defined
by names (no evaluation in the preimage ring is possible).

@item Example:
@smallexample
@c example
  ring r1=32003,(x,y,z),dp;
  ideal i=x,y,z;
  ring r2=32003,(a,b),dp;
  map f=r1,a,b,a+b;
  // maps from r1 to r2,
  // x -> a
  // y -> b
  // z -> a+b
  f(i);
  // operations like f(i[1]) or f(i*i) are not allowed
  ideal i=f(i);
  // objects in different rings may have the same name
  map g   = r2,a2,b2;
  map phi = g(f);
  // composition of map f and g
  // maps from r1 to r2,
  // x -> a2
  // y -> b2
  // z -> a2+b2
  phi(i);
@c example
@end smallexample
@end table

@c ref
See @ref{map}; @ref{ideal expressions}; @ref{ring};
@ref{imap}; @ref{fetch}.
@c ref

@c ------------------------------
@node map expressions, map operations, map declarations, map
@subsection map expressions
@cindex map expressions

A map expression is:
@enumerate
@item
an identifier of type map
@item
a function returning map
@item
map expressions combined by composition using parentheses (@code{(}, @code{)})
@end enumerate

@c ------------------------------
@node map operations,  , map expressions, map
@subsection map operations

@cindex map operations

@table @asis
@item @code{( )}
composition of maps. If, for example, @code{f} and @code{g} are maps,
then @code{f(g)} is a map expression giving the composition of @code{f}
and @code{g}.

@item map_expression @code{[} int_expressions @code{]}
is a map entry (the image of the corresponding variable)
@end table

@*@strong{Example:}
@smallexample
@c example
  ring r=0,(x,y),dp;
  map f=r,y,x;    // the map f permutes the variables
  f;
  poly p=x+2y3;
  f(p);
  map g=f(f);    // the map g defined as  f^2 is the identity
  g;
  g(p) == p;
@c example
@end smallexample





@c ---------------------------------------
@node module, map, poly,  Data types
@section module
@cindex module

Modules are submodules of a free module over the basering with basis
@code{gen(1)}, @code{gen(2)}, @dots{} .
They are represented by lists of vectors which generate the submodule.
Like vectors they
can only be defined or accessed with respect to a basering.
If @math{M} is a submodule of
@ifinfo
R^n,
@end ifinfo
@tex
$R^n$,
@end tex
@math{R} the basering, generated by vectors
@ifinfo
v_1, @dots{}, v_k, then v_1, @dots{}, v_k
@end ifinfo
@tex
$v_1, \ldots, v_k$, then $v_1, \ldots, v_k$
@end tex
may be considered as the generators of relations of
@ifinfo
R^n/M
@end ifinfo
@tex
$R^n/M$
@end tex
between the canonical generators @code{gen(1)},@dots{},@code{gen(n)}.
Hence any finitely generated @math{R}-module can be represented in @sc{Singular}
by its module of relations. The assignments
@code{module M=v1,...,vk; matrix A=M;}
create the presentation matrix of size
@ifinfo
n x k
@end ifinfo
@tex
n$\times$k
@end tex
for
@ifinfo
R^n/M,
@end ifinfo
@tex
R$^n$/M,
@end tex
i.e., the columns of A are the vectors
@ifinfo
v_1, @dots{}, v_k
@end ifinfo
@tex
$v_1, \ldots, v_k$
@end tex
which generate M (cf. @ref{Representation of mathematical objects}).

@menu
* module declarations::
* module expressions::
* module operations::
* module related functions::
@end menu

@c ------------------------------
@node module declarations, module expressions, module, module
@subsection module declarations
@cindex module declarations

@table @strong
@item Syntax:
@code{module} name @code{=} list_of_vector_expressions which are interpreted as
left generators of  the module. For two-sided modules see @ref{twostd}. 

 @code{;}
@*@code{module} name @code{=} module_expression @code{;}

@item Purpose:
defines a left  module.

@item Default:
[0]

@item Example:
@smallexample
@c example
  ring r=0,(x,y,z),(c,dp);
  vector s1 = [x2,y3,z];
  vector s2 = [xy,1,0];
  vector s3 = [0,x2-y2,z];
  poly   f  = xyz;
  module m = s1, s2-s1,f*(s3-s1);
  m;
  // show m in matrix format (columns generate m)
  print(m);
@c example
@end smallexample
@end table

@c ------------------------------
@node module expressions, module operations, module declarations, module
@subsection module expressions
@cindex module expressions

A module expression is:
@enumerate
@item
an identifier of type module
@item
a function returning module
@item
module expressions combined by the arithmetic operation @code{+}
@item
multiplication of a module expression with an ideal or a poly expression: @code{*}
@item
a type cast to module
@end enumerate

@c ref
See
@ref{ideal};
@ref{poly};
@ref{Type conversion and casting};
@ref{vector}.
@c ref

@c @*@strong{Example:}
@c @example
@c @c example
@c @c example
@c @end example

@c ------------------------------
@node module operations, module related functions, module expressions, module
@subsection module operations
@cindex module operations

@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
multiplication with ideal or poly, but not `module` * `module`

@item module_expression @code{[} int_expression @code{,} int_expression @code{]}
is a module entry, where the first index indicates the row and
the second the column

@item module_expressions @code{[} int_expression @code{]}
is a vector, where the index indicates the column
@end table

@*@strong{Example:}
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  module m=[x,y],[0,0,z];
  print(m*(x+y));
@c example
@end smallexample

@c ------------------------------
@node module related functions, poly, module operations, module
@subsection module related functions
@cindex module related functions

@table @code
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item degree
multiplicity, dimension and codimension of the module of leading terms (see @ref{degree})
@item diff
partial derivative (see @ref{diff})
@item dim
Krull dimension of free module over the basering modulo the module of leading terms (see @ref{dim})
@item eliminate
elimination of variables (see @ref{eliminate})
@item freemodule
the free module of given rank (see @ref{freemodule})
@item groebner
Groebner basis computation (a wrapper around @code{std,stdhilb,stdfglm},...)
(see @ref{groebner})
@item hilb
Hilbert function of a standard basis (see @ref{hilb})
@item homog
homogenization with respect to a variable (see @ref{homog})
@item interred
interreduction of a module (see @ref{interred})
@item intersect
module intersection (see @ref{intersect})
@item jet
Taylor series up to a given order (see @ref{jet})
@item kbase
vector space basis of free module over the basering modulo the module of
leading terms (see @ref{kbase})
@item lead
initial module (see @ref{lead})
@item lift
lift-matrix (see @ref{lift})
@item liftstd
standard basis and transformation matrix computation (see @ref{liftstd})
@item lres
free resolution (see @ref{lres})
@item minbase
minimal generating set of a homogeneous ideal, resp.@: module, or an ideal, resp.@: module,
over a local ring
@item modulo
represents
@tex
$(h1+h2)/h1=h2/(h1 \cap h2)$
@end tex
@ifinfo
(h1+h2)/h1=h2/(h1 intersect h2)
@end ifinfo
(see @ref{modulo})
@item mres
minimal free resolution of an ideal resp.@: module w.r.t. a minimal set of generators of the given module
(see @ref{mres})
@item mult
multiplicity, resp.@: degree, of the module of leading terms (see @ref{mult})
@item ncols
number of columns (see @ref{ncols})
@item nrows
number of rows (see @ref{nrows})
@item print
nice print format (see @ref{print})
@item prune
minimize the embedding into a free module (see @ref{prune})
@item qhweight
quasihomogeneous weights of an ideal, resp.@: module (see @ref{qhweight})
@item quotient
module quotient (see @ref{quotient})
@item reduce
normalform with respect to a standard basis (see @ref{reduce})
@item res
free resolution of an ideal, resp.@: module, but not changing the given ideal, resp.@: module
(see @ref{res})
@item simplify
simplify a set of vectors (see @ref{simplify})
@item size
number of non-zero generators (see @ref{size})
@item sortvec
permutation for sorting ideals/modules (see @ref{sortvec})
@item sres
free resolution of a standard basis (see @ref{sres})
@item std
standard basis computation (see @ref{std}, @ref{liftstd})
@item subst
substitute a ring variable (see @ref{subst})
@item syz
computation of the first syzygy module (see @ref{syz})
@item vdim
vector space dimension of free module over the basering modulo module
of leading terms (see @ref{vdim})
@item weight
"optimal" weights (see @ref{weight})
@end table




@c ---------------------------------------
@ifset namespaces
@node poly,qring, module, Data types
@end ifset
@ifclear namespaces
@node poly, proc, number, Data types
@end ifclear
@section poly
@cindex poly

Polynomials are the basic data for all main algorithms in
@code{@sc{Singular}}. They consist of finitely many terms
(coefficient*power product) which are combined by the usual polynomial
operations (see @ref{poly expressions}). Polynomials can only be defined
or accessed with respect to a basering which determines the coefficient
type, the names of the indeterminants and the monomial ordering.

@smallexample
@c example
  ring r=32003,(x,y,z),dp;
  poly f=x3+y5+z2;
@c example
@end smallexample

@menu
* poly declarations::
* poly expressions::
* poly operations::
* poly related functions::
@end menu

@c ------------------------------
@node poly declarations, poly expressions, poly, poly
@subsection poly declarations
@cindex poly declarations

@table @strong
@item Syntax:
@code{poly} name @code{=} poly_expression @code{;}

@item Purpose:
defines a polynomial.

@item Default:
0

@item Example:
@smallexample
@c example
  ring r = 32003,(x,y,z),dp;
  poly s1  = x3y2+151x5y+186xy6+169y9;
  poly s2  = 1*x^2*y^2*z^2+3z8;
  poly s3  = 5/4x4y2+4/5*x*y^5+2x2y2z3+y7+11x10;
  int a,b,c,t=37,5,4,1;
  poly f=3*x^a+x*y^(b+c)+t*x^a*y^b*z^c;
  f;
  short = 0;
  f;
@c example
@end smallexample
@end table
@c ref
@ref{short}
@c ref



@c ----------------------------
@node poly expressions, poly operations, poly declarations, poly
@subsection poly expressions
@cindex poly expressions

A poly expression is (optional parts in square brackets):
@enumerate
@item
a monomial (there are NO spaces allowed inside a monomial)
@smallexample
  [coefficient] ring_variable [ exponent] [ring_variable [exponent] @dots{}]
@end smallexample
monomials which contain an indexed ring variable
must be built from @code{ring_variable} and @code{coefficient}
with the operations @code{*} and @code{^}
@item
an identifier of type poly
@item
a function returning poly
@item
poly expressions combined by the arithmetic operations
@code{+}, @code{-}, @code{*}, @code{/}, or @code{^}
@item
an int expression (see @ref{Type conversion and casting})
@item
a type cast to poly
@end enumerate

@*@strong{Example:}
@smallexample
2x, x3, 2x2y3, xyz, 2xy2; //  are monomials
2*x, x^3, 2*x^2*y^3, x*y*z, 2*x*y^2; // are poly expressions
2*x(1); // is a valid poly expression, but not 2x(1) (a syntax error)
2*x^3;  // is a valid poly expression equal to 2x3 (a valid monomial)
        // but not equal to 2x^3 which will be interpreted as (2x)^3
        // since 2x is a monomial
@c example
  ring r=0,(x,y),dp;
  poly f = 10x2y3 +2x2y2-2xy+y -x+2;
  lead(f);
  leadmonom(f);
  simplify(f,1);     // normalize leading coefficient
  poly g = 1/2x2 + 1/3y;
  cleardenom(g);
  int i = 102;
  poly(i);
  typeof(_);
@c example
@end smallexample

@*@strong{Remark:} in the non-commutative case: 
y*x  is valid poly expression, but not equal to yx which will be
interpreted as commutative expression. 
 
@*@strong{Example:}
@smallexample
@c example
ring r=0,(x,y),dp;
system("PLURAL",1,1);
          // it is a Weyl algebra 
r;
yx;      // not correct input
y*x;     // correct input

@c example
@end smallexample 

@c ref
See @ref{ring}; @ref{Type conversion and casting}.
@c ref

@c ------------------------------
@node poly operations, poly related functions, poly expressions, poly
@subsection poly operations
@cindex poly operations

@table @asis
@item @code{+}
addition

@item @code{-}
negation or subtraction

@item @code{*}
multiplication

@item @code{/}
division by a monomial, non divisible terms yield 0

@item @code{^}, @code{**}
power by an integer

@item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
comparison (w.r.t. monomial ordering)

@item poly_expression @code{[} intvec_expression @code{]}
the monomial at the indicated place w.r.t.@: the monomial ordering
@end table

@*@strong{Example:}
@smallexample
@c example
  ring R=0,(x,y),dp;
  poly f = x3y2 + 2x2y2 + xy - x + y + 1;
  f;
  f + x5 + 2;
  f * x2;
  (x+y)/x;
  f/3x2;
  x5 > f;
  x<=y;
  x>y;
  ring r=0,(x,y),ds;
  poly f = fetch(R,f);
  f;
  x5 > f;
  f[2..4];
  size(f);
  f[size(f)+1]; f[-1];    // monomials out of range are 0
  intvec v = 6,1,3;
  f[v];          // the polynom built from the 1st, 3rd and 6th monomial of f
@c example
@end smallexample

@c ------------------------------
@node poly related functions, qring, poly operations, poly
@subsection poly related functions
@cindex poly related functions

@table @code
@item cleardenom
cancel denominators of numbers in poly and divide it by its content
(see @ref{cleardenom})
@item coef
matrix of coefficients and monomials (see @ref{coef})
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item deg
degree (see @ref{deg})
@item det
determinant (see @ref{det})
@item diff
partial derivative (see @ref{diff})
@item extgcd
Bezout representation of gcd (see @ref{extgcd})
@item factorize
factorize polynomial (see @ref{factorize})
@item finduni
find univariate polynomials in a zero-dimensional ideal (see @ref{finduni})
@item gcd
greatest common divisor (see @ref{gcd})
@item homog
homogenization (see @ref{homog})
@item jacob
ideal, resp.@: matrix, of all partial derivatives (see @ref{jacob})
@item lead
leading term (see @ref{lead})
@item leadcoef
coefficient of the leading term (see @ref{leadcoef})
@item leadexp
the exponent vector of the leading monomial (see @ref{leadexp})
@item leadmonom
leading monomial (see @ref{leadmonom})
@item jet
monomials with degree smaller k+1 (see @ref{jet})
@item ord
degree of the leading monomial (see @ref{ord})
@item qhweight
quasihomogeneous weights (see @ref{qhweight})
@item reduce
normal form with respect to a standard base (see @ref{reduce})
@item rvar
test for ring variable (see @ref{rvar})
@item simplify
normalize a polynomial (see @ref{simplify})
@item size
number of monomials (see @ref{size})
@item subst
substitute a ring variable (see @ref{subst})
@item trace
trace of a matrix (see @ref{trace})
@item var
the indicated variable of the ring (see @ref{var})
@item varstr
variable in string form (see @ref{varstr})
@end table

@c @*@strong{Example:}
@c @example
@c @end example






@c ---------------------------------------
@node qring, resolution, poly, Data types
@section qring
@cindex qring

@sc{Plural} offers the opportunity to calculate in 
factor rings  modulo a two-sided ideal.  The ideal has to be given
as a standard basis.  For a detailed description of the concept
of rings and quotient rings see ???
@c @ref{Rings and orderings}.

@menu
* qring declaration::
@end menu

@c ---------------------------------------
@node qring declaration,  , qring, qring
@subsection qring declaration
@cindex qring declaration

@c ------------------------------------------------------------
@c   This piece of text exists also in the file general.doc,
@c   chapter "General syntax of a ring declaration".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@table @strong
@item Syntax:
@code{qring} name @code{=} ideal_expression @code{;}
@item Default:
none
@item Purpose:
declares a quotient ring as the basering modulo two-sided ideal_expressions. Sets
it as current basering.
@item Example:
@smallexample
@c example 
ring r=0,(x,y,z,t),dp;
system("PLURAL",-1,0);
option(redSB);
option(redTail);
ideal i=x^2,y^2,z^2,t^2;
qring q=system("twostd",i);
q;
// this is an exterior algebra 
@c example
@end smallexample
@end table

@c ---------------------------------------
@node resolution, ring, qring, Data types
@section resolution
@cindex resolution

The resolution type is intended as an intermediate representation which
internally retains additional information obtained during computation of
resolutions. It furthermore enables the use of partial results to
compute, for example, Betti numbers or minimal resolutions. Like ideals
and modules, a resolution can only be defined w.r.t.@: a basering.

@strong{Note:}
to access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time,
(resp.@: an access directly with the brackets @code{[ , ]} causes
implicitly a cast to a list).

@menu
* resolution declarations::
* resolution expressions::
* resolution related functions::
@end menu

@c ---------------------------------------
@node resolution declarations, resolution expressions, resolution, resolution
@subsection resolution declarations
@cindex resolution declarations

@table @strong
@item Syntax:
@code{resolution} name @code{=} resolution_expression @code{;}

@item Purpose:
defines a resolution.

@item Default:
none

@item Example:
@smallexample
@c example
  ring R;
  ideal i=z2,x;
  resolution re=res(i,0);
  re;
  betti(re);
  list l = re;
  l;
@c example
@end smallexample
@end table

@c ------------------------------
@node resolution expressions, resolution related functions, resolution declarations, resolution
@subsection resolution expressions
@cindex resolution expressions

A resolution expression is:
@enumerate
@item
an identifier of type resolution
@item
a function returning a resolution
@item
a type cast to resolution from a list of ideals, resp.@: modules..
@end enumerate

@c ref
See @ref{Type conversion and casting}.
@c ref

@c ------------------------------
@node resolution related functions,  , resolution expressions, resolution
@subsection resolution related functions
@cindex resolution related functions

@table @code
@item betti
Betti numbers of a resolution (see @ref{betti})
@item lres
free resolution (see @ref{lres})
@item minres
minimize a free resolution (see @ref{minres})
@item mres
minimal free resolution of an ideal, resp.@: module w.r.t. a minimal set of generators of 
the given ideal, resp.@: module (see @ref{mres})
@item res
free resolution of an ideal, resp.@: module, but not changing the
given ideal, resp.@: module (see @ref{res})
@item sres
free resolution of a standard basis (see @ref{sres})
@end table

@c @*@strong{Example:}
@c @example
@c @end example

@c ---------------------------------------
@node ring, string, resolution, Data types
@section ring
@cindex ring

Rings are used to describe properties of polynomials, ideals etc.
Almost all computations in @sc{Singular} require a basering.
For a detailed description of the concept of rings see
@ref{Rings and orderings}.

@menu
* ring declarations::
* ring related functions::
* ring operations::
@end menu

@c ---------------------------------------
@node ring declarations, ring related functions, ring, ring
@subsection ring declarations
@cindex ring declarations

@table @strong
@item Syntax:
@code{ring} name @code{= (} coefficient_field @code{),}
  @code{(} names_of_ring_variables @code{),}
  @code{(} ordering @code{);}
@item Default:
@code{32003,(x,y,z),(dp,C);}
@item Purpose:
declares a ring and sets it as the actual basering.
@end table

The coefficient_field is given by one of the following:
@enumerate
@item
a non-negative int_expression less or equal 32003.
@item
an expression_list of an int_expression and one or more names.
@item
the name @code{real}
@item
an expression_list of the name @code{real} and an  int_expression.
@item
an expression_list of the name @code{complex}, an optional int_expression
and a name.
@end enumerate

For the definition of the 'coefficient_field', see @ref{Rings and orderings}.

'names_of_ring_variables' must be a list of names or indexed names.

'ordering' is a list of block orderings where each block ordering is either
@enumerate
@item
@code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, or @code{Ds}
optionally followed by a size parameter in parentheses.

@item
@code{wp}, @code{Wp}, @code{ws}, @code{Ws}, or @code{a} followed by a
weight vector given as an intvec_expression in parentheses.

@item
@code{M} followed by an intmat_expression in parentheses.

@item
@code{c} or @code{C}.
@end enumerate

For the definition of the orderings, see @ref{Term orderings},
@ref{Monomial orderings}.

If one of coefficient_field, names_of_ring_variables, and ordering
consists of only one entry, the parentheses around this entry may be
omitted.

@c ---------------------------------------
@node ring related functions, ring operations, ring declarations, ring
@subsection ring related functions
@cindex ring related functions

@table @code
@item charstr
description of the coefficient field of a ring (see @ref{charstr})
@item keepring
move ring to next upper level (see @ref{keepring})
@item npars
number of ring parameters (see @ref{npars})
@item nvars
number of ring variables (see @ref{nvars})
@item ordstr
monomial ordering of a ring (see @ref{ordstr})
@item parstr
names of all ring parameters or the
name of the n-th ring parameter (see @ref{parstr})
@item qring
quotient ring (see @ref{qring})
@item setring
set a new basering (see @ref{setring})
@item varstr
names of all ring variables or the
name of the n-th ring variable (see @ref{varstr})
@end table

@c ---------------------------------------
@node ring operations, Data types , ring related functions, ring
@subsection ring operations
@cindex ring operations
@table @asis
@item @code{+}
construct a new ring @math{k[X,Y]} from @math{k_1[X]}  and @math{k_2[Y]}.
@end table

Concerning the ground fields @math{k_1} and @math{k_2} take the
following guide lines into consideration:
@itemize @bullet
@item Neither @math{k_1} nor @math{k_2} may be @math{R} or @math{C}.
@item If the characteristic of @math{k_1} and @math{k_2} differs, then one of them must be @math{Q}.
@item At most one of @math{k_1} and @math{k_2} may be have parameters.
@item If one of @math{k_1} and @math{k_2} is an algebraic extension of @math{Z/p} it may not be defined by a @code{charstr} of type @code{(p^n,a)}. 
@end itemize


@strong{Example:}
@smallexample
@c example
  ring R1=0,(x,y),dp;
  ring R2=32003,(a,b),dp;
  def R=R1+R2;
  R;
@c example
@end smallexample

@c ref
@ref{ring_lib}
@c ref

@c // This is some quasi--commutative algebra@end table

@c @*@strong{Example:}
@c @example
@c @end example
