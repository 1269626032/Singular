@comment -*-texinfo-*-
@comment $Id: plutypes.doc,v 1.6 2003-03-06 11:42:58 levandov Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plutypes.info

@node Top, Data types@value{PSUFFIX}, (dir), (dir)
@menu
* Data types@value{PSUFFIX}::
@end menu

@node Data types@value{PSUFFIX},  , Top, Top
@chapter Data types@value{PSUFFIX}
%**end
@end ignore

@cindex expression list
This chapter explains all data types of @sc{Plural} in
alphabetical order. For every type, there is a description of the
declaration syntax as well as information about how to build expressions
of certain types.

The term expression list in @sc{Plural} refers to any comma separated
list of expressions.

For the general syntax of a declaration see 
@c @ref{General command syntax}.

@menu
* ideal@value{PSUFFIX}::
* module@value{PSUFFIX}::
* poly@value{PSUFFIX}::
* qring@value{PSUFFIX}::
* resolution@value{PSUFFIX}::
* ring@value{PSUFFIX}::
@ifset namespaces
@end ifset
@end menu


@c ---------------------------------------

@node ideal@value{PSUFFIX}, module@value{PSUFFIX}, Data types@value{PSUFFIX}, Data types@value{PSUFFIX}
@section ideal@value{PSUFFIX}
@c @cindex ideal
@cindex  untyped definitions 

Under an ideal @sc{Plural} understand a @strong{left} ideal. Ideals are represented as lists of polynomials which are interpreted as
left generators of  the ideal. For the operations with two-sided ideals see @ref{twostd}. 


Like polynomials ideals
can only be defined or accessed with respect to a basering.

@strong{Note:} @code{size} counts only the non-zero generators of an ideal
whereas @code{ncols} counts all generators. 


@menu
* ideal declarations@value{PSUFFIX}::
* ideal expressions@value{PSUFFIX}::
* ideal operations@value{PSUFFIX}::
* ideal related functions@value{PSUFFIX}::
@end menu


@c ---------------------------------------

@node ideal declarations@value{PSUFFIX}, ideal expressions@value{PSUFFIX}, ideal@value{PSUFFIX}, ideal@value{PSUFFIX}
@subsection ideal declarations@value{PSUFFIX}
@cindex ideal declarations@value{PSUFFIX}

@table @strong
@item Syntax:
@code{ideal} name @code{=} list_of_poly_and_ideal_expressions @code{;}
@*@code{ideal} name @code{=} ideal_expression @code{;}

@item Purpose:
defines a left ideal.

@item Default:
0

@item Example:
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  system("PLURAL",-1,0);
  poly s1 = x2;
  poly s2 = y3;
  poly s3 = z;
  ideal i =  s1, s2-s1, 0,s2*s3, s3^4;
  i;
  size(i);
  ncols(i);
@c example
@end smallexample
@end table



@c ------------------------------

@node ideal expressions@value{PSUFFIX}, ideal operations@value{PSUFFIX}, ideal declarations@value{PSUFFIX}, ideal@value{PSUFFIX}
@subsection ideal expressions@value{PSUFFIX}
@cindex ideal expressions@value{PSUFFIX}

An ideal expression is:
@enumerate
@item
an identifier of type ideal
@item
a function returning ideal
@item
ideal expressions combined by the arithmetic operations
@code{+} or @code{*}
@item
a power of an ideal expression (operator @code{^} or @code{**})
@*Note that the computation of the product @code{i*i} involves
all products of generators of @code{i} while @code{i^2} involves
only the different ones, and is therefore faster.
@item
a type cast to ideal
@end enumerate

@*@strong{Example:}
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  system ("PLURAL",-1,0); 
  ideal m = maxideal(1);
  m;
  poly f = x2;
  poly g = y3;
  ideal i = x*y*z , f-g, g*(x-y) + f^4 ,0, 2x-z2y;
  ideal M = i + maxideal(10);
  timer =0;
  i = M*M;
  timer;
  ncols(i);
  timer =0;
  i = M^2;
  ncols(i);
  timer;
  i[ncols(i)];
  vector v = [x,y-z,x2,y-x,x2yz2-y];
  ideal j = ideal(v);
@c example
@end smallexample


@c ------------------------------

@node ideal operations@value{PSUFFIX}, ideal related functions@value{PSUFFIX}, ideal expressions@value{PSUFFIX}, ideal@value{PSUFFIX}
@subsection ideal operations@value{PSUFFIX}
@cindex ideal operations@value{PSUFFIX}

@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
multiplication (with ideal, poly, vector, module; simplification in case of
multiplication with ideal)

@item @code{^}
exponentiation (by a non-negative integer)

@item ideal_expression @code{[} intvec_expression @code{]}
are polynomial generators of the ideal, index 1 gives the first
generator.

@ifset singularmanual
@strong{Note:} For simplification of an ideal, see also
 @ref{simplify} (in @sc{Singular}) .
@end ifset 

@ifclear singularmanual
@strong{Note:} For simplification of an ideal, see also @emph{simplify} in @sc{Singular}.
@end ifclear  



@*@strong{Example:}
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  matrix D[3][3];
  D[1,2]=-z;
  D[1,3]=y;
  D[2,3]=x;
  system("PLURAL",1,D); 
  ideal I = 0,x,0,1;
  I;
  I + 0;    // simplification
  ideal J = I,0,x,x-z;
  J;
  I * J;   //  multiplication with simplification
  I*x;
  vector V = [x,y,z];
  print(V*I);
  ideal m = maxideal(1);
  m^2;
  ideal II = I[2..4];
  II;
@c example
@end smallexample
@end table

@c ------------------------------

@node ideal related functions@value{PSUFFIX},  , ideal operations@value{PSUFFIX}, ideal@value{PSUFFIX}
@subsection ideal related functions@value{PSUFFIX}
@cindex ideal related functions@value{PSUFFIX}




        






@c ---------------------------------------

@node module@value{PSUFFIX}, poly@value{PSUFFIX}, ideal@value{PSUFFIX}, Data types@value{PSUFFIX}
@section module@value{PSUFFIX}
@cindex module@value{PSUFFIX}

Modules are left  submodules of a free module over the basering with basis
@code{gen(1)}, @code{gen(2)}, @dots{} .
They are represented by lists of vectors
@ifset singularmanual 
(vector data type is the same as in @sc{Singular} @pxref{vector})
@end ifset 
@ifclear singularmanual 
(vector data type is the same as in @sc{Singular})
@end ifclear 
 which generate the submodule.
Like vectors they
can only be defined or accessed with respect to a basering.

If @math{M} is a submodule of
@ifinfo
R^n,
@end ifinfo
@tex
$R^n$,
@end tex
 where @math{R} is the basering, generated by vectors
@ifinfo
v_1, @dots{}, v_k, then v_1, @dots{}, v_k
@end ifinfo
@tex
$v_1, \ldots, v_k$, then $v_1, \ldots, v_k$
@end tex
may be considered as the generators of relations of
@ifinfo
R^n/M
@end ifinfo
@tex
$R^n/M$
@end tex
between the canonical generators @code{gen(1)},@dots{},@code{gen(n)}.
Hence any finitely generated @math{R}-module can be represented in @sc{Plural}
by its module of relations. The assignments
@code{module M=v1,...,vk; matrix A=M;} 
create the presentation matrix of size
@ifinfo
n x k
@end ifinfo
@tex
n$\times$k
@end tex
 for
@ifinfo
R^n/M,
@end ifinfo
@tex
R$^n$/M,
@end tex
 i.e., the columns of A are the vectors
@ifinfo
v_1, @dots{}, v_k
@end ifinfo
@tex
$v_1, \ldots, v_k$
@end tex
which generate M 

@menu
* module declarations@value{PSUFFIX}::
* module expressions@value{PSUFFIX}::
* module operations@value{PSUFFIX}::
* module related functions@value{PSUFFIX}::
@end menu

@c ------------------------------

@node module declarations@value{PSUFFIX}, module expressions@value{PSUFFIX}, module@value{PSUFFIX}, module@value{PSUFFIX}
@subsection module declarations@value{PSUFFIX}
@cindex module declarations@value{PSUFFIX}

@table @strong
@item Syntax:
@code{module} name @code{=} list_of_vector_expressions which are interpreted as
left generators of  the module. @code{;}
@*@code{module} name @code{=} module_expression @code{;}

@item Purpose:
defines a left  module.

@item Default:
[0]

@item Example:
@smallexample
@c example
  ring r=0,(x,y,z),(c,dp);
  matrix D[3][3];
  D[1,2]=-z;
  D[1,3]=y;
  D[2,3]=x;
  system("PLURAL",1,D); 
  vector s1 = [x2,y3,z];
  vector s2 = [xy,1,0];
  vector s3 = [0,x2-y2,z];
  poly   f  = xyz;
  module m = s1, s2-s1,f*(s3-s1);
  m;
  // show m in matrix format (columns generate m)
  print(m);
@c example
@end smallexample
@end table

@c ------------------------------

@node module expressions@value{PSUFFIX}, module operations@value{PSUFFIX}, module declarations@value{PSUFFIX}, module@value{PSUFFIX}
@subsection module expressions@value{PSUFFIX}
@cindex module expressions@value{PSUFFIX}

A module expression is:
@enumerate
@item
an identifier of type module
@item
a function returning module
@item
module expressions combined by the arithmetic operation @code{+}
@item
multiplication of a module expression with an ideal or a poly expression: @code{*}
@item
a type cast to module
@end enumerate


@c @*@strong{Example:}
@c @example
@c @c example
@c @c example
@c @end example

@c ------------------------------
@node module operations@value{PSUFFIX}, module related functions@value{PSUFFIX}, module expressions@value{PSUFFIX}, module@value{PSUFFIX}
@subsection module operations@value{PSUFFIX}
@cindex module operations@value{PSUFFIX}

@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
multiplication with ideal or poly, but not `module` * `module`

@item module_expression @code{[} int_expression @code{,} int_expression @code{]}
is a module entry, where the first index indicates the row and
the
????????
@end table


@c ------------------------------
@node module related functions@value{PSUFFIX}, poly declarations@value{PSUFFIX}, module operations@value{PSUFFIX}, module@value{PSUFFIX}
@subsection module related functions@value{PSUFFIX}
@cindex module related functions@value{PSUFFIX}







@c ---------------------------------------

@ifset namespaces
@node poly@value{PSUFFIX}, qring@value{PSUFFIX}, module@value{PSUFFIX}, Data types@value{PSUFFIX}
@end ifset
@ifclear namespaces
@node poly@value{PSUFFIX}, qring@value{PSUFFIX}, module@value{PSUFFIX}, Data types@value{PSUFFIX}
@end ifclear
@section poly@value{PSUFFIX}
@cindex poly@value{PSUFFIX}

Polynomials are the basic data for all main algorithms in
@code{@sc{Plural}}. They consist of finitely many terms
(coefficient*power product) which are combined by the usual polynomial
operations 
@c (see @ref{poly expressions}).
 Polynomials can only be defined
or accessed with respect to a basering which determines the coefficient
type, the names of the indeterminants and the monomial ordering.

@smallexample
@c example
  ring r=32003,(x,y,z),dp;
  poly f=x3+y5+z2;
@c example
@end smallexample

@menu
* poly declarations@value{PSUFFIX}::
* poly expressions@value{PSUFFIX}::
* poly operations@value{PSUFFIX}::
* poly related functions@value{PSUFFIX}::
@end menu

@c ------------------------------

@node poly declarations@value{PSUFFIX}, poly expressions@value{PSUFFIX}, module related functions@value{PSUFFIX}, poly@value{PSUFFIX}
@subsection poly declarations@value{PSUFFIX}
@cindex poly declarations@value{PSUFFIX}

@table @strong
@item Syntax:
@code{poly} name @code{=} poly_expression @code{;}

@item Purpose:
defines a polynomial.

@item Default:
0 

@item Example:
@smallexample
@c example
  ring r = 32003,(x,y,z),dp;
  system("PLURAL",-1,1);  
  poly s1  = x3y2+151x5y+186xy6+169y9;
  poly s2  = 1*x^2*y^2*z^2+3z8;
  poly s3  = 5/4x4y2+4/5*x*y^5+2x2y2z3+y7+11x10;
  int a,b,c,t=37,5,4,1;
  poly f=3*x^a+x*y^(b+c)+t*x^a*y^b*z^c;
  f;
  short = 0;
  f;
@c example
@end smallexample
@end table



@c ----------------------------

@node poly expressions@value{PSUFFIX}, poly operations@value{PSUFFIX}, poly declarations@value{PSUFFIX}, poly@value{PSUFFIX}
@subsection poly expressions@value{PSUFFIX}
@cindex poly expressions@value{PSUFFIX}

A poly expression is (optional parts in square brackets):
@enumerate
@item
a monomial (there are NO spaces allowed inside a monomial)
@smallexample
  [coefficient] ring_variable [ exponent] [ring_variable [exponent] @dots{}]
@end smallexample
@c monomials which contain an indexed ring variable
@c must be built from @code{ring_variable} and @code{coefficient}
@c with the operations @code{*} and @code{^}
@item
an identifier of type poly
@item
a function returning poly
@item
poly expressions combined by the arithmetic operations
@code{+}, @code{-}, @code{*}, @code{/}, or @code{^}.
@item
a type cast to poly
@end enumerate

@*@strong{Example:}
@smallexample
2x, x3, 2x2y3, xyz, 2xy2; //  are monomials
2*x, x^3, 2*x^2*y^3, x*y*z, 2*x*y^2; // are poly expressions
2*x(1); // is a valid poly expression, but not 2x(1) (a syntax error)
2*x^3;  // is a valid poly expression equal to 2x3 (a valid monomial)
        // but not equal to 2x^3 which will be interpreted as (2x)^3
        // since 2x is a monomial
@c example
  ring r=0,(x,y),dp;
  poly f = 10x2y3 +2x2y2-2xy+y -x+2;
  lead(f);
  leadmonom(f);
  simplify(f,1);     // normalize leading coefficient
  poly g = 1/2x2 + 1/3y;
  cleardenom(g);
  int i = 102;
  poly(i);
  typeof(_);
@c example
@end smallexample

@*@strong{Remark:} In the non-commutative case see @ref{PLURAL conventions}.
 
@*@strong{Example:}
@smallexample
@c example
ring r=0,(x,y),dp;
system("PLURAL",1,1);
          // it is a Weyl algebra 
r;
yx;      // not correct input
y*x;     // correct input

@c example
@end smallexample 


@c ------------------------------

@node poly operations@value{PSUFFIX}, poly related functions@value{PSUFFIX}, poly expressions@value{PSUFFIX}, poly@value{PSUFFIX}
@subsection poly operations@value{PSUFFIX}
@cindex poly operations@value{PSUFFIX}

@table @asis
@item @code{+}
addition

@item @code{-}
negation or subtraction

@item @code{*}
multiplication

@item @code{/}
division by a monomial, non divisible terms yield 0

@item @code{^}, @code{**}
power by an integer

@item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
comparison (w.r.t. monomial ordering)

@item poly_expression @code{[} intvec_expression @code{]}
the monomial at the indicated place w.r.t.@: the monomial ordering
@end table


@c ------------------------------

@node poly related functions@value{PSUFFIX},  , poly operations@value{PSUFFIX}, poly@value{PSUFFIX}
@subsection poly related functions@value{PSUFFIX}
@cindex poly related functions@value{PSUFFIX}


@c ---------------------------------------

@node qring@value{PSUFFIX}, resolution@value{PSUFFIX}, poly@value{PSUFFIX}, Data types@value{PSUFFIX}
@section qring@value{PSUFFIX}
@cindex qring@value{PSUFFIX}

@sc{Plural} offers the opportunity to calculate in 
factor rings  modulo a two-sided ideal.  The ideal has to be given
as a standard basis.  For a detailed description of the concept
of rings and quotient rings see
@ifset singularmanual 
@ref{Rings and orderings}.
@end ifset
@ifclear singularmanual
in @sc{Singular} manual section Rings and orderings.
@end ifclear

@menu
* qring declaration@value{PSUFFIX}::
@end menu

@c ---------------------------------------

@node qring declaration@value{PSUFFIX},  , qring@value{PSUFFIX}, qring@value{PSUFFIX}
@subsection qring declaration@value{PSUFFIX}
@cindex qring declaration@value{PSUFFIX}

@c ------------------------------------------------------------
@c   This piece of text exists also in the file general.doc,
@c   chapter "General syntax of a ring declaration".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------


@c ---------------------------------------

@node resolution@value{PSUFFIX}, ring@value{PSUFFIX}, qring@value{PSUFFIX}, Data types@value{PSUFFIX}
@section resolution@value{PSUFFIX}
@cindex resolution@value{PSUFFIX}

The resolution type is intended as an intermediate representation which
internally retains additional information obtained during computation of
resolutions. It furthermore enables the use of partial results to
compute, for example, Betti numbers or minimal resolutions. Like ideals
and modules, a resolution can only be defined w.r.t.@: a basering.

@strong{Note:}
to access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time,
(resp.@: an access directly with the brackets @code{[ , ]} causes
implicitly a cast to a list).

@menu
* resolution declarations@value{PSUFFIX}::
* resolution expressions@value{PSUFFIX}::
* resolution related functions@value{PSUFFIX}::
@end menu

@c ---------------------------------------

@node resolution declarations@value{PSUFFIX}, resolution expressions@value{PSUFFIX}, resolution@value{PSUFFIX}, resolution@value{PSUFFIX}
@subsection resolution declarations@value{PSUFFIX}
@cindex resolution declarations@value{PSUFFIX}

@table @strong
@item Syntax:
@code{resolution} name @code{=} resolution_expression @code{;}

@item Purpose:
defines a resolution.

@item Default:
none

@item Example:
@smallexample
@c example
  ring R;
  ideal i=z2,x;
  resolution re=res(i,0);
  re;
  betti(re);
  list l = re;
  l;
@c example
@end smallexample
@end table

@c ------------------------------

@node resolution expressions@value{PSUFFIX}, resolution related functions@value{PSUFFIX}, resolution declarations@value{PSUFFIX}, resolution@value{PSUFFIX}
@subsection resolution expressions@value{PSUFFIX}
@cindex resolution expressions@value{PSUFFIX}

A resolution expression is:
@enumerate
@item
an identifier of type resolution
@item
a function returning a resolution
@item
a type cast to resolution from a list of ideals, resp.@: modules..
@end enumerate


@c ------------------------------

@node resolution related functions@value{PSUFFIX},  , resolution expressions@value{PSUFFIX}, resolution@value{PSUFFIX}
@subsection resolution related functions@value{PSUFFIX}
@cindex resolution related functions@value{PSUFFIX}


@c ---------------------------------------

@node ring@value{PSUFFIX},  , resolution@value{PSUFFIX}, Data types@value{PSUFFIX}
@section ring@value{PSUFFIX}
@cindex ring@value{PSUFFIX}

Rings are used to describe properties of polynomials, ideals etc.
Almost all computations in @sc{Plural} require a basering.
For a detailed description of the concept of rings see

@menu
* ring declarations@value{PSUFFIX}::
* ring related functions@value{PSUFFIX}::
* ring operations@value{PSUFFIX}::
@end menu

@c ---------------------------------------

@node ring declarations@value{PSUFFIX}, ring operations@value{PSUFFIX}, ring@value{PSUFFIX}, ring@value{PSUFFIX}
@subsection ring declarations@value{PSUFFIX}
@cindex ring declarations@value{PSUFFIX}

@table @strong
@item Syntax:
@code{ring} name @code{= (} coefficient_field @code{),}
  @code{(} names_of_ring_variables @code{),}
  @code{(} ordering @code{);}
@item Default:
@code{32003,(x,y,z),(dp,C);}
@item Purpose:
declares a ring and sets it as the actual basering.
@end table

The coefficient_field is given by one of the following:
@enumerate
@item
a non-negative int_expression less or equal 32003.
@item
an expression_list of an int_expression and one or more names.
@item
the name @code{real}
@item
an expression_list of the name @code{real} and an  int_expression.
@item
an expression_list of the name @code{complex}, an optional int_expression
and a name.
@end enumerate


'names_of_ring_variables' must be a list of names or indexed names.

'ordering' is a list of block orderings where each block ordering is either
@enumerate
@item
@code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, or @code{Ds}
optionally followed by a size parameter in parentheses.

@item
@code{wp}, @code{Wp}, @code{ws}, @code{Ws}, or @code{a} followed by a
weight vector given as an intvec_expression in parentheses.

@item
@code{M} followed by an intmat_expression in parentheses.

@item
@code{c} or @code{C}.
@end enumerate


If one of coefficient_field, names_of_ring_variables, and ordering
consists of only one entry, the parentheses around this entry may be
omitted.



@c ---------------------------------------

@node ring operations@value{PSUFFIX}, ring related functions@value{PSUFFIX}, ring declarations@value{PSUFFIX}, ring@value{PSUFFIX}
@subsection ring operations@value{PSUFFIX}
@cindex ring operations@value{PSUFFIX}
@table @asis
@item @code{+}
construct a new ring @math{k[X,Y]} from @math{k_1[X]}  and @math{k_2[Y]}.
@end table

Concerning the ground fields @math{k_1} and @math{k_2} take the
following guide lines into consideration:
@itemize @bullet
@item Neither @math{k_1} nor @math{k_2} may be @math{R} or @math{C}.
@item If the characteristic of @math{k_1} and @math{k_2} differs, then one of them must be @math{Q}.
@item At most one of @math{k_1} and @math{k_2} may be have parameters.
@item If one of @math{k_1} and @math{k_2} is an algebraic extension of @math{Z/p} it may not be defined by a @code{charstr} of type @code{(p^n,a)}. 
@end itemize


@strong{Example:}
@smallexample
@c example
  ring R1=0,(x,y),dp;
  ring R2=32003,(a,b),dp;
  def R=R1+R2;
  R
 
         ==> //   characteristic : 32003
         ==> //   number of vars : 4
         ==> //        block   1 : ordering dp
         ==> //                  : names    x y 
         ==> //        block   2 : ordering dp
         ==> //                  : names    a b 
         ==> //        block   3 : ordering C


@c example
@end smallexample

@c ---------------------------------------

@node ring related functions@value{PSUFFIX},  , ring operations@value{PSUFFIX}, ring@value{PSUFFIX}
@subsection ring related functions@value{PSUFFIX}
@cindex ring related functions@value{PSUFFIX}
