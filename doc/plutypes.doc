@comment -*-texinfo-*-
@comment $Id: plutypes.doc,v 1.26 2005-04-28 16:29:55 levandov Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plutypes.info

@node Top, Data types @value{PSUFFIX}, (dir), (dir)
@menu
* Data types @value{PSUFFIX}::
@end menu

@node Data types @value{PSUFFIX},  , Top, Top
@chapter Data types @value{PSUFFIX}
%**end
@end ignore

@cindex expression list
This chapter explains all data types of @sc{Plural} in
alphabetical order. For every type, there is a description of the
declaration syntax 
@* as well as information about how to build expressions of certain types.

The term "expression list" in @sc{Plural} refers to any comma separated
list of expressions.

For the general syntax of a declaration see 
@c @ref{General command syntax}.

@menu
* ideal @value{PSUFFIX}::
* map @value{PSUFFIX}::
* module @value{PSUFFIX}::
* poly @value{PSUFFIX}::
* qring @value{PSUFFIX}::
* resolution @value{PSUFFIX}::
* ring @value{PSUFFIX}::
@ifset namespaces
@end ifset
@end menu


@c ---------------------------------------

@node ideal @value{PSUFFIX}, map @value{PSUFFIX}, Data types @value{PSUFFIX}, Data types @value{PSUFFIX}
@section ideal @value{PSUFFIX}
@c @cindex ideal
@cindex  untyped definitions 

Under an ideal @sc{Plural} understand a @strong{left} ideal. 
@* Ideals are represented as lists of polynomials which are interpreted as
left generators of  the ideal. 
@* For the operations with two-sided ideals see 
 @ref{twostd}. 


Like polynomials, ideals can only be defined or accessed with respect to a basering.

@strong{Note:} @code{size} counts only the non-zero generators of an ideal
whereas @code{ncols} counts all generators. 


@menu
* ideal declarations @value{PSUFFIX}::
* ideal expressions @value{PSUFFIX}::
* ideal operations @value{PSUFFIX}::
* ideal related functions @value{PSUFFIX}::
@end menu


@c ---------------------------------------

@node ideal declarations @value{PSUFFIX}, ideal expressions @value{PSUFFIX}, ideal @value{PSUFFIX}, ideal @value{PSUFFIX}
@subsection ideal declarations @value{PSUFFIX}
@cindex ideal declarations @value{PSUFFIX}

@table @strong
@item Syntax:
@code{ideal} name @code{=} list_of_poly_and_ideal_expressions @code{;}
@*@code{ideal} name @code{=} ideal_expression @code{;}

@item Purpose:
defines a left ideal.

@item Default:
0

@item Example:
@smallexample
@c example
ring r=0,(x,y,z),dp;
ncalgebra(-1,0); // an anticommutative algebra
poly s1 = x2;
poly s2 = y3;
poly s3 = z;
ideal i =  s1, s2-s1, 0,s2*s3, s3^4;
i;
size(i);
ncols(i);
@c example
@end smallexample
@end table



@c ------------------------------

@node ideal expressions @value{PSUFFIX}, ideal operations @value{PSUFFIX}, ideal declarations @value{PSUFFIX}, ideal @value{PSUFFIX}
@subsection ideal expressions @value{PSUFFIX}
@cindex ideal expressions @value{PSUFFIX}

An ideal expression is:
@enumerate
@item
an identifier of type ideal
@item
a function returning ideal
@item
ideal expressions combined by the arithmetic operations
@code{+} or @code{*}
@item
a power of an ideal expression (operator @code{^} or @code{**})
@*Note that the computation of the product @code{i*i} involves
all products of generators of @code{i} while @code{i^2} involves
only the different ones, and is therefore faster.
@item
a type cast to ideal
@end enumerate

@*@strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
ncalgebra(-1,0); // an anticommutative algebra
ideal m = maxideal(1);
m;
poly f = x2;
poly g = y3;
ideal i = x*y*z , f-g, g*(x-y) + f^4 ,0, 2x-z2y;
ideal M = i + maxideal(10);
i = M*M;
ncols(i);
i = M^2;
ncols(i);
i[ncols(i)];
vector v = [x,y-z,x2,y-x,x2yz2-y];
ideal j = ideal(v);
j;
@c example
@end smallexample


@c ------------------------------

@node ideal operations @value{PSUFFIX}, ideal related functions @value{PSUFFIX}, ideal expressions @value{PSUFFIX}, ideal @value{PSUFFIX}
@subsection ideal operations @value{PSUFFIX}
@cindex ideal operations @value{PSUFFIX}

@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
multiplication (with ideal, poly, vector, module; in case of
multiplication with ideal, the result will be simplified)

@item @code{^}
exponentiation (by a non-negative integer)

@item ideal_expression @code{[} intvec_expression @code{]}
are polynomial generators of the ideal, index 1 gives the first
generator.

@ifset singularmanual
@strong{Note:} For simplification of an ideal, see also
 @ref{simplify}.
@end ifset 

@ifclear singularmanual
@strong{Note:} For simplification of an ideal, see also section simplify
in @sc{Singular} manual.
@end ifclear  

@*@strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix D[3][3];
D[1,2]=-z;  D[1,3]=y;  D[2,3]=x;
ncalgebra(1,D); // this algebra is U(so_3) 
ideal I = 0,x,0,1;
I;
I + 0;    // simplification
I*x;
ideal J = I,0,x,x-z;
I * J;   //  multiplication with simplification
vector V = [x,y,z];
print(V*I);
ideal m = maxideal(1);
m^2;
ideal II = I[2..4];
II;
@c example
@end smallexample
@end table

@c ------------------------------

@node ideal related functions @value{PSUFFIX},  , ideal operations @value{PSUFFIX}, ideal @value{PSUFFIX}
@subsection ideal related functions @value{PSUFFIX}
@cindex ideal related functions @value{PSUFFIX}


@table @code

@item mres 
minimal free resolution of an ideal resp.@: module w.r.t. a minimal set
of generators of the given ideal resp.@: module
(see @ref{mres @value{PSUFFIX}})
@item nres 
computes a free resolution of an ideal resp.@: module M which is
minimized from the second module on
(see @ref{nres @value{PSUFFIX}})          
@item reduce
normal form with respect to a Groebner basis (see @ref{reduce @value{PSUFFIX}})
@c @item res
@c free resolution of an ideal resp.@: module but not changing the given ideal resp.@: module(see @ref{res @value{PSUFFIX}})
@item std
Groebner basis computation (see @ref{std @value{PSUFFIX}})
@item syz
computation of the first syzygy module (see @ref{syz @value{PSUFFIX}})
@item twostd
two-sided Groebner basis computation (see @ref{twostd})
@end table


@c ---------------------------------------
@node map @value{PSUFFIX}, module @value{PSUFFIX}, ideal @value{PSUFFIX}, Data types @value{PSUFFIX}
@section map @value{PSUFFIX}
@cindex map @value{PSUFFIX}

Maps are ring maps from a preimage ring into the basering.

@strong{Note:}
@itemize @bullet
@item
the target of a map is @strong{ALWAYS} the actual basering
@item
the preimage ring is stored "by name", that means, maps can only be
used in such contexts, where the name of the preimage ring can be
resolved (i.e., there might be problems for rings/maps defined in
subprocedures). 
@c See also @ref{Identifier resolution}, @ref{Names in procedures}.
@end itemize

Maps between rings with different coefficient fields are
possible and listed below.

Canonically realized are
@itemize @bullet
@item
@tex
$Q \rightarrow  Q(a, \ldots)$
@end tex
@ifinfo
Q -> Q(a,..)
@end ifinfo

@item
@tex
$Q \rightarrow R$
@end tex
@ifinfo
Q -> R
@end ifinfo

@item
@tex
$Q \rightarrow  C$
@end tex
@ifinfo
Q -> C
@end ifinfo

@item
@tex
$Z/p \rightarrow  (Z/p)(a, \ldots)$
@end tex
@ifinfo
Z/p ->(Z/p)(a,...)
@end ifinfo

@item
@tex
$Z/p \rightarrow  GF(p^n)$
@end tex
@ifinfo
Z/p -> GF(p^n)
@end ifinfo

@item
@tex
$Z/p \rightarrow  R$
@end tex
@ifinfo
Z/p -> R
@end ifinfo

@item
@tex
$R \rightarrow C$
@end tex
@ifinfo
R -> C
@end ifinfo
@end itemize

Possible are furthermore
@itemize @bullet
@item
@tex
% This is quite a hack, but for now it works.
$Z/p \rightarrow Q,
\quad
[i]_p \mapsto i \in [-p/2, \, p/2]
\subseteq Z$
@end tex
@ifinfo
Z/p -> Q : [i]_p -> i in [-p/2, p/2] in Z
@end ifinfo
@item
@tex
$Z/p \rightarrow Z/p^\prime,
\quad
[i]_p \mapsto i \in [-p/2, \, p/2] \subseteq Z, \;
i \mapsto [i]_{p^\prime} \in Z/p^\prime$
@end tex
@ifinfo
Z/p -> Z/p' : [i]_p in Z/p -> i in [-p/2,p/2] in Z, i -> [i]_p' in Z/p'
@end ifinfo
@item
@tex
$C \rightarrow R, \quad$ by taking the real part.
@end tex
@ifinfo
C -> R by taking the real part.
@end ifinfo
@end itemize

Finally, in Singular we allow the mapping from rings
with coefficient field Q to rings whose ground fields
have finite characteristic:

@itemize @bullet
@item
@tex
$Q \rightarrow Z/p$
@end tex
@ifinfo
Q -> Z/p
@end ifinfo

@item
@tex
$Q \rightarrow (Z/p)(a, \ldots)$
@end tex
@ifinfo
Q -> (Z/p)(a,..)
@end ifinfo
@end itemize
In these cases the denominator and the numerator
of a number are mapped separately by the usual
map from Z to Z/p, and the image of the number
is built again afterwards by division. It is thus
not allowed to map numbers whose denominator is
divisible by the characteristic of the target
ground field, or objects containing such numbers.
We, therefore, strongly recommend using such
maps only to map objects with integer coefficients.


@menu
* map declarations @value{PSUFFIX}::
* map expressions @value{PSUFFIX}::
* map operations @value{PSUFFIX} ::
* map related functions @value{PSUFFIX} ::
@end menu
@c @iftex
@c See @ref{imap}; @ref{fetch}; @ref{subst}.
@c @end iftex

@c ------------------------------
@node map declarations @value{PSUFFIX}, map expressions @value{PSUFFIX}, map @value{PSUFFIX}, map @value{PSUFFIX}
@subsection map declarations @value{PSUFFIX}
@cindex map declarations @value{PSUFFIX}

@table @strong
@item Syntax:
@code{map} name @code{=} preimage_ring_name @code{,} ideal_expression @code{;}
@*@code{map} name @code{=} preimage_ring_name @code{,} list_of_poly_and_ideal_expressions @code{;}
@*@code{map} name @code{=} map_expression @code{;}

@item Purpose:
defines a ring map from @code{preimage_ring} to basering.
@* Maps the variables of the @code{preimage ring} to the generators of the ideal.
@* If the ideal contains less elements than the number of variables in the
@code{preimage_ring}, the remaining variables are mapped to 0. 
@* If the ideal contains more elements, extra elements are ignored.
@* The image ring is always the current basering.
For the mapping of coefficients from different fields see @ref{map}.

@item Default:
none

@item Note:
There are standard mappings for maps which are close to the identity
map: @code{fetch @value{PSUFFIX}} and @code{imap @value{PSUFFIX}}.

The name of a map serves as the function which maps objects from the
preimage_ring into the basering.  These objects must be defined
by names (no evaluation in the preimage ring is possible).

@item Example:
@smallexample
@c example
// an easy example
ring r1 = 0,(a,b),dp; // a commutative ring
poly P = a^2+ab+b^3;
ring r2 = 0,(x,y),dp;
ncalgebra(1,-1); // a Weyl algebra
map M = r1, x^2, -y^3; // note this is not a morphism, just a map
M(P);
// now, consider more interesting example
LIB "ncalg.lib";
def Usl2 = sl2(); // this algebra is U(sl_2), generated by  e,f,h
setring Usl2;
poly  C  = 4*e*f+h^2-2*h; // the central element of U(sl2)
poly  D  = e^3*f-h^4;     // some polynomial
ring W1  = 0,(D,X),dp;
ncalgebra(1,-1); // this algebra is the opposite Weyl algebra
option(redSB);
option(redTail);
map F = Usl2, -X, D*D*X, 2*D*X;
F(C); // 0, because this map has a nonzero kernel
F(D);
 
@c example
@end smallexample
@end table

@c ref
See 
@ref{fetch @value{PSUFFIX}};
@ref{ideal expressions @value{PSUFFIX}};
@ref{imap @value{PSUFFIX}};
@ref{map @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref
@c ------------------------------
@node map expressions @value{PSUFFIX}, map operations @value{PSUFFIX}, map declarations @value{PSUFFIX}, map @value{PSUFFIX}
@subsection map expressions @value{PSUFFIX}
@cindex map expressions @value{PSUFFIX}

A map expression is:
@enumerate
@item
an identifier of type map
@item
a function returning map
@item
map expressions combined by composition using parentheses (@code{(}, @code{)})
@end enumerate

@c ------------------------------
@node map operations  @value{PSUFFIX}, map related functions @value{PSUFFIX}, map expressions @value{PSUFFIX}, map @value{PSUFFIX}
@subsection map @value{PSUFFIX} operations

@cindex map operations @value{PSUFFIX} 

@table @asis
@item @code{( )}
composition of maps. If, for example, @code{f} and @code{g} are maps,
then @code{f(g)} is a map expression giving the composition of @code{f}
and @code{g},
@* provided the target ring of @code{g} is the basering of @code{f}.

@item map_expression @code{[} int_expressions @code{]}
is a map entry (the image of the corresponding variable)
@end table

@*@strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def Usl2 = sl2(); // this algebra is U(sl_2)
setring Usl2;
map F = Usl2, f, e, -h; // check the endomorphism of U(sl_2)
map G = F(F);
poly p = (f+e*h)^2 + 3*h-e;
p;
F(p);
G(p);
(G(p) == p); // G is the identity
@c example
@end smallexample

@c ------------------------------
@node map related functions @value{PSUFFIX},  , map operations @value{PSUFFIX}, map  @value{PSUFFIX}
@subsection map related functions  @value{PSUFFIX}

@cindex map related functions  @value{PSUFFIX}

@table @code
@item fetch @value{PSUFFIX} 
the identity map between rings and qrings (see @ref{fetch @value{PSUFFIX}})

@item imap @value{PSUFFIX}
a convenient map procedure for inclusions and projections of rings (see @ref{imap @value{PSUFFIX}})

@item preimage @value{PSUFFIX}
preimage under a ring map (see @ref{preimage @value{PSUFFIX}})

@item subst
substitute a ring variable (see @ref{subst})
@end table


@c ---------------------------------------

@node module @value{PSUFFIX}, poly @value{PSUFFIX}, map @value{PSUFFIX}, Data types @value{PSUFFIX}
@section module @value{PSUFFIX}
@cindex module @value{PSUFFIX}

Modules are @strong{left} submodules of a free module over the basering with basis
@code{gen(1)}, @code{gen(2)}, @dots{}, @code{gen(n)} for some natural number @code{n}.
@* They are represented by lists of vectors, which generate the left submodule.
Like vectors, they
can only be defined or accessed with respect to a basering.

If @math{M} is a left submodule of
@ifinfo
R^n,
@end ifinfo
@tex
$R^n$
@end tex
(where @math{R} is the basering) generated by vectors
@ifinfo
v_1, @dots{}, v_k, then 
@end ifinfo
@tex
$v_1, \ldots, v_k$, then 
@end tex
 these generators may be considered as 
@* the generators of relations of
@ifinfo
R^n/M
@end ifinfo
@tex
$R^n/M$
@end tex
between the canonical generators @code{gen(1)},@dots{},@code{gen(n)}.
Hence, any finitely generated @math{R}-module can be represented in @sc{Plural}
by its module of relations. 
@* The assignments @code{module M=v1,...,vk; matrix A=M;} 
create the presentation matrix of size
@ifinfo
n x k
@end ifinfo
@tex
$n \times k$
@end tex
 for
@ifinfo
R^n/M,
@end ifinfo
@tex
$R^n/M$,
@end tex
 i.e. the columns of A are the vectors
@ifinfo
v_1, @dots{}, v_k which generate M. 
@end ifinfo
@tex
$v_1, \ldots, v_k$ which generate $M$. 
@end tex


@menu
* module declarations @value{PSUFFIX}::
* module expressions @value{PSUFFIX}::
* module operations @value{PSUFFIX}::
* module related functions @value{PSUFFIX}::
@end menu

@c ------------------------------

@node module declarations @value{PSUFFIX}, module expressions @value{PSUFFIX}, module @value{PSUFFIX}, module @value{PSUFFIX}
@subsection module declarations @value{PSUFFIX}
@cindex module declarations @value{PSUFFIX}

@table @strong
@item Syntax:
@code{module} name @code{=} list_of_vector_expressions (which are
interpreted as
left generators of  the module) @code{;}
@*@code{module} name @code{=} module_expression @code{;}

@item Purpose:
defines a left  module.

@item Default:
[0]

@item Example:
@smallexample
@c example
ring r=0,(x,y,z),(c,dp);
matrix D[3][3];
D[1,2]=-z;  D[1,3]=y;  D[2,3]=x;
ncalgebra(1,D); // this algebra is U(so_3)
vector s1 = [x2,y3,z];
vector s2 = [xy,1,0];
vector s3 = [0,x2-y2,z];
poly   f  = -x*y;
module m = s1, s2-s1,f*(s3-s1);
m;
// show m in matrix format (columns generate m)
print(m);

@c example
@end smallexample
@end table

@c ------------------------------

@node module expressions @value{PSUFFIX}, module operations @value{PSUFFIX}, module declarations @value{PSUFFIX}, module @value{PSUFFIX}
@subsection module expressions @value{PSUFFIX}
@cindex module expressions @value{PSUFFIX}

A module expression is:
@enumerate
@item
an identifier of type module
@item
a function returning module
@item
module expressions combined by the arithmetic operation @code{+}
@item
multiplication of a module expression with an ideal or a poly expression: @code{*}
@item
a type cast to module
@end enumerate


@c @*@strong{Example:}
@c @example
@c @c example
@c @c example
@c @end example

@c ------------------------------
@node module operations @value{PSUFFIX}, module related functions @value{PSUFFIX}, module expressions @value{PSUFFIX}, module @value{PSUFFIX}
@subsection module operations @value{PSUFFIX}
@cindex module operations @value{PSUFFIX}


@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
right or left multiplication with ideal or poly (but not `module` * `module`!)

@item module_expression @code{[} int_expression @code{,} int_expression @code{]}
is a module entry, where the first index indicates the row and
the second the column

@item module_expressions @code{[} int_expression @code{]}
is a vector, where the index indicates the column
@end table

@*@strong{Example:}
@smallexample
@c example
ring A=0,(x,y,z),Dp;
matrix D[3][3];
D[1,2]=-z;  D[1,3]=y;  D[2,3]=x;  // this algebra is U(so_3) 
ncalgebra(1,D);
module M = [x,y],[0,0,x*z];
module N = (x+y-z)*M - M*(x+y-z);
print(-N);
@c example
@end smallexample


@c ------------------------------
@node module related functions @value{PSUFFIX}, poly declarations @value{PSUFFIX}, module operations @value{PSUFFIX}, module @value{PSUFFIX}
@subsection module related functions @value{PSUFFIX}
@cindex module related functions @value{PSUFFIX}



@table @code
@item mres 
computes minimal free resolution of an ideal resp. 
module w.r.t. a minimal set of generators of the given ideal
resp. module (see @ref{mres @value{PSUFFIX}})
@item nres 
computes a free resolution of an ideal resp.@: module M which is
minimized from the second module on
(see @ref{nres @value{PSUFFIX}})          
@item reduce
normal form with respect to a Groebner basis (see @ref{reduce @value{PSUFFIX}})
@item std
Groebner basis computation (see @ref{std @value{PSUFFIX}})
@item syz
computation of the first syzygy module (see @ref{syz @value{PSUFFIX}})
@end table






@c ---------------------------------------

@ifset namespaces
@node poly @value{PSUFFIX}, qring @value{PSUFFIX}, module @value{PSUFFIX}, Data types @value{PSUFFIX}
@end ifset
@ifclear namespaces
@node poly @value{PSUFFIX}, qring @value{PSUFFIX}, module @value{PSUFFIX}, Data types @value{PSUFFIX}
@end ifclear
@section poly @value{PSUFFIX}
@cindex poly @value{PSUFFIX}

Polynomials are the basic data for all main algorithms in
@sc{Plural}. They consist of finitely many terms
(coefficient*monomial) which are combined by the usual polynomial
operations (see @ref{poly expressions @value{PSUFFIX}}).
 Polynomials can only be defined
or accessed with respect to a basering which determines the coefficient
type, the names of the indeterminants and the monomial ordering.
@*@strong{Example:}
@smallexample
@c example
  ring r=32003,(x,y,z),dp;
  poly f=x3+y5+z2;
@c example
@end smallexample

@menu
* poly declarations @value{PSUFFIX}::
* poly expressions @value{PSUFFIX}::
* poly operations @value{PSUFFIX}::
* poly related functions @value{PSUFFIX}::
@end menu

@c ------------------------------

@node poly declarations @value{PSUFFIX}, poly expressions @value{PSUFFIX}, module related functions @value{PSUFFIX}, poly @value{PSUFFIX}
@subsection poly declarations @value{PSUFFIX}
@cindex poly declarations @value{PSUFFIX}

@table @strong
@item Syntax:
@code{poly} name @code{=} poly_expression @code{;}

@item Purpose:
defines a polynomial.

@item Default:
0 

@item Example:
@smallexample
@c example
ring r = 32003,(x,y,z),dp;
ncalgebra(-1,1); // ring of some differential-like operators
r;
poly s1  = x3y2+151x5y+186xy6+169y9;
poly s2  = 1*x^2*y^2*z^2+3z8;
poly s3  = 5/4x4y2+4/5*x*y^5+2x2y2z3+y7+11x10;
int a,b,c,t=37,5,4,1;
poly f=3*x^a+x*y^(b+c)+t*x^a*y^b*z^c;
f;
short = 0;
f;
 
@c example
@end smallexample
@end table



@c ----------------------------

@node poly expressions @value{PSUFFIX}, poly operations @value{PSUFFIX}, poly declarations @value{PSUFFIX}, poly @value{PSUFFIX}
@subsection poly expressions @value{PSUFFIX}
@cindex poly expressions @value{PSUFFIX}

A poly expression is (optional parts in square brackets):
@enumerate
@item
a monomial (there are NO spaces allowed inside a monomial)
@smallexample
  [coefficient] ring_variable [ exponent] [ring_variable [exponent] @dots{}]
@end smallexample
 monomials which contain an indexed ring variable
 must be built from @code{ring_variable} and @code{coefficient}
 with the operations @code{*} and @code{^}
@item
an identifier of type poly
@item
a function returning poly
@item
poly expressions combined by the arithmetic operations @code{+}, @code{-}, @code{*}, @code{/}, or @code{^}.
@item
a type cast to poly
@end enumerate

@strong{Remark:} In the non-commutative case see @ref{Getting started with PLURAL}.

@strong{Example:}
@smallexample
@c example
ring r=0,(x,y),dp;
ncalgebra(1,1);  // make it a Weyl algebra 
r;
yx;      // not correct input
y*x;     // correct input
poly f = 10x2*y3 + 2y2*x^2 - 2*x*y + y - x + 2;
lead(f);
leadmonom(f);
simplify(f,1);     // normalize leading coefficient
cleardenom(f);
@c example
@end smallexample 


@c ------------------------------

@node poly operations @value{PSUFFIX}, poly related functions @value{PSUFFIX}, poly expressions @value{PSUFFIX}, poly @value{PSUFFIX}
@subsection poly operations @value{PSUFFIX}
@cindex poly operations @value{PSUFFIX}

@table @asis
@item @code{+}
addition

@item @code{-}
negation or subtraction

@item @code{*}
multiplication

@item @code{/}
division by a monomial, non divisible terms yield 0

@item @code{^}, @code{**}
power by a positive integer

@item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
comparison (of leading monomials w.r.t. monomial ordering)

@item poly_expression @code{[} intvec_expression @code{]}
the sum of monomials at the indicated places w.r.t. the monomial ordering
@end table


@c ------------------------------

@node poly related functions @value{PSUFFIX},  , poly operations @value{PSUFFIX}, poly @value{PSUFFIX}
@subsection poly related functions @value{PSUFFIX}
@cindex poly related functions @value{PSUFFIX}


@table @code
@item bracket 
computes the Lie bracket of two polinomials (see @ref{bracket})
@end table

@c ---------------------------------------

@node qring @value{PSUFFIX}, resolution @value{PSUFFIX}, poly @value{PSUFFIX}, Data types @value{PSUFFIX}
@section qring @value{PSUFFIX}
@cindex qring @value{PSUFFIX}

@sc{Plural} offers the opportunity to compute within 
factor-rings modulo two-sided ideals.  The ideal has to be given
as a two-sided Groebner basis (see @ref{twostd} command). 

@* For a detailed description of the concept of rings and quotient rings see
@ifset singularmanual 
@ref{Rings and orderings}.
@end ifset
@ifclear singularmanual
in @sc{Singular} manual section Rings and orderings.
@end ifclear

@menu
* qring declaration @value{PSUFFIX}::
@end menu

@strong{Note:}
we highly recommend to turn on 
@code{option(redSB); option(redTail);}
while computing in qrings. Otherwise results may have no meaning.

@c ---------------------------------------

@node qring declaration @value{PSUFFIX},  , qring @value{PSUFFIX}, qring @value{PSUFFIX}
@subsection qring declaration @value{PSUFFIX}
@cindex qring declaration @value{PSUFFIX}


@table @strong
@item Syntax:
@code{qring} name @code{=} ideal_expression @code{;}
@item Default:
none
@item Purpose:
declares a quotient ring as the basering modulo ideal_expression and sets
it as current basering.
@item Example:
@smallexample
@c example
ring r=0,(z,u,v,w),dp;
ncalgebra(-1,0); // an anticommutative algebra
option(redSB);
option(redTail);
ideal i=z^2,u^2,v^2,w^2;
qring q=twostd(i); // now it is an exterior algebra
q;
poly k = (v-u)*(zv+u-w);
k; // the output is not yet totally reduced
poly ek=reduce(k,std(0));
ek; // the reduced form
@c example
@end smallexample
@end table


@c ------------------------------------------------------------
@c   This piece of text exists also in the file general.doc,
@c   chapter "General syntax of a ring declaration".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------


@c ---------------------------------------

@node resolution @value{PSUFFIX}, ring @value{PSUFFIX}, qring @value{PSUFFIX}, Data types @value{PSUFFIX}
@section resolution @value{PSUFFIX}
@cindex resolution @value{PSUFFIX}

The resolution type is intended as an intermediate representation which
internally retains additional information obtained during computation of
resolutions. It furthermore enables the use of partial results to
compute, for example, Betti numbers or minimal resolutions. Like ideals
and modules, a resolution can only be defined w.r.t.@: a basering.

@strong{Note:}
to access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time,
(resp.@: an access directly with the brackets @code{[ , ]} causes
implicitly a cast to a list).

@menu
* resolution declarations @value{PSUFFIX}::
* resolution expressions @value{PSUFFIX}::
* resolution related functions @value{PSUFFIX}::
@end menu

@c ---------------------------------------

@node resolution declarations @value{PSUFFIX}, resolution expressions @value{PSUFFIX}, resolution @value{PSUFFIX}, resolution @value{PSUFFIX}
@subsection resolution declarations @value{PSUFFIX}
@cindex resolution declarations @value{PSUFFIX}

@table @strong
@item Syntax:
@code{resolution} name @code{=} resolution_expression @code{;}

@item Purpose:
defines a resolution.

@item Default:
none

@item Example:
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix D[3][3];
D[1,2]=z;
ncalgebra(1,D); // it is a Heisenberg algebra
ideal i=z2+z,x+y;
resolution re=nres(i,0);
re;
list l = re;
l;
print(matrix(l[2]));
@c example
@end smallexample
@end table

@c ------------------------------

@node resolution expressions @value{PSUFFIX}, resolution related functions @value{PSUFFIX}, resolution declarations @value{PSUFFIX}, resolution @value{PSUFFIX}
@subsection resolution expressions @value{PSUFFIX}
@cindex resolution expressions @value{PSUFFIX}

A resolution expression is:
@enumerate
@item
an identifier of type resolution
@item
a function returning a resolution
@item
a type cast to resolution from a list of ideals, resp.@: modules.
@end enumerate


@c ------------------------------

@node resolution related functions @value{PSUFFIX},  , resolution expressions @value{PSUFFIX}, resolution @value{PSUFFIX}
@subsection resolution related functions @value{PSUFFIX}
@cindex resolution related functions @value{PSUFFIX}

@table @code
@item minres 
minimizes a free resolution  (see @ref{minres @value{PSUFFIX}})
@item mres 
computes a minimal free resolution of an ideal resp. 
module w.r.t. a minimal set of generators of the given ideal
resp. module (see @ref{mres @value{PSUFFIX}})
@item nres 
computes a free resolution of an ideal resp.@: module M which is
minimized from the second module on (see @ref{nres @value{PSUFFIX}})          
@c @item res
@c free resolution of an ideal resp.@: module but not changing the given ideal resp.@: module(see @ref{res @value{PSUFFIX}})
@end table


@c ---------------------------------------

@node ring @value{PSUFFIX},  , resolution @value{PSUFFIX}, Data types @value{PSUFFIX}
@section ring @value{PSUFFIX}
@cindex ring @value{PSUFFIX}

Rings are used to describe properties of polynomials, ideals etc.
Almost all computations in @sc{Plural} require a basering.
For a detailed description of the concept of rings see
@ifset singularmanual
@ref{Rings and orderings}.
@end ifset 
@ifclear singularmanual
@sc{Singular} manual (Chapter: General Concepts, Section: Rings and orderings).
@end ifclear

@*@strong{Note:} @sc{Plural} works with global orderings
only (@pxref{Getting started with PLURAL}).

@menu
* ring declarations @value{PSUFFIX}::
* ring operations @value{PSUFFIX}::
* ring related functions @value{PSUFFIX}::
@end menu

@c ---------------------------------------

@node ring declarations @value{PSUFFIX}, ring operations @value{PSUFFIX}, ring @value{PSUFFIX}, ring @value{PSUFFIX}
@subsection ring declarations @value{PSUFFIX}
@cindex ring declarations @value{PSUFFIX}

@table @strong
@item Syntax:
@code{ring} name @code{= (} coefficient_field @code{),}
  @code{(} names_of_ring_variables @code{),}
  @code{(} ordering @code{);}
@item Default:
@code{2147483629,(x,y,z),(dp,C);}
@item Purpose:
declares a ring and sets it as the actual basering.
@end table

The coefficient_field is given by one of the following:
@enumerate
@item
a non-negative int_expression less or equal 2147483629.
@item
an expression_list of an int_expression and one or more names.
@item
the name @code{real}.
@item
an expression_list of the name @code{real} and an  int_expression.
@item
an expression_list of the name @code{complex}, an optional int_expression
and a name.
@end enumerate


'names_of_ring_variables' must be a list of names or indexed names.

'ordering' is a list of block orderings where each block ordering is either
@enumerate
@item
@code{lp}, @code{dp}, @code{Dp}, 
optionally followed by a size parameter in parentheses.

@item
@code{wp}, @code{Wp}, or @code{a} followed by a
weight vector given as an intvec_expression in parentheses.

@item
@code{M} followed by an intmat_expression in parentheses.

@item
@code{c} or @code{C}.
@end enumerate


If one of coefficient_field, names_of_ring_variables, and ordering
consists of only one entry, the parentheses around this entry may be
omitted.

@strong{In order to create the non-commutative extension, use} @ref{ncalgebra}.  


@c ---------------------------------------

@node ring operations @value{PSUFFIX}, ring related functions @value{PSUFFIX}, ring declarations @value{PSUFFIX}, ring @value{PSUFFIX}
@subsection ring operations @value{PSUFFIX}
@cindex ring operations @value{PSUFFIX}
@table @asis
@item @code{+}
construct a tensor product over the groung field
@ifinfo
C = A\otimes_k B
@end ifinfo
@tex
$C = A\otimes_{\bf{K} } B$
@end tex 
of two
@ifinfo 
G-algebras A and B. 
@end ifinfo
@tex
$G$-algebras $A$ and $B$.
@end tex

Let
@ifinfo
 A=k1<x_1,...,x_n | @{x_j x_i=c_@{ij@}x_i x_j + d_@{ij @} @}, 1 =<i <j =< n >,
 and
 B=k2<y_1,...,y_m | @{y_j y_i=q_@{ij@}y_i y_j + r_@{ij @} @}, 1 =<i <j =< m >
@end ifinfo

@tex 
$A= k_1 \langle x_1, \ldots ,x_n \mid$ 
$\{ x_j x_i=c_{ij} \cdot x_i x_j + d_{ij}\}, 1 \leq i <j \leq n \rangle$,
and
$B= k_2 \langle y_1, \ldots ,y_m \mid$
$\{ y_j y_i=q_{ij} \cdot y_i y_j + r_{ij}\}, 1 \leq i <j \leq m \rangle$
@end tex

be two @math{G}-algebras, then @math{C} is defined to be the algebra

@ifinfo
C = K<x_1,...,x_n, y_1,...,y_m |
@{x_j x_i=c_@{ij@}x_i x_j + d_@{ij @}, 1 =<i <j =< n @},
@{y_j y_i=q_@{ij@}y_i y_j + r_@{ij @}, 1 =<i <j =< m @},
@{y_j x_i = x_i y_j, 1 <= j <= m, 1 <= i <= n @}>
@end ifinfo

@tex 
$C = K \langle x_1, \ldots ,x_n, y_1, \ldots ,y_m \mid$
$\{ x_j x_i=c_{ij} \cdot x_i x_j + d_{ij}, 1 \leq i <j \leq n\}$,
$\{ y_j y_i=q_{ij} \cdot y_i y_j + r_{ij}, 1 \leq i <j \leq m\}$,
$\{ y_j x_i = x_i y_j, 1 \leq j \leq m, 1 \leq i \leq n\}  \rangle$.
@end tex

@end table


Concerning the ground fields @math{k_1} and @math{k_2} take the
following guide lines into consideration:
@itemize @bullet
@item Neither @math{k_1} nor @math{k_2} may be @math{R} or @math{C}.
@item If the characteristic of @math{k_1} and @math{k_2} differs, then one of them must be @math{Q}.
@item At most one of @math{k_1} and @math{k_2} may have parameters.
@item If one of @math{k_1} and @math{k_2} is an algebraic extension of @math{Z/p} it may not be defined by a @code{charstr} of type @code{(p^n,a)}. 
@end itemize


@strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def a = sl2();       // U(sl_2) in e,f,h presentation
ring W = 0,(x,d),dp;
Weyl();              // 1st Weyl algebra in x,d
def S = a+W;
setring S;
S;
@c example
@end smallexample

@c ---------------------------------------

@node ring related functions @value{PSUFFIX},  , ring operations @value{PSUFFIX}, ring @value{PSUFFIX}
@subsection ring related functions @value{PSUFFIX}
@cindex ring related functions @value{PSUFFIX}

@table @code
@item envelope
enveloping ring (see @ref{envelope})
@item opposite
opposite ring (see @ref{opposite})
@item qring
quotient ring (see @ref{qring @value{PSUFFIX}}) 
@end table
