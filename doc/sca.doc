@comment -*-texinfo-*-
@comment $Id: sca.doc,v 1.6 2009-04-17 12:53:22 motsak Exp $
@comment this file describes super-commutative algebras and their implementation in Singular

@node Super-commutative algebras,LETTERPLACE,Mathematical background (plural),Non-commutative subsystem
@section Super-commutative algebras
@cindex SCA, Super-commutative algebras, Z_2-graded algebras

This section describes basic mathematical notions, definition, and a little bit the implementation of
the experimental non-commutative kernel extension @sc{Sca} of @sc{Singular}
which improves performance of many algorithms in super-commutative algebras.

In order to improve performance of @sc{Singular} in specific non-commutative algebras
one can extend the internal implementation for them in a virtual-method-overloading-like manner.
At the moment super-commutative algebras (SCA) and in particular exterior algebras are implemented this way.

Note that super-commutative algebras require no special user actions apart from 
defining an appropriate non-commutative GR-algebra in @sc{Singular}. 
Upon doing that, the supper-commutative structure will be automatically detected and 
special multiplication will be used. 
Moreover, in most SCA-aware (e.g. @code{std}) algorithms special internal improvements will be used
(otherwise standard generic non-commutative implementations will be used).

All considered algebras are assumed to be associative @math{K}-algebras for some ground field @math{K}.

@itemize
@item Definition

Super-commutative algebras are factors of tensor products of any commutative algebras and an exterior algebra over @math{K}.
They are also known as @math{Z_2}-graded algebras since they have natural @math{Z_2}-grading 
where anti-commutative algebra generators have degree @math{1} and commutative algebra generators (and naturally scalars) 
have degree @math{0}. 

@item GR-algebra representation

A super-commutative algebra with @math{n} commutative and @math{m} anti-commutative algebra generators can be represented 
as factors of the following GR-algebra by some two-sided ideal: 
@tex
$$K\left\langle x_1, \ldots, x_n; y_1, \ldots, y_m \mid y_j * y_i = - y_i y_j, j > i \right\rangle / \left\langle y_1^2, \ldots, y_m^2  \right\rangle.$$
@end tex 

@item Distinctive features

Super-commutative algebras have zero divisors if @math{m > 0}: @math{y_i * y_i = 0}.

Unlike other non-commutative algebras one may use any monomial ordering
where only the non-commutative variables are required to be global.
In particular, commutative variables are allowed to be local. 
This means that one can work in tensor products of any commutative ring with an exterior algebra.

@item Example of defining super-commutative algebras in @sc{Singular}
@smallexample
@c example
LIB "nctools.lib";
ring r = 0,(a, b, x,y,z, Q, W),(lp(2), dp(3), Dp(2));
// Let us make variables x = var(3), ..., z = var(5) to be anti-commutative
// and add additionally a quotient ideal:
def S = superCommutative(3, 5, ideal(a*W + b*Q*x + z) ); setring S; S;
ideal I = a*x*y + z*Q + b, y*Q + a; I;
std(I); // Groebner basis is used here since > is global
kill r;
// Let's do the same but this time with some local commutative variables:
ring r = 0,(a, b, x,y,z, Q, W),(dp(1), ds(1), lp(3), ds(2));
def S = superCommutative(3, 5, ideal(a*W + b*Q*x + z) ); setring S; S;
ideal I = a*x*y + z*Q + b, y*Q + a; I;
std(I);
@c example
@end smallexample
@end itemize

See example of @code{superCommutative} from the library @code{nctools.lib}.

Reference: Ph.D thesis by Oleksandr Motsak (2009).
