@comment -*-texinfo-*-
@comment $Id: examples.doc,v 1.37 1999-02-09 08:16:07 obachman Exp $
@comment this file contains the examples

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').
@ignore
%**start
\input texinfo.tex
@setfilename examples.info
@node Top, Examples
@menu
* General concepts::
@end menu
@node Examples, Mathematical Background, Tricks and pitfalls, Top
@appendix Examples
%**end
@end ignore

@ifinfo
The following topics are treated:
@end ifinfo

@ifset singularmanual
@menu
* Milnor and Tjurina::
* Procedures and LIB::
* Critical points::
* Saturation::
* Long coefficients::
* Parameters::
* T1 and T2::
* Deformations::
* Finite fields::
* Elimination::
* Free resolution::
* Ext::
* Polar curves::
* Depth::
* Formatting output::
* Cyclic roots::
* G_a -Invariants::
* Invariants of a finite group::
* Factorization::
* Puiseux pairs::
* Primary decomposition::
* Normalization::
* Kernel of module homomorphisms::
* Algebraic dependence::
* Classification::
* Fast lexicographical GB::
* Parallelization with MPtcp links::
@end menu
@end ifset

@ifclear singularmanual
@menu
* Milnor and Tjurina::
* Procedures and LIB::
* Critical points::
* Saturation::
* Parameters::
* Deformations::
* Elimination::
* Free resolution::
* Formatting output::
* Factorization::
* Kernel of module homomorphisms::
* Algebraic dependence::
@end menu
@end ifclear

@c ----------------------------------------------------------------------------
@c @node Start SINGULAR, Milnor and Tjurina,Examples, Examples
@c @section Start SINGULAR
@c @cindex Start SINGULAR

@c Call @sc{Singular} by typing @code{Singular} [return]

@c To use the online help type for instance:
@c    @code{help;} @code{help command;} @code{help General syntax;} @code{help ring;}...
@c Please note:  EVERY COMMAND MUST END WITH A SEMICOLON ";"

@c To leave @sc{Singular}, type one of the:
@c    @code{quit;} @code{exit;} @code{$}

@c The two characters @code{//} make the rest of the line a comment.

@c ----------------------------------------------------------------------------
@node Milnor and Tjurina, Procedures and LIB, Examples, Examples
@section Milnor and Tjurina
@cindex Milnor
@cindex Tjurina

The Milnor number resp. the Tjurina number of a power
series f in
@tex
$K[[x_1,\ldots,x_n]]$
@end tex
@ifinfo
K[[x1,...,xn]]
@end ifinfo
is
@ifinfo
@*      milnor(f) = dim_K(K[[x1,...,xn]]/jacob(f))
@*resp.
@*      tjurina(f) = dim_K(K[[x1,...,xn]]/((f)+jacob(f)))
@*where
@end ifinfo
@tex
$$
\eqalignno{
\hbox{\it milnor}(f) &= \hbox{dim}_K(K[[x_1,\ldots,x_n]]/\hbox{\it jacob}(f))\cr
\noalign{\hbox{resp.}}
\hbox{\it tjurina}(f) &= \hbox{dim}_K(K[[x_1,\ldots,x_n]]/((f)+\hbox{\it jacob}(f)))\cr
}$$
where
@end tex
jacob(f) is the ideal generated by the partials
of f. tjurina(f) is finite, if and only if f has an
isolated singularity. The same holds for milnor(f) if
K has characteristic 0.
@sc{Singular} displays -1 if the dimension is infinite.

@sc{Singular} cannot compute with infinite power series. But it can
work in
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]$,
@end tex
@ifinfo
Loc_(x)K[x1,...,xn],
@end ifinfo
the localization of
@tex
$K[x_1,\ldots,x_n]$
@end tex
@ifinfo
K[x1,...,xn]
@end ifinfo
at the maximal ideal
@tex
$(x_1,\ldots,x_n)$.
@end tex
@ifinfo
(x1,...,xn).
@end ifinfo
To do this one has to define an
s-ordering like ds, Ds, ls, ws, Ws or an appropriate matrix
ordering (look at the manual to get information about the possible
monomial orderings in @sc{Singular}, or type @code{help Monomial orderings;}
to get a menu of possible orderings. For further help type e.g.
@code{help local orderings;}).

We shall show in the example below how to realize the following:
@itemize @bullet
@item
set option @code{prot} to have a short protocol during standard basis
computation
@item
define the ring r1 with char 32003, variables x,y,z, monomial
  ordering ds, series ring (i.e. K[x,y,z] localized at (x,y,z))
@item
list the information about r1 by typing its name
@item
define the integers a,b,c,t
@item
define a polynomial f (depending on a,b,c,t) and display it
@item
define the jacobian ideal i of f
@item
compute a standard basis of i
@item
compute the Milnor number (=250) with vdim and create and display
  a string in order to comment the result
  (text between quotes "  "; is a 'string')
@item
compute a standard basis of i+(f)
@item
compute the Tjurina number (=195) with @code{vdim}
@item
then compute the Milnor number (=248) and the Tjurina number
(=195) for t=1
@item
reset the option to @code{noprot}
@end itemize

@example
@c example
  option(prot);
  ring r1 = 32003,(x,y,z),ds;
  r1;
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  f;
  ideal i=jacob(f);
  i;
  ideal j=std(i);
  "The Milnor number of f(11,5,3) for t=0 is", vdim(j);
  j=i+f;    // overwrite j
  j=std(j);
  vdim(j);  // compute the Tjurina number for t=0
  t=1;
  f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
    +x^(c-2)*y^c*(y^2+t*x)^2;
  ideal i1=jacob(f);
  ideal j1=std(i1);
  "The Milnor number of f(11,5,3) for t=1:",vdim(j1);
  vdim(std(j1+f));   // compute the Tjurina number for t=1
  option(noprot);
@c example
@end example

@c ----------------------------------------------------------------------------
@node Procedures and LIB, Critical points, Milnor and Tjurina, Examples
@section Procedures and LIB
@cindex Procedures and LIB

The computation of the Milnor number (for an arbitrary isolated complete
intersection singularity ICIS) and the Tjurina number (for an arbitrary
isolated singularity) can be done by using procedures from the library
@code{sing.lib}. For a hypersurface singularity it is very easy to write a
procedure which computes the Milnor number and the Tjurina number.

We shall demonstrate:
@itemize @bullet
@item
loading the library @code{sing.lib}
@c item
@c disable the protocol option
@item
define a local ring in 2 variables and characteristic 0
@item
define a plane curve singularity
@item
compute Milnor number and Tjurina number by using the procedures
@code{milnor} and @code{tjurina}
@item
write your own procedures:
(A procedure has a list of input parameters and of return values, both
lists may be empty.)
  @itemize @minus
  @item
  the procedure @code{mil} which must be called with one parameter, a
  polynomial.
  The name g is local to the procedure and is killed automatically.
  @code{mil} returns the Milnor number (and displays a comment).
  @item
  the procedure @code{tjur} where the parameters are not specified. They
  are referred
  to by @code{#[1]} for the 1-st, @code{#[2]} for the 2-nd parameter etc.
  @code{tjur} returns the Tjurina number (and displays a comment).
  @item
  the procedure @code{milrina} which returns a list consisting of two
  integers,
  the Milnor and the Tjurina number.
  @end itemize
@end itemize

@example
LIB "sing.lib";
// you should get the information that sing.lib has been loaded
// together with some other libraries which are needed by sing.lib
ring r = 0,(x,y),ds;
poly f = x7+y7+(x-y)^2*x2y2;
milnor(f);
@expansion{} 28
tjurina(f);
@expansion{} 24

proc mil (poly g)
@{
   "Milnor number:";
   return(vdim(std(jacob(g))));
@}
mil(f);
@expansion{} Milnor number:
@expansion{} 28

proc tjur
@{
   "Tjurina number:";
   return(vdim(std(jacob(#[1])+#[1])));
@}
tjur(f);
@expansion{} Tjurina number:
@expansion{} 24

proc milrina (poly f)
@{
   ideal j=jacob(f);
   list L=vdim(std(j)),vdim(std(j+f));
   return(L);
@}
milrina(f);     // a list containing Milnor and Tjurina number
@expansion{} [1]:
@expansion{}    28
@expansion{} [2]:
@expansion{}    24
milrina(f)[2];  // the second element of the list
@expansion{} 24
@end example

@c ----------------------------------------------------------------------------
@node Critical points, Saturation, Procedures and LIB, Examples
@section Critical points
@cindex Critical points

The same computation which computes the Milnor resp. the Tjurina
number, but with ordering dp instead of ds (i.e. in
@tex
$K[x_1,\ldots,x_n]$
@end tex
@ifinfo
K[x1,...,xn]
@end ifinfo
instead of
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n])$
@end tex
@ifinfo
Loc_(x)K[x1,...,xn])
@end ifinfo
gives:
@itemize @bullet
@item
the number of critical points of f in the affine plane
(counted with multiplicities)
@item
the number of singular points of f on the affine plane curve f=0
(counted with multiplicities)
@end itemize

We start with the ring r1 from section @ref{Milnor and Tjurina} and its elements.

The following will be realized below:
@itemize @bullet
@item
reset the protocol option and activate the timer
@item
define the ring r2 with char 32003, variables x,y,z and monomial
  ordering dp (= degrevlex) (i.e. the polynomial ring = K[x,y,z]).
@item
Note that polynomials, ideals, matrices (of polys), vectors,
  modules belong to a ring, hence we have to define f and jacob(f)
  again in r2. Since these objects are local to a ring, we may use
  the same names.
  Instead of defining f again we map it from ring r1 to r2 by using
  the @code{imap} command (@code{imap} is a convenient way to map variables
  from some ring identically to variables with the same name in the 
  basering, even if the groundfield is different. Compare with @code{fetch}
  which works for almost identical rings,
  e.g. if the rings differ only by the ordering or the names of the variables
  and which may be used to rename variables).
  Integers and strings however do not belong to any ring. Once
  defined they are globally known.
@item
The result of the computation here (together with the previous one in
 @ref{Milnor and Tjurina}) shows that (for t=0)
@tex
$\hbox{dim}_K(\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]/\hbox{\it jacob}(f))$
@end tex
@ifinfo
  dim_K(Loc_(x)K[x1,...,xn]/jacob(f))
@end ifinfo
= 250 (previously computed) while
@tex
$\hbox{dim}_K(K[x_1,\ldots,x_n]/\hbox{\it jacob}(f))$
@end tex
@ifinfo
  dim_K(K[x1,...,xn]/jacob(f))
@end ifinfo
= 536. Hence f has 286 critical points,
  counted with multiplicity, outside the origin.
  Moreover, since
@tex
$\hbox{dim}_K(\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]/(\hbox{\it jacob}(f)+(f)))$
@end tex
@ifinfo
dim_K(Loc_(x)K[x1,...,xn]/(jacob(f)+(f)))
@end ifinfo
= 195 =
@tex
$\hbox{dim}_K(K[x_1,\ldots,x_n]/(\hbox{\it jacob}(f)+(f)))$,
@end tex
@ifinfo
dim_K(K[x1,...,xn]/(jacob(f)+(f))),
@end ifinfo
the affine surface f=0 is smooth outside the origin.
@end itemize

@example
@c example
  ring r1 = 32003,(x,y,z),ds;
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  timer=1;
  ring r2 = 32003,(x,y,z),dp;
  poly f=imap(r1,f);
  ideal j=jacob(f);
  vdim(std(j));
  vdim(std(j+f));
  timer=0;  // reset timer
@c example
@end example

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Saturation, Long coefficients, Critical points, Examples
@end ifset
@ifclear singularmanual
@node Saturation, Parameters, Critical points, Examples
@end ifclear
@section Saturation
@cindex Saturation

Since in the example above, the ideal j+(f) has the same vdim
in the polynomial ring and in the localization at 0 (each 195),
f=0 is smooth outside 0!
Hence j+(f) contains some power of the maximal ideal m. We shall
check this in a different manner:
For any two ideals i, j in the basering R let
@tex
$$
\eqalign{
\hbox{sat}(i,j)&=\{x\in R\;|\; \exists\;n\hbox{ s.t. }
x*(j^n)\subseteq i\}\cr
&=\bigcup_{n=1}^\infty i:j^n\cr}$$
@end tex
@ifinfo
@*sat(i,j) = @{x in R | there is an n s.t. x*(j^n) contained in i@}
@*         = union_(n=1...) of i:j^n,
@end ifinfo
@*denote the saturation of i with respect to j. This defines,
geometrically, the closure of the complement of V(j) in V(i)
(V(i) denotes the variety defined by i).
In our case, sat(j+(f),m) must be the whole ring, hence
generated by 1.

The saturation is computed by the procedure @code{sat} in
@code{elim.lib} by computing iterated ideal quotients with the maximal
ideal.  @code{sat} returns a list of two elements: the saturated ideal
and the number of iterations.  (Note that @code{maxideal(n)} denotes the
n-th power of the maximal ideal).

@example
@c example
  LIB "elim.lib";         // loading library elim.lib
  // you should get the information that elim.lib has been loaded
  // together with some other libraries which are needed by it
  option(noprot);         // no protocol
  ring r2 = 32003,(x,y,z),dp;
  poly f = x^11+y^5+z^(3*3)+x^(3+2)*y^(3-1)+x^(3-1)*y^(3-1)*z3+
    x^(3-2)*y^3*(y^2)^2;
  ideal j=jacob(f);
  sat(j+f,maxideal(1));
  // list the variables defined so far:
  listvar();
@c example
@end example

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Long coefficients, Parameters, Saturation, Examples
@section Long coefficients
@cindex Long coefficients

The following innocent example produces in its standard basis
extremely long coefficients in char 0 for the lexicographical
ordering.
But a very small deformation does not (the undeformed
example is degenerate with respect to the Newton boundary).
This example demonstrates that it might be wise, for complicated
examples, to do the calculation first in positive char (e.g. 32003).
It was shown, that in complicated examples, more than 95 percent of
the time needed for a standard basis computation is used in the
computation of the coefficients (in char 0).
The representation of long integers with real is demonstrated.

@example
timer = 1;                              // activate the timer
option(prot);
ring R0 = 0,(x,y),lp;
poly f = x5+y11+xy9+x3y9;
ideal i = jacob(f);
ideal i1 = i,i[1]*i[2];                 // undeformed ideal
ideal i2 = i,i[1]*i[2]+1/1000000*x5y8;  // deformation of i1
i1; i2;
@expansion{} i1[1]=5x4+3x2y9+y9
@expansion{} i1[2]=9x3y8+9xy8+11y10
@expansion{} i1[3]=45x7y8+27x5y17+45x5y8+55x4y10+36x3y17+33x2y19+9xy17+11y19
@expansion{} i2[1]=5x4+3x2y9+y9
@expansion{} i2[2]=9x3y8+9xy8+11y10
@expansion{} i2[3]=45x7y8+27x5y17+45000001/1000000x5y8+55x4y10+36x3y17
@expansion{} +33x2y19+9xy17+11y19
ideal j = std(i1);
@expansion{} V19-s20.s21(1)s22(2)23-s27.s28.s29.s30.s31.s32.s33.s34.s35.s36
@expansion{} .s37.s38.s39.s40.s.70-
@expansion{} product criterion:1 chain criterion:30
@expansion{} //used time: 1.9 sec
j;
@expansion{} j[1]=264627y39+26244y35-1323135y30-131220y26+1715175y21
@expansion{} +164025y17+1830125y16
@expansion{} j[2]=-12103947791971846719838321886393392913750065060875xy8
@expansion{} +286391521141683198701331939250003266767738632875y38
@expansion{} +3195440220690902692676462287757356578554430672591y37
@expansion{} -57436621420822663849721381265738895282846320y36
@expansion{} -1657764214948799497573918210031067353932439400y35
@expansion{} -21301848158930819119567722389898682697001205500y34
@expansion{} -1822194158663066565585991976961565719648069806148y33
@expansion{} +4701709279892816135156972313196394005220175y32
@expansion{} +135187226968819226760078697600850686824231975y31
@expansion{} +3873063305929810816961516976025038053001141375y30
@expansion{} -1325886675843874047990382005421144061861290080000y29
@expansion{} -15977201954760631419467945895542406089526966887310y28
@expansion{} +262701813363090926606333480026253304267126525y27
@expansion{} +7586082690893335269027136248944859544727953125y26
@expansion{} +86785307410649464602285843351672148965395945625y25
@expansion{} +5545808143273594102173252331151835700278863924745y24
@expansion{} -19075563013460437364679153779038394895638325y23
@expansion{} -548562322715501761058348996776922561074021125y22
@expansion{} -15746545267764838607395746471568100780933983125y21
@expansion{} +1414279129721176222978654235817359505555191156250y20
@expansion{} +20711190069445893615213399650035715378169943423125y19
@expansion{} -272942733337472665573418092977905322984009750y18
@expansion{} -7890651158453345058018472946774133657209553750y17
@expansion{} -63554897038491686787729656061044724651089803125y16
@expansion{} +22099251729923906699732244761028266074350255961625y14
@expansion{} -14793713967965590435357948972258591339027857296625y10
@expansion{} j[3]=5x4+3x2y9+y9

// Compute average coefficient length (=51) by
//   - converting j[2] to a string in order to compute the number
//   of characters
//   - divide this by the number of monomials:
size(string(j[2]))/size(j[2]);
@expansion{} 51
vdim(j);
@expansion{} 63

// For a better representation normalize the long coefficients
// of the polynomial j[2] and map it  to real:
poly p=-(1/12103947791971846719838321886393392913750065060875)*j[2];
ring R1=real,(x,y),lp;
poly p=imap(R0,p);
p;
@expansion{} -xy8
@expansion{} +2.366e-02y38
@expansion{} +2.640e-01y37
@expansion{} -4.745e-06y36
@expansion{} -1.370e-04y35
@expansion{} -1.760e-03y34
@expansion{} -1.505e-01y33
@expansion{} +3.884e-07y32
@expansion{} +1.117e-05y31
@expansion{} +3.200e-04y30
@expansion{} -1.095e-01y29
@expansion{} -1.320e+00y28
@expansion{} +2.170e-05y27
@expansion{} +6.267e-04y26
@expansion{} +7.170e-03y25
@expansion{} +4.582e-01y24
@expansion{} +1.576e-06y23
@expansion{} -4.532e-05y22
@expansion{} -1.301e-03y21
@expansion{} +1.168e-01y20
@expansion{} +1.711e+00y19
@expansion{} +2.255e-05y18
@expansion{} -6.519e-04y17
@expansion{} -5.251e-03y16
@expansion{} +1.826e+00y14
@expansion{} -1.222e+00y10

// Compute a standard basis for the deformed ideal:
setring R0;
j = std(i2);
@expansion{} v13.s14(2)s15.s16.19-s.s20.s21.23-
@expansion{} product criterion:3 chain criterion:7
j;
@expansion{} j[1]=y16
@expansion{} j[2]=-729xy8+1331y14-891y10
@expansion{} j[3]=5x4+3x2y9+y9
vdim(j);
@expansion{} 40
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Parameters, T1 and T2, Long coefficients, Examples
@end ifset
@ifclear singularmanual
@node Parameters, Deformations, Saturation, Examples
@end ifclear
@section Parameters
@cindex Parameters

@ifset singularmanual
Let us now deform the above ideal by introducing a parameter t
and compute over the ground field Q(t).
We compute the dimension at the generic point,
@end ifset
@ifclear singularmanual
Let us now deform a given 0-dimensional ideal j by introducing a parameter t
and compute over the ground field Q(t).
We compute the dimension at the generic point, 
@end ifclear
i.e.
@tex
$dim_{Q(t)}Q(t)[x,y]/j$.
@end tex
@ifinfo
dim_Q(t) Q(t)[x,y]/j.
@end ifinfo
@ifset singularmanual
(This gives the
same result as for the deformed ideal above. Hence, the above small
deformation was "generic".)
@end ifset

For almost all 
@tex
$a \in Q$
@end tex
@ifinfo
a in Q
@end ifinfo
this is the same as 
@tex
$dim_Q Q[x,y]/j_0$,
@end tex
@ifinfo
dim_Q Q[x,y]/j0,
@end ifinfo
where
@tex
$j_0=j|_{t=a}$.
@end tex
@ifinfo
j_0=j_t=a
@end ifinfo

@example
@c example
  ring Rt = (0,t),(x,y),lp;
  Rt;
  poly f = x5+y11+xy9+x3y9;
  ideal i = jacob(f);
  ideal j = i,i[1]*i[2]+t*x5y8;  // deformed ideal, parameter t
  vdim(std(j));
  ring R=0,(x,y),lp;
  ideal i=imap(Rt,i);
  int a=random(1,30000);
  ideal j=i,i[1]*i[2]+a*x5y8;  // deformed ideal, fixed integer a
  vdim(std(j));
@c example
@end example

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node T1 and T2, Deformations, Parameters, Examples
@section T1 and T2
@cindex T1
@cindex T2

T1 resp. T2 of an ideal j do usually denote the vector spaces of
infinitesimally deformations resp. of obstructions.
In @sc{Singular} there are procedures @code{T1} and @code{T2} in
@code{sing.lib} to compute this.
@code{T1(j)} and @code{T2(j)} compute a standard basis of
a presentation of these modules.
A basis of the vectorspaces T1 resp. T2 is computed by applying @code{kbase}:
@code{kbase(T1(j));} resp. @code{kbase(T2(j));}, the dimensions by
applying @code{vdim}.
For a complete intersection j the procedure @code{Tjurina} also
computes T1, but faster (T2=0 in this case).
For a non complete intersection, it is faster to use the procedure @code{T12}
instead of @code{T1} and @code{T2}.
Type @code{help T1;} (or @code{help T2;} or @code{help T12;}) to obtain
more detailed information about these procedures.

We give three examples, the first being a hypersurface, the second a complete
intersection, the third no complete intersection:
@itemize @bullet
@item
load @code{sing.lib}
@item
check wether the ideal j is a complete intersection. It is, if
     number of variables = dimension + minimal number of generators
@item
compute the Tjurina number
@item
compute a vectorspace basis (kbase) of T1
@item
compute the Hilbert function of T1
@item
create a polynomial encoding the Hilbert series
@item
compute the dimension of T2
@end itemize

@example
@c example
  LIB "sing.lib";
  ring R=32003,(x,y,z),ds;
  // ---------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  tjurina(f);
  kbase(Tjurina(f));
  // Tjurina number = 8
  // ---------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  dim(std(j));          // Krull dimension
  size(minbase(j));     // minimal number of generators
  tjurina(j);           // Tjurina number
  module T=Tjurina(j);
  kbase(T);             // a sparse output of the k-basis of T1
  print(kbase(T));      // columns of matrix are a k-basis of T1
  // ---------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);   // 2x2 minors of matrix m
  module M=T1(i);       // a presentation matrix of T1
  vdim(M);              // Tjurina number
  hilb(M);              // display of both Hilbert series
  intvec v1=hilb(M,1);  // first Hilbert series as intvec
  intvec v2=hilb(M,2);  // second Hilbert series as intvec
  v1;
  v2;
  v1[3];                // 3-rd coefficient of the 1-st Hilbert series
  module N=T2(i);
@c example
@end example
@example
// In some cases it might be useful to have a polynomial in some ring
// encoding the Hilbert series. This polynomial can then be
// differentiated, evaluated etc. It can be done as follows:
ring H = 0,t,ls;
poly h1;
int ii;
for (ii=1; ii<=size(v1); ii=ii+1)
@{
   h1=h1+v1[ii]*t^(ii-1);
@}
h1;                   // 1-st Hilbert series
@expansion{} 4-20t+40t2-40t3+20t4-4t5
diff(h1,t);           // differentiate  h1
@expansion{} -20+80t-120t2+80t3-20t4
subst(h1,t,1);        // substitute t by 1
@expansion{} 0

// The procedures T1, T2, T12 may be called with two arguments and then
// they return a list with more information (type help T1; etc.)
// e.g. T12(i,<any>); returns a list with 9 nonempty objects where
// _[1] = std basis of T1-module, _[2] = std basis of T2-module,
// _[3]= vdim of T1, _[4]= vdim of T2
setring r1;           // make r1 again the basering
list L = T12(i,1);
@expansion{} // dim T1  =  4
@expansion{} // dim T2  =  3
kbase(L[1]);          // kbase of T1
@expansion{} _[1]=1*gen(2)
@expansion{} _[2]=1*gen(3)
@expansion{} _[3]=1*gen(6)
@expansion{} _[4]=1*gen(7)
kbase(L[2]);          // kbase of T2
@expansion{} _[1]=1*gen(6)
@expansion{} _[2]=1*gen(8)
@expansion{} _[3]=1*gen(9)
L[3];                 // vdim of T1
@expansion{} 4
L[4];                 // vdim of T2
@expansion{} 3
@end example
@c killall();            // a procedure from general.lib
@c @expansion{} // ** killing the basering for level 0
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Deformations, Finite fields, T1 and T2, Examples
@end ifset
@ifclear singularmanual
@node Deformations, Elimination, Parameters, Examples
@end ifclear
@section Deformations
@cindex Deformations

@itemize @bullet
@item
The libraries @code{sing.lib} resp. @code{deform.lib} contain procedures
to compute the miniversal (= semiuniversal deformation) of an
isolated complete intersection singularity resp. arbitrary isolated
singularity.
@item
The procedure @code{deform} in @code{sing.lib} returns a matrix whose columns
represent a basis of 1-st order miniversal deformations.
@item
The procedure @code{versal} in @code{deform.lib} computes a formal
miniversal deformation up to a certain order which can be
prescribed by the user. For a complete intersection the 1-st order
part is already miniversal.
@item
The procedure @code{versal} extends the basering to a new ring with
additional deformation parameters which contains the equations for the
miniversal base space and the miniversal total space.
@item
There are default names for the objects created, but the user may also
choose his own names.
@item
If the user sets @code{printlevel=2;} before running @code{versal}, some
intermediate results are shown. This is useful since @code{versal}
is already complicated and since it might run quite long on more
complicated examples. (type @code{help versal;})
@end itemize

@ifset singularmanual
We compute for the same examples as in the preceeding section
the miniversal deformations:
@end ifset
@ifclear singularmanual
We give three examples, the first being a hypersurface, the second a 
complete intersection, the third no complete intersection and compute
in each of the cases the miniversal deformation:
@end ifclear

@example
@c example
  LIB "deform.lib";
  ring R=32003,(x,y,z),ds;
  //----------------------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  print(deform(f));
  // the miniversal deformation of f=0 is the projection from the
  // miniversal total space to the miniversal base space:
  // { (A,B,C,D,E,F,G,H,x,y,z) | x3+y3+xyz+z4+A+Bx+Cxz+Dy+Eyz+Fz+Gz2+Hz3 =0 }
  //  --> { (A,B,C,D,E,F,G,H) }
  //----------------------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  print(deform(j));
  versal(j);                  // using default names
  setring Px;
  show(Px);                   // show is a procedure from inout.lib
  listvar(ideal);
  // ___ Equations of miniversal base space ___:
  Js;
  // ___ Equations of miniversal total space ___:
  Fs;
  // the miniversal deformation of V(j) is the projection from the
  // miniversal total space to the miniversal base space:
  // { (A,B,C,D,E,F,x,y,z) | xy+A+Bz=0, y2+z2+x3+C+Dx+Ex2+Fy=0 }
  //  --> { (A,B,C,D,E,F) }
  //----------------------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);                 // 2x2 minors of matrix m
  int time=timer;
  // Def_r is the name of the miniversal base space with
  // parameters A(1),...,A(4)
  versal(i,0,"Def_r","A(");
  "// used time:",timer-time,"sec";   // time for miniversal
  // the miniversal deformation of V(i) is the projection from the
  // miniversal total space to the miniversal base space:
  // { (A(1..4),x,y,z,u,v) |
  //         -y^2+x*z+A(2)*x-A(3)*y=0, -y*z+x*u-A(1)*x-A(3)*z=0,
  //         -y*u+x*v-A(3)*u-A(4)*z=0, -z^2+y*u-A(1)*y-A(2)*z=0,
  //         -z*u+y*v-A(2)*u-A(4)*u=0, -u^2+z*v+A(1)*u-A(4)*v=0 }
  //  --> { A(1..4) |
  //         -A(1)*A(4) = A(3)*A(4) = -A(2)*A(4)-A(4)^2 = 0 }
  //----------------------------------------------------
@c example
@end example
@c  killall(); // proc from general.lib, kills all user-defined variables


@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Finite fields, Elimination, Deformations, Examples
@section Finite fields
@cindex Finite fields

We define a variety in @math{n}-space of codimension 2 defined by
polynomials of degree @math{d} with generic coefficients over the prime
field @math{Z/p} and look for zeroes on the torus. First over the prime
field and then in the finite extension field with
@tex
$p^k$
@end tex
@ifinfo
p^k
@end ifinfo
elements.
In general there will be many more solutions in the second case.
(Since the @sc{Singular} language is interpreted, the evaluation of many
@code{for}-loops is not very fast):

@example
@c example
  int p=3;  int n=3;  int d=5; int k=2;
  ring rp = p,(x(1..n)),dp;
  int s = size(maxideal(d));
  s;
  // create a dense homogeneous ideal m, all generators of degree d, with
  // generic (random) coefficients:
  ideal m = maxideal(d)*random(p,s,n-2);
  m;
  // look for zeroes on the torus by checking all points (with no component 0)
  // of the affine n-space over the field with p elements :
  ideal mt;
  int i(1..n);                    // initialize integers i(1),...,i(n)
  int l;
  s=0;
  for (i(1)=1;i(1)<p;i(1)=i(1)+1)
  {
    for (i(2)=1;i(2)<p;i(2)=i(2)+1)
    {
      for (i(3)=1;i(3)<p;i(3)=i(3)+1)
      {
        mt=m;
        for (l=1;l<=n;l=l+1)
        {
          mt=subst(mt,x(l),i(l));
        }
        if (size(mt)==0)
        {
          "solution:",i(1..n);
          s=s+1;
        }
      }
    }
  }
  "//",s,"solutions over GF("+string(p)+")";
  // Now go to the field with p^3 elements:
  // As long as there is no map from Z/p to the field with p^3 elements
  // implemented, use the folowing trick: convert the ideal to be maped
  // to the new ring to a string and then execute that string in the
  // new ring
  string ms="ideal m="+string(m)+";";
  ms;
  // define a ring rpk with p^k elements, call the primitive element z. Hence
  // 'solution exponent: 0 1 5' means that (z^0,z^1,z^5) is a solution
  ring rpk=(p^k,z),(x(1..n)),dp;
  rpk;
  execute ms;
  s=0;
  ideal mt;
  for (i(1)=0;i(1)<p^k-k;i(1)=i(1)+1)
  {
    for (i(2)=0;i(2)<p^k-k;i(2)=i(2)+1)
    {
      for (i(3)=0;i(3)<p^k-k;i(3)=i(3)+1)
      {
        mt=m;
        for (l=1;l<=n;l=l+1)
        {
          mt=subst(mt,x(l),z^i(l));
        }
        if (size(mt)==0)
        {
          "solution exponent:",i(1..n);
          s=s+1;
        }
      }
    }
  }
  "//",s,"solutions over GF("+string(p^k)+")";
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Elimination, Free resolution, Finite fields, Examples
@end ifset
@ifclear singularmanual
@node Elimination, Free resolution, Deformations, Examples
@end ifclear
@section Elimination
@cindex Elimination

Elimination is the algebraic counterpart of the geometric concept of
projection. If
@tex
$f=(f_1,\ldots,f_n):k^r\rightarrow k^n$
@end tex
@ifinfo
f=(f1,...,fn) : k^r --> k^n
@end ifinfo
is a polynomial map,
the Zariski-closure of the image is the zero-set of the ideal
@tex
$$
\displaylines{
j=J \cap k[x_1,\ldots,x_n], \;\quad\hbox{\rm where}\cr
J=(x_1-f_1(t_1,\ldots,t_r),\ldots,x_n-f_n(t_1,\ldots,t_r))\subseteq
k[t_1,\ldots,t_r,x_1,\ldots,x_n]
}
$$
@end tex
@ifinfo

@example
        j = J intersected with K[x1,...,xn]
J=(x1-f1(t1,...,tr),...,xn-fn(t1,...,tr)) in k[t1,...tr,x1,...,xn]
@end example

@end ifinfo
i.e of the ideal j obtained from J by eliminating the variables
@tex
$t_1,\ldots,t_r$.
@end tex
@ifinfo
t1,...,tr.
@end ifinfo
This can be done by computing a standard basis of J with respect to a product
ordering where the block of t-variables comes before the block of
x-variables and then selecting those polynomials which do not contain
any t. In @sc{Singular} the most convenient way is to use the
@code{eliminate} command.
In contrast to the first method, with @code{eliminate} the result need not be a
standard basis in the given ordering.
Hence, there may be cases where the first method is to be preferred.

@strong{WARNING:} In the case of a local or a mixed ordering, elimination needs special
care. f may be considered as a map of germs
@tex
$f:(k^r,0)\rightarrow(k^n,0)$,
@end tex
@ifinfo
f : (k^r,0) --> (k^n,0),
@end ifinfo
but even
if this map germ is finite, we are in general not able to compute the image
germ because for this we would need an implementation of the Weierstrass
preparation theorem. What we can compute, and what @code{eliminate} actually does,
is the following. Let V(J) be the zero-set of J in
@tex
$k^r\times(k^n,0)$,
@end tex
@ifinfo
k^r x (k^n,0),
@end ifinfo
then the
closure of the image of V(J) under the projection
@tex
$$\hbox{pr}:k^r\times(k^n,0)\rightarrow(k^n,0)$$
can be computed.
@end tex
@ifinfo
@*           pr:  k^r x (k^n,0) --> (k^n,0)
@*can be computed.
@end ifinfo
Note that this germ contains also those components
of V(J) which meet the fibre of pr but not necessarily in the origin.
This is achieved by an ordering with the block of t-variables having a
global ordering (and coming before the x-variables) and the x-variables having
a local ordering. In a local situation we propose @code{eliminate} with
ordering ls.

In any case, if the input is weighted homogeneous (=quasihomogeneous),
the variables should be given the correct weights.
@sc{Singular} offers a function @code{weight} which proposes,
given an ideal or module, integer weights for the variables, such that
the ideal resp. module is as homogeneous as possible with respect to these weights.
The function finds correct weights, if the input is weighted homogeneous
(but is rather slow for many variables). In order to check, whether the
input is quasihomogeneous, use the function @code{qhweight}, which returns
an intvec of correct weights if the input is quasihomogeneous and an intvec
of zeroes otherwise.

Let us give two examples:
@enumerate
@item
First we compute the equations of the simple space curve
@tex
$\hbox{T}[7]^\prime$
@end tex
@ifinfo
T[7]'
@end ifinfo
   consisting of two tangential cusps given in parametric form.
@item
We compute weights for the equations and check that the
   equations are quasihomogeneous with these weights.
@item
Then we compute the tangent developable of the rational
   normal curve in
@tex
$P^4$.
@end tex
@ifinfo
P^4.
@end ifinfo
@end enumerate

@example
@c example
  // 1. Compute equations of curve given in parametric form:
  // Two transversal cusps in (k^3,0):
  ring r1 = 0,(t,x,y,z),ls;
  ideal i1 = x-t2,y-t3,z;        // parametrization of the first branch
  ideal i2 = y-t2,z-t3,x;        // parametrization of the second branch
  ideal j1 = eliminate(i1,t);
  j1;                            // equations of the first branch
  ideal j2 = eliminate(i2,t);
  j2;                            // equations of the second branch
  // Now map to a ring with only x,y,z as variables and compute the
  // intersection of j1 and j2 there:
  ring r2 = 0,(x,y,z),ds;
  ideal j1= imap(r1,j1);         // imap is a convenient ringmap for
  ideal j2= imap(r1,j2);         // inclusions and projections of rings
  ideal i = intersect(j1,j2);
  i;                             // equations of both branches
  //
  // 2. Compute the weights:
  intvec v= qhweight(i);         // compute weights
  v;
  //
  // 3. Compute the tangent developable
  // The tangent developable of a projective variety given parametrically
  // by F=(f1,...,fn) : P^r --> P^n is the union of all tangent spaces
  // of the image. The tangent space at a smooth point F(t1,...,tr)
  // is given as the image of the tangent space at (t1,...,tr) under
  // the tangent map (affine coordinates)
  //   T(t1,...,tr): (y1,...,yr) --> jacob(f)*transpose((y1,...,yr))
  // where jacob(f) denotes the jacobian matrix of f with respect to the
  // t's evaluated at the point (t1,...,tr).
  // Hence we have to create the graph of this map and then to eliminate
  // the t's and y's.
  // The rational normal curve in P^4 is given as the image of
  //        F(s,t) = (s4,s3t,s2t2,st3,t4)
  // each component being homogeneous of degree 4.
  ring P = 0,(s,t,x,y,a,b,c,d,e),dp;
  ideal M = maxideal(1);
  ideal F = M[1..2];     // take the 1-st two generators of M
  F=F^4;
  // simplify(...,2); deletes 0-columns
  matrix jac = simplify(jacob(F),2);
  ideal T = x,y;
  ideal J = jac*transpose(T);
  ideal H = M[5..9];
  ideal i = H-J;         // this is tricky: difference between two
                         // ideals is not defined, but between two
                         // matrices. By automatic type conversion
                         // the ideals are converted to matrices,
                         // subtracted and afterwards converted
                         // to an ideal. Note that '+' is defined
                         // and adds (concatenates) two ideals
  i;
  // Now we define a ring with product ordering and weights 4
  // for the variables a,...,e.
  // Then we map i from P to P1 and eliminate s,t,x,y from i.
  ring P1 = 0,(s,t,x,y,a,b,c,d,e),(dp(4),wp(4,4,4,4,4));
  ideal i = fetch(P,i);
  ideal j= eliminate(i,stxy);    // equations of tangent developable
  j;
  // We can use the product ordering to eliminate s,t,x,y from i
  // by a std-basis computation.
  // We need proc 'nselect' from elim.lib.
  LIB "elim.lib";
  j = std(i);                    // compute a std basis j
  j = nselect(j,1,4);            // select generators from j not
  j;                             // containing variable 1,...,4
@c example
@end example
@c  killall();


@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Free resolution, Ext, Elimination, Examples
@end ifset
@ifclear singularmanual
@node Free resolution, Formatting output, Elimination, Examples
@end ifclear
@section  Free resolution
@cindex  Free resolution

In @sc{Singular} a free resolution of a module or ideal has its own type:
resolution. It is a structure that stores all information related to
free resolutions. This allows partial computations of resolutions via
the command @code{res}. After applying @code{res}, only a pre-format of the
resolution is computed which allows to determine invariants like
Betti-numbers or homological dimension. To see the differentials 
of the complex, a resolution must be converted into the type list which 
yields a list of modules: the k-th module in this
list is the first syzygy-module (module of relations) of the (k-1)st module.
There are the following commands to compute a resolution:
@table @code
@item res
@ifset singularmanual
@ref{res}@*
@end ifset
computes a free resolution of an ideal or module using a heuristically
chosen method.
This is the prefered method to compute free resolutions of ideals or
modules.
@item lres
@ifset singularmanual
@ref{lres}@*
@end ifset
computes a free resolution of an ideal or module with LaScala's
method. The input needs to be homogeneous.
@item mres
@ifset singularmanual
@ref{mres}@*
@end ifset
computes a minimal free resolution of an ideal or module with the Syzygy
method.
@item sres
@ifset singularmanual
@ref{sres}@*
@end ifset
computes a free resolution of an ideal or module with Schreyer's
method. The input has to be a standard basis.
@item nres
@ifset singularmanual
@ref{nres}@*
@end ifset
computes a free resolution of an ideal or module with the standard basis
method. 
@item minres
minimizes a free resolution of an ideal or module.
@item syz
@ifset singularmanual
@ref{syz}@*
@end ifset
computes the first Syzygy (i.e., the module of relations of the
given generators).
@end table
@code{res(i,r)}, @code{lres(i,r)}, @code{sres(i,r)}, @code{mres(i,r)},
@code{nres(i,r)} compute the first r modules of the resolution
of i, resp. the full resolution if r=0 and the basering is not a qring.
See the the manual for a precise description of these commands.
@*Note: The command @code{betti} does not require a minimal
resolution for the minimal betti numbers.

Now let's look at an example which uses resolutions: The Hilbert-Burch
theorem says that the ideal i of a reduced curve in
@tex
$K^3$
@end tex
@ifinfo
K^3
@end ifinfo
has a free resolution of length 2 and that i is given by the 2x2 minors
of the 2nd matrix in the resolution.
We test this for the two transversal cusps in
@tex
$K^3$.
@end tex
@ifinfo
K^3.
@end ifinfo
Afterwards we compute the resolution of the ideal j of the tangent developable
of the rational normal curve in
@tex
$P^4$
@end tex
@ifinfo
P^4
@end ifinfo
from above.
Finally we demonstrate the use of the type resolution in connection with
the lres command.

@example
@c example
  // Two transversal cusps in (k^3,0):
  ring r2 =0,(x,y,z),ds;
  ideal i =z2-1y3+x3y,xz,-1xy2+x4,x3z;
  resolution rs=mres(i,0);   // computes a minimal resolution
  rs;                        // the standard representation of complexes
    list resi=rs;            // convertion to a list
  print(resi[1]);            // the 1-st module is i minimized
  print(resi[2]);            // the 1-st syzygy module of i
  resi[3];                   // the 2-nd syzygy module of i
  ideal j=minor(resi[2],2);
  reduce(j,std(i));          // check whether j is contained in i
  size(reduce(i,std(j)));    // check whether i is contained in j
  // size(<ideal>) counts the non-zero generators
  // ---------------------------------------------
  // The tangent developable of the rational normal curve in P^4:
  ring P = 0,(a,b,c,d,e),dp;
  ideal j= 3c2-4bd+ae, -2bcd+3ad2+3b2e-4ace,
           8b2d2-9acd2-9b2ce+9ac2e+2abde-1a2e2;
  resolution rs=mres(j,0);
  rs;
  list L=rs;
  print(L[2]);
  // create an intmat with graded betti numbers
  intmat B=betti(rs);
  // this gives a nice output of betti numbers
  print(B,"betti");
  // the user has access to all betti numbers
  // the 2-nd column of B:
  B[1..4,2];
  ring cyc5=32003,(a,b,c,d,e,h),dp;
  ideal i=
  a+b+c+d+e,
  ab+bc+cd+de+ea,
  abc+bcd+cde+dea+eab,
  abcd+bcde+cdea+deab+eabc,
  h5-abcde;
  resolution rs=lres(i,0);   //computes the resolution according LaScala
  rs;                        //the shape of the minimal resolution
  print(betti(rs),"betti");  //shows the Betti-numbers of cyclic 5
  dim(rs);                   //the homological dimension
  size(list(rs));            //gets the full (non-reduced) resolution
  minres(rs);                //minimizes the resolution
  size(list(rs));            //gets the minimized resolution
@c example
@end example


@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Ext, Polar curves, Free resolution, Examples
@section  Ext
@cindex  Ext

We start by showing how to calculate the @math{n}-th Ext group of an
ideal. The ingredients to do this, are by the definition of Ext the
following: calculate a (minimal) resolution at least up to length
@math{n}, apply the Hom-functor, and calculate the @math{n}-th Homology
group, so form the quotient
@tex
$\hbox{\rm ker} / \hbox{\rm Im}$
@end tex
@ifinfo
ker/Im
@end ifinfo
in the resolution sequence.

The Hom functor is given simply by transposing (hence dualizing) the
module or the corresponding matrix with the command @code{transpose}.
The image of the @math{n-1}-st map is generated by the columns of the
corresponding matrix. To calculate the kernel apply the command
@code{syz} at the @math{n-1}-st transposed entry of the resolution.
Finally, the quotient is obtained by the command @code{modulo}, which
gives for two modules A = ker, B = Im the module of relations of
@tex
$A/(A \cap B)$
@end tex
@ifinfo
A/(A intersect B)
@end ifinfo
in the usual way. As we have a chain complex this is obviously the same
as ker/Im.

We collect these statements in this short procedure.

@example
proc ext(int n, ideal I)
@{
  resolution rs = mres(I,n+1);
  module tAn    = transpose(rs[n+1]);
  module tAn_1  = transpose(rs[n]);
  module ext_n  = modulo(syz(tAn),tAn_1);
  return(ext_n);
@}
@end example

Now consider the following example:

@example
ring r5 = 32003,(a,b,c,d,e),dp;
ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
print(ext(2,I));
@expansion{} 1,0,0,0,0,0,0,
@expansion{} 0,1,0,0,0,0,0,
@expansion{} 0,0,1,0,0,0,0,
@expansion{} 0,0,0,1,0,0,0,
@expansion{} 0,0,0,0,1,0,0,
@expansion{} 0,0,0,0,0,1,0,
@expansion{} 0,0,0,0,0,0,1
ext(3,I);   // too big to be displayed here
@end example

The library @code{homolog.lib} contains several procedures for computing
Ext-modules and related modules, which are much more general and
sophsticated then the above one. They are used in the following
example.

If @math{M} is a module, then
@tex
$\hbox{Ext}^1(M,M)$ resp.\ $\hbox{Ext}^2(M,M)$
@end tex
@ifinfo
Ext^1(M,M) resp. Ext^2(M,M)
@end ifinfo
are the modules of infinitesimal deformations resp.@: of obstructions of
@math{M} (like T1 and T2 for a singularity).  Similar to the treatment
for singularities, the semiuniversal deformation of @math{M} can be
computed (if
@tex
$\hbox{Ext}^1$
@end tex
@ifinfo
Ext^1
@end ifinfo
is finite dimensional) with the help of
@tex
$\hbox{Ext}^1$, $\hbox{Ext}^2$
@end tex
@ifinfo
Ext^1, Ext^2
@end ifinfo
and the cup product. There is an extra procedure for
@tex
$\hbox{Ext}^k(R/J,R)$
@end tex
@ifinfo
Ext^k(R/J,R)
@end ifinfo
if @math{J} is an ideal in @math{R} since this is faster than the
general Ext.

We compute
@itemize @bullet
@item
the infinitesimal deformations
@tex
($=\hbox{Ext}^1(K,K)$)
@end tex
@ifinfo
(=Ext^1(K,K))
@end ifinfo
and obstructions
@tex
($=\hbox{Ext}^2(K,K)$)
@end tex
@ifinfo
(=Ext^2(K,K))
@end ifinfo
of the residue field @math{K=R/m} of an ordinary cusp,
@tex
R=Loc$_K[x,y]/(x^2-y^3)$, m=($x,y$).
@end tex
@ifinfo
R=Loc_K[x,y]/(x^2-y^3), m=(x,y).
@end ifinfo
For
@tex
$\hbox{Ext}^1(m,m)$
@end tex
@ifinfo
Ext^1(m,m),
@end ifinfo
here we have to compute @code{Ext(1,syz(m),syz(m))} with
@code{syz(m)} the first syzygy module of @math{m}, which is isomorphic to
@tex
$\hbox{Ext}^2(K,K)$.
@end tex
@ifinfo
Ext^2(K,K).
@end ifinfo
@item
@tex
$\hbox{Ext}^k(R/i,R)$
@end tex
@ifinfo
Ext^k(R/i,R)
@end ifinfo
for some ideal @math{i} and with an extra option
@end itemize

@example
@c example
  LIB "homolog.lib";
  ring R=0,(x,y),ds;
  ideal i=x2-y3;
  qring q = std(i);          // defines the quotient ring Loc_k[x,y]/(x2-y3)
  ideal m = maxideal(1);
  module T1K = Ext(1,m,m);   // computes Ext^1(R/m,R/m)
  print(T1K);
  printlevel=2;              // gives more explanation
  module T2K=Ext(2,m,m);     // computes Ext^2(R/m,R/m)
  print(std(T2K));
  printlevel=0;
  module E = Ext(1,syz(m),syz(m));
  print(std(E));
  //We see from the matrices that T2K and E are isomorphic
  //as it should be; but both are differently presented
  //-------------------------------------------
  ring S=0,(x,y,z),dp;
  ideal  i = x2y,y2z,z3x;
  module E = Ext_R(2,i);
  print(E);
  // if a 3-rd argument is given (of any type)
  // a list of Ext^k(R/i,R), a SB of Ext^k(R/i,R) and a vector space basis
  // is returned:
  list LE = Ext_R(3,i,"");
  LE;
  print(LE[2]);
  print(kbase(LE[2]));
@c example
@end example
@c  killall();
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Polar curves, Depth, Ext, Examples
@section   Polar curves
@cindex Polar curves

The polar curve of a hypersurface given by a polynomial
@tex
$f\in k[x_1,\ldots,x_n,t]$
@end tex
@ifinfo
f in k[x1,...,xn,t]
@end ifinfo
with respect to @math{t} (we may consider @math{f=0} as a family of
hypersurfaces parametrized by @math{t}) is defined as the Zariski
closure of
@tex
$V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n) \setminus V(f)$
@end tex
@ifinfo
V(diff(f,x1),...,diff(f,xn)) \ V(f)
@end ifinfo
if this happens to be a curve.  Some authors consider
@tex
$V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n)$
@end tex
@ifinfo
V(diff(f,x1),...,diff(f,xn))
@end ifinfo
itself as polar curve.

We may consider projective hypersurfaces
@tex
(in $P^n$),
@end tex
@ifinfo
(in P^n),
@end ifinfo
affine hypersurfaces
@tex
(in $k^n$)
@end tex
@ifinfo
(in k^n)
@end ifinfo
or germs of hypersurfaces
@tex
(in $(k^n,0)$),
@end tex
@ifinfo
(in (k^n,0)),
@end ifinfo
getting in this way
projective, affine or local polar curves.

We shall compute now this for a family of curves.  We need the library
@code{elim.lib} for saturation and @code{sing.lib} for the singular
locus.

@example
@c example
  LIB "elim.lib";
  LIB "sing.lib";
  // Affine polar curve:
  ring R = 0,(x,z,t),dp;              // global ordering dp
  poly f = z5+xz3+x2-tz6;
  dim_slocus(f);                      // dimension of singular locus
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // dim V(j)
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
  // j defines a curve, but to get the polar curve we must remove the
  // branches contained in f=0 (they exist since dim V(j,f) = 1). This
  // gives the polar curve set theoretically. But for the structure we
  // may take either j:f or j:f^k for k sufficiently large. The first is
  // just the ideal quotient, the second the iterated ideal quotient
  // or saturation. In our case both is the same.
  ideal q = quotient(j,ideal(f));     // ideal quotient
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  ideal sq = std(q);
  dim(sq);
  // 1-dimensional, hence q defines the affine polar curve
  //
  // to check that q and qsat are the same, we show both inclusions, i.e.
  // both reductions must give the 0-ideal
  size(reduce(qsat,sq));
  size(reduce(q,std(qsat)));
  qsat;
  // We see that the affine polar curve does not pass through the origin,
  // hence we expect the local polar "curve" to be empty
  // ------------------------------------------------
  // Local polar curve:
  ring r = 0,(x,z,t),ds;              // local ordering ds
  poly f = z5+xz3+x2-tz6;
  dim_slocus(f);                      // dimension of singular locus
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j) 1-dimensional
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
  ideal q = quotient(j,ideal(f));     // ideal quotient
  q;
  // The local polar "curve" is empty, i.e V(j) is contained in V(f)
  // ------------------------------------------------
  // Projective polar curve: (we need "sing.lib" and "elim.lib")
  ring P = 0,(x,z,t,y),dp;            // global ordering dp
  poly f = z5+xz3+x2-tz6;
  f = z5y+xz3y2+x2y4-tz6;             // homogenize f with respect to y
                                      // but consider t as parameter
  dim_slocus(f);              // projective 1-dimensional singular locus
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j), projective 1-dimensional
  dim(std(j+ideal(f)));               // V(j,f) also projective 1-dimensional
  ideal q = quotient(j,ideal(f));
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  dim(std(qsat));
  // projective 1-dimensional, hence q and/or qsat define the projective
  // polar curve. In this case, q and qsat are not the same, we needed
  // 2 quotients.
  // Let us check both reductions:
  size(reduce(qsat,std(q)));
  size(reduce(q,std(qsat)));
  // Hence q is contained in qsat but not conversely
  q;
  qsat;
  //
  // Now consider again the affine polar curve,
  // homogenize it with respect to y (deg t=0) and compare:
  // affine polar curve:
  ideal qa = 12zt+3z-10,5z2+12xt+3x,-144xt2-72xt-9x-50z;
  // homogenized:
  ideal qh = 12zt+3z-10y,5z2+12xyt+3xy,-144xt2-72xt-9x-50z;
  size(reduce(qh,std(qsat)));
  size(reduce(qsat,std(qh)));
  // both ideals coincide
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Depth, Formatting output, Polar curves, Examples
@section Depth
@cindex Depth

We compute the depth of the module of Kaehler differentials
@tex
D$_k$(R)
@end tex
@ifinfo
D_k(R)
@end ifinfo
of the variety defined by the @math{(m+1)}-minors of generic symmetric
nxn matrix.  We do this by computing the resolution over the polynomial
ring.  Then, by the Auslander-Buchsbaum formula, the depth is equal to
the number of variable minus the length of a minimal resolution.  This
example was suggested by U.@: Vetter in order to check wheter his bound
@tex
$\hbox{depth}(\hbox{D}_k(R))\geq m(m+1)/2 + m-1$
@end tex
@ifinfo
depth(D_k(R)) >= m(m+1)/2 + m-1
@end ifinfo
could be improved.

@example
@c example
  LIB "matrix.lib"; LIB "sing.lib";
  int n = 4;
  int m = 3;
  int N = n*(n+1)/2;           // will become number of variables
  ring R = 32003,x(1..N),dp;
  matrix X = symmat(n);        // proc from matrix.lib
                               // creates the symmetric generic nxn matrix
  print(X);
  ideal J = minor(X,m);
  J=std(J);
  // Kaehler differentials D_k(R)
  // of R=k[x1..xn]/J:
  module D = J*freemodule(N)+transpose(jacob(J));
  ncols(D);
  nrows(D);
  //
  // Note: D is a submodule with 110 generators of a free module
  // of rank 10 over a polynomial ring in 10 variables.
  // Compute a full resolution of D with sres.
  // This takes about 17 sec on a Mac PB 520c and 2 sec an a HP 735
  int time = timer;
  module sD = std(D);
  list Dres = sres(sD,0);                // the full resolution
  timer-time;                            // time used for std + sres
  intmat B = betti(Dres);
  print(B,"betti");
  N-ncols(B)+1;                          // the desired depth
@c example
@end example
@c  killall();
@end ifset

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Formatting output, Cyclic roots, Depth, Examples
@end ifset
@ifclear singularmanual
@node Formatting output, Factorization, Free resolution, Examples
@end ifclear
@section Formatting output
@cindex Formatting output

We show how to insert the result of a computation inside a text
by using strings.
First we compute the powers of 2 and comment the result with some text.
Then we do the same and give the output a nice format by computing and
adding appropriate space.

@example
@c example
  // The powers of 2:
  int  n;
  for (n = 2; n <= 128; n = n * 2)
  {"n = " + string (n);}
  // The powers of 2 in a nice format
  int j;
  string space = "";
  for (n = 2; n <= 128; n = n * 2)
  {
    space = "";
    for (j = 1; j <= 5 - size (string (n)); j = j+1)
    { space = space + " "; }
    "n =" + space + string (n);
  }
@c example
@end example

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Cyclic roots, G_a -Invariants, Formatting output, Examples
@section Cyclic roots
@cindex Cyclic roots

We write a procedure returning a string that enables us to automatically
create the ideal of cyclic roots over the basering with n variables. The
procedure assumes that the variables consist of a single letter each
(hence no indexed variables are allowed; the procedure @code{cyclic} in
@code{poly.lib} does not have this restriction). Then we compute a
standard basis of this ideal and some numerical information.  (This
ideal is used as a classical benchmark for standard basis computations).

@example
// We call the procedure 'cyclic':
proc cyclic (int n)
@{
   string vs = varstr(basering)+varstr(basering);
   int c=find(vs,",");
   while ( c!=0 )
   @{
      vs=vs[1,c-1]+vs[c+1,size(vs)];
      c=find(vs,",");
   @}
   string t,s;
   int i,j;
   for ( j=1; j<=n-1; j=j+1 )
   @{
      t="";
      for ( i=1; i <=n; i=i+1 )
      @{
         t = t + vs[i,j] + "+";
      @}
      t = t[1,size(t)-1] + ","+newline;
      s=s+t;
   @}
   s=s+vs[1,n]+"-1";
   return (s);
@}

ring r=0,(a,b,c,d,e),lp;         // basering, char 0, lex ordering
string sc=cyclic(nvars(basering));
sc;                              // the string of the ideal
@expansion{} a+b+c+d+e,
@expansion{} ab+bc+cd+de+ea,
@expansion{} abc+bcd+cde+dea+eab,
@expansion{} abcd+bcde+cdea+deab+eabc,
@expansion{} abcde-1
execute("ideal i="+sc+";");      // this defines the ideal of cyclic roots
i;
@expansion{} i[1]=a+b+c+d+e
@expansion{} i[2]=ab+bc+cd+ae+de
@expansion{} i[3]=abc+bcd+abe+ade+cde
@expansion{} i[4]=abcd+abce+abde+acde+bcde
@expansion{} i[5]=abcde-1
timer=1;
ideal j=std(i);
@expansion{} //used time: 7.5 sec
size(j);                         // number of elements in the std basis
@expansion{} 11
degree(j);
@expansion{} // codimension = 5
@expansion{} // dimension   = 0
@expansion{} // degree      = 70
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node G_a -Invariants, Invariants of a finite group, Cyclic roots, Examples
@section G_a -Invariants
@cindex G_a -Invariants

We work in characteristic 0 and use the Lie algebra generated by one
vectorfield of the form
@tex
$\sum x_i \partial /\partial x_{i+1}$.
@end tex
@ifinfo
sum x(i)*d/dx(i+1).
@end ifinfo
@example
@c example
  LIB "invar.lib";
  int n=5;
  int i;
  ring s=32003,(x(1..n)),wp(1,2,3,4,5);
  // definition of the vectorfield m=sum m[i,1]*d/dx(i)
  matrix m[n][1];
  for (i=1;i<=n-1;i=i+1)
  {
     m[i+1,1]=x(i);
  }
  // computation of the ring of invariants
  ideal in=invariantRing(m,x(2),x(1));
  in;   //invariant ring is generated by 5 invariants
  ring q=32003,(x,y,z,u,v,w),dp;
  matrix m[6][1];
  m[2,1]=x;
  m[3,1]=y;
  m[5,1]=u;
  m[6,1]=v;
  // the vectorfield is: xd/dy+yd/dz+ud/dv+vd/dw
  ideal in=invariantRing(m,y,x);
  in; //invariant ring is generated by 6 invariants
@c example
@end example
@c kill n,i,s,q;
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Invariants of a finite group, Factorization, G_a -Invariants, Examples
@section Invariants of a finite group
@cindex Invariants of a finite group

Two algorithms to compute the invariant ring are implemented in
@sc{Singular}, @code{invariant_ring} and @code{invariant_ring_random},
both by Agnes E. Heydtmann (@code{agnes@@math.uni-sb.de}):

Bases of homogeneous invariants are generated successively and those are
chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1997) to appear in JSC).  In the
non-modular case secondary invariants are calculated by finding a basis
(in terms of monomials) of the basering modulo the primary invariants,
mapping to invariants with the Reynolds operator and using those or
their power products such that they are linearly independent modulo the
primary invariants (see paper "Some Algorithms in Invariant Theory of
Finite Groups" by Kemper and Steel (1997)).  In the modular case they
are generated according to "Generating Invariant Rings of Finite Groups
over Arbitrary Fields" by Kemper (1996, to appear in JSC).

We calculate now an example from Sturmfels: "Algorithms in Invariant
Theory 2.3.7":

@example
@c example
  LIB "finvar.lib";
  ring R=0,(x,y,z),dp;
  matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
  // the group G is generated by A in Gl(3,Q);
  print(A);
  // the fourth power of A is 1:
  print(A*A*A*A); // the fourth power of A is 1
  // Use the first method to compute the invariants of G:
  matrix B(1..3);
  B(1..3)=invariant_ring(A);
  // SINGULAR returns 2 matrices, the first containing
  // primary invariants and the second secondary
  // invariants, i.e. module generators over a Noetherian
  // normalization
  // the third result are the irreducible secondary invariants
  // if the Molien series was available
  print(B(1));
  print(B(2));
  print(B(3));
  // Use the second method,
  // with using random numbers between -1 and 1:
  B(1..3)=invariant_ring_random(A,1);
  print(B(1..3));
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Factorization, Puiseux pairs, Invariants of a finite group, Examples
@end ifset
@ifclear singularmanual
@node Factorization, Kernel of module homomorphisms, Formatting output, Examples
@end ifclear
@section Factorization
@cindex Factorization

The factorization of polynomials is implemented in the C++ libraries
Factory (written mainly by Ruediger Stobbe) and libfac (written by
Michael Messollen) which are part of the @sc{Singular} system.

@example
@c example
  ring r = 0,(x,y),dp;
  poly f = 9x16-18x13y2-9x12y3+9x10y4-18x11y2+36x8y4
         +18x7y5-18x5y6+9x6y4-18x3y6-9x2y7+9y8;
  // = 9 * (x5-1y2)^2 * (x6-2x3y2-1x2y3+y4)
  factorize(f);
  // returns factors and multiplicities,
  // first factor is a constant.
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
  // The same in characteristic 2:
  ring r =2,(x,y),dp;
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
@c example
@end example

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Puiseux pairs, Primary decomposition, Factorization, Examples
@section Puiseux pairs
@cindex Puiseux pairs

The Puiseux pairs of an irreducible and reduced curve singularity are
its most important invariants.  They can be computed from its
Hamburger-Noether expansion.  The library @code{hnoether.lib} written by
Martin Lamm uses the algorithm of Antonio Campillo "Algebroid curves in
positive characteristic" SLN 813, 1980.  This algorithm has the
advantage that it needs least possible field extensions and, moreover,
works in any characteristic. This fact can be used to compute the
invariants over a field of finite characteristic, say 32003, which will
then be most probably be the same in characteristic 0.

We compute the Hamburger-Noether expansion of some plane curve
singularities given by a polynomial @math{f} in two variables. This is a
matrix which allows to compute the parametrization (up to a given order)
and all numerical invariants like
@itemize @bullet
@item
    characteristic exponents
@item
    puiseux pairs (of a complex model)
@item
    degree of the conductor
@item
    delta invariant
@item
    generators of semigroup
@end itemize
Besides this, the library contains procedures to compute the Newton
polygon of @math{f}, the squarefree part of @math{f} and a procedure to
convert one set of invariants to another.


@example
@c example
  LIB "hnoether.lib";
  // ======== The irreducible case ========
  ring s = 0,(x,y),ds;
  poly f = y4-2x3y2-4x5y+x6-x7;
  list hn = develop(f);
  show(hn[1]);     // Hamburger-Noether matrix
  displayHNE(hn);  // Hamburger-Noether development
  setring s;
  displayInvariants(hn);
  // invariants(hn);  returns the invariants as list
                   // partial parametrization of f
                   // param takes the first variable as
  param(hn);       // except the ring has >2 variables
  ring extring=0,(x,y,t),ds;
  poly f=x3+2xy2+y2;
  list hn=develop(f,-1);
  param(hn);       // partial parametrization of f
  list hn1=develop(f,6);
  param(hn1);     // a better parametrization
  // instead or recomputing you may extend the development:
  list hn2=extdevelop(hn,12);
  param(hn2);     // a still better parametrization
  // ======== The reducible case ========
  ring r = 0,(x,y),dp;
  poly f=x11-2y2x8-y3x7-y2x6+y4x5+2y4x3+y5x2-y6;
  // = (x5-1y2) * (x6-2x3y2-1x2y3+y4)
  list hn=reddevelop(f);
  show(hn[1][1]);     // Hamburger-Noether matrix of 1st brach
  displayInvariants(hn);
  param(hn[2]);      // parametrization of 2nd branch
  // extended parametrization of 1st
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Primary decomposition, Normalization, Puiseux pairs, Examples
@section Primary decomposition
@cindex Primary decomposition

There are two algorithms implemented in @sc{Singular} which provide
primary decomposition: @code{primdecGTZ}, based on
Gianni/Trager/Zacharias (written by Gerhard Pfister) and
@code{primdecSY}, based on Shimoyama/Yokoyama (written by Wolfram Decker
and Hans Schoenemann).

The result of primdecGTZ is returned as a list of ideals,
where the even indexed ideals form the prime ideal and the odd indexed
ideals form the corresponding primary ideal.

The result of primdecSY is a list of list-tupels of ideals,
the primary ideal and the corresponding prime ideal.

@example
@c example
  LIB "primdec.lib";
  ring r = 0,(a,b,c,d,e,f),dp;
  ideal i= f3, ef2, e2f, bcf-adf, de+cf, be+af, e3;
  primdecGTZ(i);
  // We consider now the ideal J of the base space of the
  // miniversal deformation of the cone over the rational
  // normal curve computed in section *11* and compute
  // its primary decomposition.
  ring R = 0,(A,B,C,D),dp;
  ideal J = CD, BD+D2, AD;
  primdecGTZ(J);
  // We see that there are two components which are both
  // prime, even linear subspaces, one 3-dimensional,
  // the other 1-dimensional.
  // (This is Pinkhams example and was the first found
  // surface singularity with two components of
  // different dimensions)
  //
  // Let us now produce an embedded component in the last
  // example, compute the minimal associated primes and
  // the radical. We use the Characteristic set methods
  // from prim_dec.lib.
  J = intersect(J,maxideal(3));
                     //shows that the maximal ideal is
  primdecSY(J);      //embedded (takes a few seconds)
  minAssChar(J);
  radical(J);
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Normalization, Kernel of module homomorphisms, Primary decomposition, Examples
@section Normalization
@cindex Normalization
The normalization will be computed for a reduced ring @math{R/I}. The
result is a list of rings; ideals are always called @code{KK} in the
rings of this list. The normalization of @math{R/I} is the product of
the factor rings of the rings in the list divided out by the ideals
@code{KK}.

@example
@c example
  LIB "normal.lib";
  // ----- first example: rational quadruple point -----
  ring R=32003,(x,y,z),wp(3,5,15);
  ideal I=z*(y3-x5)+x10;
  list pr=normal(I);
  def S=pr[1];
  setring S;
  KK;
  // ----- second example: union of straight lines -----
  ring R1=0,(x,y,z),dp;
  ideal I=(x-y)*(x-z)*(y-z);
  list qr=normal(I);
  def S1=qr[1]; def S2=qr[2]; def S3=qr[3];
  setring S1; KK;
  setring S2; KK;
  setring S3; KK;
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Kernel of module homomorphisms, Algebraic dependence, Normalization, Examples
@end ifset
@ifclear singularmanual
@node Kernel of module homomorphisms, Algebraic dependence, Factorization, Examples
@end ifclear
@section Kernel of module homomorphisms
@cindex Kernel of module homomorphisms
Let @math{A}, @math{B} two matrices of size
@tex
$m\times r$ and $m\times s$
@end tex
@ifinfo
m x r and m x s
@end ifinfo
over the ring @math{R} and consider the corresponding maps
@tex
$$
R^r \buildrel{A}\over{\longrightarrow}
R^m \buildrel{B}\over{\longleftarrow} R^s\;.
$$
@end tex
@ifinfo

@example
   r   A     m
  R  -----> R
            ^
            |
            |
             s
            R  .
@end example

@end ifinfo
We want to compute the kernel of the map
@tex
$R^r \buildrel{A}\over{\longrightarrow}
R^m\longrightarrow
R^m/\hbox{Im}(B) \;.$
@end tex
@ifinfo

@example
   r   A     m         m
  R  -----> R  -----> R /Im(B) .
@end example

@end ifinfo
This can be done using the @code{modulo} command:
@tex
$$
\hbox{\tt modulo}(A,B)=\hbox{ker}(R^r
\buildrel{A}\over{\longrightarrow}R^m/\hbox{Im}(B)) \; .
$$
@end tex
@ifinfo

@example
                   r   A     m
  modulo(A,B)=ker(R  -----> R /Im(B))  .
@end example

@end ifinfo

@example
@c example
  ring r=0,(x,y,z),(c,dp);
  matrix A[2][2]=x,y,z,1;
  matrix B[2][2]=x2,y2,z2,xz;
  modulo(A,B);
@c example
@end example

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Algebraic dependence, Classification, Kernel of module homomorphisms, Examples
@end ifset
@ifclear singularmanual
@node Algebraic dependence,  , Kernel of module homomorphisms, Examples
@end ifclear
@section Algebraic dependence
@cindex Algebraic dependence
Let
@tex
$g$, $f_1$, \dots, $f_r\in K[x_1,\ldots,x_n]$.
@end tex
@ifinfo
g, f_1, @dots{}, f_r in K[x1,@dots{},xn].
@end ifinfo
We want to check whether
@enumerate
@item
@tex
$f_1$, \dots, $f_r$
@end tex
@ifinfo
f_1, @dots{}, f_r
@end ifinfo
are algebraically dependent.

Let
@tex
$I=\langle Y_1-f_1,\ldots,Y_r-f_r \rangle \subseteq
K[x_1,\ldots,x_n,Y_1,\ldots,Y_r]$.
@end tex
@ifinfo

@example
I=<Y_1-f_1,@dots{},Y_r-f_r> subset K[x1,@dots{},xn,Y_1,@dots{},Y_r].
@end example

@end ifinfo
Then
@tex
$I \cap K[Y_1,\ldots,Y_r]$
@end tex
@ifinfo
I intersected with K[Y_1,@dots{},Y_r]
@end ifinfo
are the algebraic relations between
@tex
$f_1$, \dots, $f_r$.
@end tex
@ifinfo
f_1, @dots{}, f_r.
@end ifinfo

@item
@tex
$g \in K [f_1,\ldots,f_r]$.
@end tex
@ifinfo
g in K[f_1,@dots{},f_r].
@end ifinfo

@tex
$g \in K[f_1,\ldots,f_r]$
@end tex
@ifinfo
g in K[f_1,@dots{},f_r]
@end ifinfo
if and only if the normalform of @math{g} with respect to @math{I} and a
blockordering with respect to
@tex
$X=(x_1,\ldots,x_n)$ and $Y=(Y_1,\ldots,Y_r)$ with $X>Y$
@end tex
@ifinfo
X=(x1,@dots{},xn) and Y=(Y_1,@dots{},Y_r) with X>Y
@end ifinfo
is in @math{K[Y]}. Then
@tex
$g=h(f_1,\ldots,f_r)$.
@end tex
@ifinfo
g=h(f_1,@dots{},f_r).
@end ifinfo
@end enumerate

Both questions can be answered using the following procedure. If the
second argument is zero, it checks for algebraic dependence and returns
the ideal of relations between the generators of the given ideal.
Otherwise it checks for subring membership and returns the normal form 
of the second argument with respect to the ideal I.

@example
@c example
  proc algebraicDep(ideal J, poly g)
  {
    def R=basering;         // give a name to the basering
    int n=size(J);
    int k=nvars(R);
    int i;
    intvec v;
  
    // construction of the new ring
  
    v[n+k]=0;               // construct a weight vector
    for(i=1;i<=k;i++)
    {
      v[i]=1;
    }
    string orde="(a("+string(v)+"),dp);";
    string ri="ring Rhelp=("+charstr(R)+"),
                          ("+varstr(R)+",Y(1.."+string(n)+")),"+orde;
                            // ring definition as a string
    execute(ri);            // execution of the string
  
    // construction of the new ideal I=(J[1]-Y(1),...,J[n]-y(n))
    ideal I=imap(R,J);
    for(i=1;i<=n;i++)
    {
      I[i]=I[i]-var(k+i);
    }
    poly g=imap(R,g);
    if(g==0)
    {
      // construction of the ideal of relations by elimination
      poly el=var(1);
      for(i=2;i<=k;i++)
      {
        el=el*var(i);
      }
      ideal KK=eliminate(I,el);
      keepring(Rhelp);
      return(KK);
    }
    // reduction of g with respect to I
    ideal KK=reduce(g,std(I));
    keepring(Rhelp);
    return(KK); 
  }

  // applications of the procedure
  ring r=0,(x,y,z),dp;
  ideal i=xz,yz;
  algebraicDep(i,0);
  setring r; kill Rhelp;
  ideal j=xy+z2,z2+y2,x2y2-2xy3+y4;
  algebraicDep(j,0);
  setring r; kill Rhelp;
  poly g=y2z2-xz;
  algebraicDep(i,g);
  setring r; kill Rhelp;
  algebraicDep(j,g);
@c example
@end example

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Classification, Fast lexicographical GB, Algebraic dependence, Examples
@section Classification
@cindex Classification

Classification of isolated hypersurface singularities with respect to
right equivalence is provided by the command @code{classify} of the
library @code{classify.lib}. The classification is done using the
algorithm of Arnold. Before entering this algorithm, a first guess based
on the Hilbert polynomial of the Milnor algebra is made.

@example
@c example
  LIB "classify.lib";
  ring r=0,(x,y,z),ds;
  poly p=singularity("E[6k+2]",2)[1];
  p=p+z^2;
  p;
  // We received a E_14 singularity in normal form
  // from the database of normal forms. Since only the residual
  // part is saved in the database, we added z^2 to get an E_14
  // of embedding dimension 3.
  //
  // Now we apply a coordinate change in order to deal with a
  // singularity which is not in normal form:
  map phi=r,x+y,y+z,x;
  poly q=phi(p);
  // Yes, q really looks ugly, now:
  q;
  // Classification
  classify(q);
  // The library also provides routines to determine the corank of q
  // and its residual part without going through the whole
  // classification algorithm.
  corank(q);
  morsesplit(q);
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Fast lexicographical GB, Parallelization with MPtcp links, Classification, Examples
@section Fast lexicographical GB
@cindex Fast lexicographical GB

Compute Groebner basis in lexicographical ordering
by using FGLM algorithm (@code{stdfglm})
and Hilbert driven Groebner (@code{stdhilb}).

The command @code{stdfglm} works only for zero dimensional ideals and
returns a reduced Groebner basis.

For the ideal below, @code{stdfglm} is more than 100 times
and @code{stdhilb} about 10 times faster than std.

@example
@c example
  ring r =32003,(a,b,c,d,e),lp;
  ideal i=a+b+c+d, ab+bc+cd+ae+de, abc+bcd+abe+ade+cde,
          abc+abce+abde+acde+bcde, abcde-1;
  int t=timer;
  ideal j1=stdfglm(i);
  timer-t;
  size(j1);   // size (no. of polys) in computed GB
  t=timer;
  ideal j2=stdhilb(i);
  timer-t;
  size(j2);   // size (no. of polys) in computed GB
  // usual Groebner basis computation for lex ordering
  t=timer;
  ideal j0 =std(i);
  timer-t;
@c example
@end example
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node  Parallelization with MPtcp links,  , Fast lexicographical GB, Examples
@section Parallelization with MPtcp links
@cindex Parallelization
@cindex MPtcp
@cindex link
In this example, we demonstrate how MPtcp links can be used to
parallelize computations.

To compute a standard base for a zero-dimensional ideal in the
lexicographical ordering, one of the two powerful routines
@code{stdhilb}
@ifset singularmanual
(see @ref{stdhilb})s
@end ifset
and @code{stdfglm}
@ifset singularmanual
(see @ref{stdfglm})
@end ifset
should be used. However, one can not a priory predict
which one the two commands is faster. This very much depends on the
(input) example. Therefore, we use MPtcp links to let the two commands
work on the problem independently and in parallel, so that the one which
finishes first delivers the result.

The example we use is the so-called "omndi example". See @i{Tim
Wichmann; Der FGLM-Algorithmus: verallgemeinert und implementiert in
Singular; Diplomarbeit Fachbereich Mathematik, Universitaet
Kaiserslautern; 1997} for more details.

@example
@c example
ring r=0,(a,b,c,u,v,w,x,y,z),lp;
ideal i=a+c+v+2x-1, ab+cu+2vw+2xy+2xz-2/3,  ab2+cu2+2vw2+2xy2+2xz2-2/5,
ab3+cu3+2vw3+2xy3+2xz3-2/7, ab4+cu4+2vw4+2xy4+2xz4-2/9, vw2+2xyz-1/9,
vw4+2xy2z2-1/25, vw3+xyz2+xy2z-1/15, vw4+xyz3+xy3z-1/21;

link l_hilb,l_fglm = "MPtcp:fork","MPtcp:fork";         // 1.

open(l_fglm); open(l_hilb);

write(l_hilb, quote(system("pid")));                    // 2.
write(l_fglm, quote(system("pid")));
int pid_hilb,pid_fglm = read(l_hilb),read(l_fglm);

write(l_hilb, quote(stdhilb(i)));                       // 3.
write(l_fglm, quote(stdfglm(eval(i))));

while ((! status(l_hilb, "read", "ready", 1)) &&        // 4.
       (! status(l_fglm, "read", "ready", 1))) {}

if (status(l_hilb, "read", "ready"))
{
  "stdhilb won !!!!"; size(read(l_hilb));
  close(l_hilb); pid_fglm = system("sh","kill "+string(pid_fglm));
}
else                                                    // 5.
{
  "stdfglm won !!!!"; size(read(l_fglm));
  close(l_fglm); pid_hilb = system("sh","kill "+string(pid_hilb));
}
@c example
@end example
Some explainatory remarks are in order:
@enumerate
@item
Instead of using links of the type @code{MPtcp:fork}, we alternatively
could use @code{MPtcp:launch} links such that the two "competing"
@sc{Singular} processes run on different machines. This has the
advantage of "true" parallel computing since no resource sharing is
involved (as it usually is with forked processes).

@item
Unfortunately, MPtcp links do not offer means to (asynchronously)
interrupt or kill an attached (i.e., launched or forked)
process. Therefore, we explicitely need to get the process id numbers of
the competing @sc{Singular} processes, so that we can later "kill" the
looser.

@item
Notice how quoting is used in order to prevent local evaluation
(i.e., local computation of results). Since we "forked" the two
competing processes, the identifier @code{i} is defined and has
identical values in the two child processes. Therefore, the innermost
@code{eval} can be ommited (as is done for the @code{l_hilb} link),
and only the identifier @code{i} needs to be communicated to the
children. However, when @code{MPtcp:launch} links are used, the inner
evaluation must be applied so that actual values, and not the
identifiers are communicated (as is done for the @code{l_fglm} link).

@item
We go into a "sleepy" loop and wait until one of the two children
finished the computation. That is, the current process checks appr. once
a per second the status of one of the connecting links, and sleeps
(i.e., suspends its execution) in the intermediate time.

@item
The child which won delivers the result and is terminated with the usual
@code{close} command. The other child which is still computing needs to
be terminated by an explicit (i.e., system) kill command, since it can
not be terminated through the link while it is still computing.
@end enumerate
@end ifset

@c --------------------------------------------------------------------
@ifclear singularmanual
@section Further examples

The example section of the @sc{Singular} manual contains further examples,
e.g.:
@itemize @bullet
@item Long coefficients
@*how they arise in innocent examples
@item T1 and T2
@*compute first order deformations and obstructions
@item Finite fields
@*compute in fields with 
@tex
$q=p^n$
@end tex
@ifinfo
q=p^n
@end ifinfo
elements
@item Ext
@*compute Ext groups, derived from the Hom functor
@item Polar curves
@*compute local and global polar curves
@item Depth
@*various ways to compute the depth of a module
@item Cyclic roots
@*create and compute with this standard benchmark example
@item Invariants of finite group
@*compute invariant rings for finite group
@item Puiseux pairs
@*compute Puiseux development and invariants with the
Hamburger-Noether method
@item Primary decomposition
@*compute primar decomposition of an ideal
@item Normalization
@*compute the normalization of a ring
@item Classification
@*determine type and normal form of a hypersurface singularity
after Arnold
@item Fast lexicographical GB
@*FGLM and Hilbert-driven Groebner
@item Parallelization with MPtcp links
@*use MP for distributed and parallel computation
@end itemize

In this list the names of the items are the names of the 
examples in the online help system. So by the command 
@code{help T1 and T2} the example about the computation of
first order deformations and obstructions is displayed.
@end ifclear
















