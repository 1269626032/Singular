@comment -*-texinfo-*-
@comment $Id: general.doc,v 1.22 1998-05-04 17:19:45 Singular Exp $
@comment this file contains the general information about Singular

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-b).
@c @setfilename general.info
@c @node Top, General concepts
@c @menu
@c * General concepts::     
@c @end menu
@c @node General concepts, Data types, Introduction, Top
@c @chapter General concepts


@menu
* Interactive use::             
* Rings and orderings::         
* Implemented algorithms::      
* The SINGULAR language::       
* Procedures::
* Libraries::
* Debugging tools::
@end menu


@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@node Interactive use, Rings and orderings, General concepts, General concepts
@section Interactive use
@cindex Interactive use

@menu
* How to enter and exit::       
* SINGULAR prompt and error recovery::  
* The online help system::      
* Interrupting SINGULAR::       
* Editing input::               
* Control parameters::          
* Startup sequence::            
* Reuse of output::             
* Commandline options::         
@end menu

@c --------------------------------------------------------------------------
@c @node How to enter and exit -- command line options,General syntax,,Command Syntax
@node How to enter and exit,SINGULAR prompt and error recovery  , Interactive use, Interactive use
@subsection How to enter and exit
@cindex How to enter and exit

@*To start @sc{Singular}, enter @code{Singular} at the system prompt.
@*You will get a header with the version name, the compilation date
and a short remark how to get help on
@sc{Singular}.
Enter @code{help;} to get the online manual at the @sc{Singular} prompt
@code{>}.
Commands are always ended with a @code{;} (semicolon) and @code{<ENTER>}.
Spaces and commas are always considered as separators. 
@*To exit @sc{Singular} enter @code{quit;}, @code{exit;} or @code{$}.


@sc{Singular} may also be started with command-line options and with 
filenames as arguments. More generally, the synopsis of @sc{Singular} is
@*@code{  Singular  [options] [file1 [file2 ...]] }

@ref{Commandline options}
@menu
* Commandline options::
@end menu

@*On start-up, @sc{Singular} 
@enumerate
@item 
loads the library @code{standard.lib} (provided the @code{--no-stdlib}
was not given)

@item
searches the current directory and then the
home directory of the user for a file named @code{.singularrc} and
executes it, if found (provided the @code{--no-rc} options was not
given)

@item 
executes the files @code{file1}, @code{file2} ...  (given on the command
line) in that order. 
@end enumerate

Unless otherwise specified, @sc{Singular} locates all (data) files and
libraries by first searching for them in the current working directory,
and then by searching through all the directories specified by the
environment variable @code{SINGULARPATH} (@code{SPATH} on DOS-based
systems) and finally by searching through some default directories
(e.g., @code{/usr/local/share/Singular}).

@c --------------------------------------------------------------------------
@node SINGULAR prompt and error recovery,The online help system,How to enter and exit, Interactive use
@subsection SINGULAR prompt and error recovery
@cindex SINGULAR prompt and error recovery
@cindex prompt
@cindex error recovery
The @sc{Singular} prompt @code{>}
asks the user for input of a command, while the prompt @code{.}
asks the user for input of missing parts of a command (remember the
semicolon @code{;} at the end of every command). If your input
is erroneous @sc{Singular} may miss the semicolon.
(It may be missed because @sc{Singular} needs first a @code{"} or @code{@}}.)
On the other hand additional @code{;} will not harm @sc{Singular}:
extra semicolons are interpreted as empty statements.

@c --------------------------------------------------------------------------
@node The online help system,Interrupting SINGULAR,SINGULAR prompt and error recovery,Interactive use
@subsection The online help system
@cindex The online help system

@sc{Singular} uses @code{info} (from @code{texinfo}) for it's help system.@*
The whole manual is decomposed into "nodes" of information.
A node contains text describing a specific topic at a specific level of
detail. The top line of a node is its "header".  This node's header
(the upper most line) tells the name of this node (@code{Node:}),
the name of the next node (@code{Next:}),
the name of the previous node (@code{Prev:}),
and the name of an "Up" node (@code{Up:}).

To move within info type commands of single characters and do not type a RETURN
character. The most important commands:
@table @asis
@item @code{q} 
leave info
@item @code{n}
go to the "next" node
@item @code{p}
go to the "previous" node
@item @code{u}
go to the "up" node
@item @code{m}
pick a menu item specified by name. Reads name of menu entry
@item @code{f}
follow a cross reference.  Reads name of reference
@item @code{l}
go to the previous visited node
@item @code{h}
help about info (use @code{l} to come back)
@item @code{b}
go to the begining of the current node
@item @code{e}
go to the end of the current node
@item SPACE
scroll forward a page
@item DEL
scroll backward a page
@item @code{s}
search through this Info file for a specified string,
and select the node in which the next occurrence is found
@end table
@c --------------------------------------------------------------------------
@node Interrupting SINGULAR,Editing input,The online help system,Interactive use
@subsection Interrupting SINGULAR
@cindex Interrupting SINGULAR

@c --------------------------------------------------------------------------
@node Editing input,Control parameters,Interrupting SINGULAR,Interactive use
@subsection Editing input
@cindex Editing input

If the command line option @code{-t} is not given,
@sc{Singular} redefines the terminal characteristics
@footnote{
therefore the comandline option @code{-t} must be given if @sc{Singular} should
run in the background
}
and the following keys can be used for editing
the input and retrieving previous input lines
(CTL denotes the control key):
@table @kbd
@item CTL-A
go to the start of the line
@item CTL-B
go one character to the left
@item CTL-D
erase the character under the cursor
(or return @kbd{EOF}, if the current line is empty)
@item CTL-E
goto to the end of the line
@item CTL-F
go one character to the right
@item BACKSPACE
@itemx DELETE
@itemx CTL-H
erase the character before the cursor
@item CTL-K
kill the rest of the line
@item CTL-N
save the current line to the history and get the next line
@item CTL-P
save the current line to the history and get the previous line
@item CTL-U
kill the whole line
@item RETURN
save the current line to the history and
send it to the @sc{Singular} parser for interpretation
@end table
@* @strong{Remark:}
@c @* There is a history of the last 32 unique lines.
@* This section does not apply to the MPW-Macintosh version of
@sc{Singular}.
@* This section describes only a subset of the key bindings of
@sc{Singular}s built with @code{readline}. See the @code{readline} manual
for the key bindings.

@c --------------------------------------------------------------------------
@node Control parameters, Startup sequence, Editing input, Interactive use
@subsection Control parameters
@cindex Control parameters

You may wish to set some control parameters. Most often used are
@code{timer}, @code{option(prot)} and @code{pagewidth}.

@itemize @bullet
@item
If @code{timer} is set to 1 the time (in sec) used for the execution of
a command
is displayed if it is bigger than 0.5 sec (Unix: CPU-time
or Macintosh/MSDOS: time between two commands).
@item
@code{option(prot)} shows a short protocol during std-computation: the
number between brackets () is the number of critical pairs still
to be reduced (except immediatly after an H 'high corner' where it shows the
degree above which all monomials can be discarded), a - sign indicates
that one critical pair has been reduced (either to 0 or to a new
s-polynomial which indicated by an s), a number without brackets
shows the degree in which the computation takes place (this is in
particular useful if the input is homogeneous).
There are many more options, mostly used to control the strategies
for the std-computations, see the manual or type @code{help option;}.
@item
@code{pagewidth} sets the number of characters in a line printed on the
screen.
@item
@code{option} also controls messages like warnings, loading libs, etc.
@xref{option}, or type @code{help verbose;}.
@end itemize

@example
pagewidth = 80;        // set pagewidth to 80 characters
option(prot);          // short protocoll
timer = 1;             // activate the timer
option(noredefine);   // supress redefine-warnings
@end example

It is useful to have a file say, init, in which your preferred
parameters are set. Such a file could also contain the commands
for loading those libraries which you usually use. If you start
by typing '@code{Singular init}' the @code{init} file and hence all commands
contained in @code{init} are executed.

@c --------------------------------------------------------------------------
@node Startup sequence, Reuse of output, Control parameters, Interactive use
@subsection Startup sequence
@cindex Startup sequence

@c --------------------------------------------------------------------------
@node Reuse of output, Commandline options, Startup sequence, Interactive use
@subsection Reuse of output
@cindex Reuse of output

The most recently printed expression is available
under the special name @code{_}, e.g.
@example
@c example
  ring r;
  ideal i=x2+y3,y3+z4;
  std(i);
  ideal k=_;
  k*k+x;
  size(_[3]);
@c example
@end example

@c --------------------------------------------------------------------------
@node Commandline options, ,Reuse of output,Interactive use
@subsection Commandline options
@cindex Commandline options

The synopsis of @sc{Singular} is

@*@code{  Singular  [options] [file1 [file2 ...]] }

@*with the options (which can be given in both, their long and
short format):
@table @asis

@item @code{-b},@code{--batch} 
Run in MP batch mode. Opens a TCP/IP connection with host specified by
@code{--MPhost} at the port specified by @code{--MPport}. Input is read
from and output is written to this connection in the MP format.

@item @code{-h},@code{--help} 
Print a short help message and exit.

@item @code{-q},@code{--quiet}
Do not print start-up banner and warnings and redirect stderr (all error
messages)  to stdout (normal output channel).

@item @code{-t},@code{--no-tty} 
Do not redefine the terminal characteristics (useful for batch
processes, see @ref{Editing input}).  

@item @code{-v},@code{--version}             
Print extended information about the version and configuration of
@sc{Singular}  (used optional parts, compilation date, start of random
generator etc.). This information should be included if a user reports
an error to the authors.

@item @code{-e},@code{--echo[=VAL]} 
Set value of variable @code{echo} to @code{VAL} (integer in the range 0
.. 9). Without an argument, @code{echo} is set to 1, which echoes all
input coming from a file. By default, the value of @code{echo} is 0. See
also @ref{System variables}.

@item @code{-c},@code{--execute=STRING} 
Execute @code{STRING} as a (sequence) of @sc{Singular} commands on
start-up after the @code{.singularrc} file is executed, but prior to
executing the files given on the command line.

@item @code{-r},@code{--random=SEED}         
Seed (i.e., set initial value of) pseudo random generator with integer
(integer) @code{SEED} (integer). If this option is not given, then the
random generated is seeded with a time-based @code{SEED} (e.g., the
number of seconds since January, 1, 1970, on Unix systems).

@item @code{-u},@code{--user-option=STRING}
Returns @code{STRING} on @code{system("--user-option")}. This is useful
for passing arbitrary arguments (like filenames) from the command line to 
the @sc{Singular} interpreter (i.e. top-level of @sc{Singular}).

@item @code{--no-stdlib}
Do not load the library @code{standard.lib} on start-up. By default,
this library is loaded on start-up.

@item @code{--no-rc}               
Do not execute the @code{.singularrc} file on start-up. By default,
@sc{Singular} searches first in the current directory and then in the
home directory of the user for a file named @code{.singularrc}. If it is 
found, then it is executed after the library @code{standard.lib} is
loaded and prior to executing the string specified by
@code{--user-option}.

@item @code{--min-time=SECS}
If the @code{timer} variables is set, do only report times larger than
@code{SECS} seconds (@code{SECS} needs to be a floating point number
greater than 0). By default, this value is set to 0.5 (i.e., half a
second).

@item @code{--MPport=PORT} 
Use @code{PORT} as default port number for MP connections (whenever not
further specified) . This option is mandatory when the @code{--batch}
option is given. See also @ref{MPtcp links}.

@item @code{--MPhost=HOST}
Use @code{HOST} as default host for MP connections (whenever not
further specified) . This option is mandatory when the @code{--batch}
option is given. See also @ref{MPtcp links}.

@item @code{--ticks-per-sec=TICKS} 
Sets unit of timer to @code{TICKS} per second (i.e. the value reported by 
the @code{timer} variable multiplied by @code{TICKS} gives the time in
seconds.By default, this value is 1.

@end table


@c --------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@node Rings and orderings, Implemented algorithms, Interactive use, General concepts
@section Rings and orderings
@cindex Rings and orderings

@menu
* Available rings::             
* General syntax of a ring definition::  
* Term orderings::              
@end menu

@c ---------------------------------------------------------------------------
@node Available rings, General syntax of a ring definition, Rings and orderings, Rings and orderings
@subsection Available rings
@cindex Available rings

Almost all computations in @sc{Singular} require a basering which may be
@itemize @bullet
@item
a polynomial ring
@item
a series ring, i.e a localization of a polynomial ring
@item
a factor ring by an ideal of one of the above
@item
a tensor products of one of the above
@end itemize

Each object of type
@code{map},
@code{matrix},
@code{module},
@code{number},
@code{ideal},
@code{poly},
@code{resolution},
@code{vector}
belongs to a specific ring.
Also @code{list}, if one of the objects belong to a ring.
These objects are local to the ring, hence their names can be used for other
objects in other rings.
Objects from one ring can be mapped to another
ring with an object of type @code{map}
(or with the commands @code{fetch} or @code{imap}).
They are all algebras over the ground
field. Hence, in oder to compute in one of the ground fields,
one has to define a ring (with at least one variable and a monomial
ordering).

The ground field of these algebras may be
@itemize @bullet
@item
the rational numbers Q (char 0)
@item
a finite field Z/p, p a prime <= 32003 (char p)
@item
@tex
a finite field with $q=p^n$ elements ($p^n<=\le 2^{15}$)
@end tex
@ifinfo
a finite field with q=p^n elements (p^n<=2^15)
@end ifinfo
@item
transcendental extension K(A,B,C,...), K=Q or Z/p
@item
algebraic extension K[Z]/MinPol, K=Q or Z/p
@item
floating point real numbers with simple precision (real)
@end itemize

The other types do not belong to a ring and can be accessed within every ring.

@c ---------------------------------------------------------------------------
@node General syntax of a ring definition, Term orderings, Available rings, Rings and orderings
@subsection General syntax of a ring definition
@cindex General syntax of a ring definition


@table @code
@item @strong{Syntax:}
@code{ring} name @code{=} field@code{,}
  @code{(} names_of_ring_variables @code{),}
  @code{(} ordering @code{);}
@item @strong{Default:}
@code{32003,(x,y,z),(dp,C);}
@item @strong{Purpose:}
defines a base ring for polynomials, ideals, vectors, modules, resolutions
and matrices and set it as the actual basering

All advanced algorithms in @sc{Singular} require a ring.
The last defined ring is the basering until a new ring is defined
or until it is changed with @code{setring} or @code{keepring} or
it gets killed.

The coefficient field is given by either
@enumerate
@item
the characteristic (0 or a prime <= 32003)
@item
an expression_list of the characteristic and
the names of  parameters.
If there is only one parameter you may define a minimal polynomial for it
to work in an algebraic extension of Q or F(p).
See @ref{minpoly}
@item
an expression_list of the number of element
(a small prime characteristic p to the power of a small exponent n) and a
name for a primitive element (generating the multiplicative group).
The maximal values for p and n depend on the files in the directory @code{gftables}.
They define the finite field with p^n elements.
@item
the name @code{real}. The field elements will be the machine floating
point numbers.
@end enumerate

@*If you write a  characteristic which is not a prime,
it is automatically converted
to the next lower prime or you receive an error message.

The names of ring variables
are like variable names (comma separated).

The ordering is a list of blockorderings which have an order keyword and
a weight vector or an optional size.

Possible order keywords are:
@itemize @bullet
@item @code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, @code{Ds}, @code{M}
with optional size parameter

@item @code{wp}, @code{Wp}, @code{ws}, @code{Ws}
with weight vector

@item @code{c}, @code{C}
for components orders

@end itemize

If one element of the list consists of only one entry, the parentheses may
be omitted.
@item @strong{Example:}
@example
  ring r =
  32003,       // coefficient field: Z/32003
  ( x,y,z ),   // names for variables
  ds;          // monomial ordering
               // (degrevlex in a series ring)
               // parenthesis of lists with only one element
               // are optional
@end example
@example
  ring r2=10,(x(1..6)),(lp(2),dp(4));
               // defines a ring with name r2,
               // (10 is substituted by the next lower prime)
               // coefficient field: Z/7
               // variables x(1),x(2),..,x(6)
               // which is the polynomial ring (Z/7)[x(1),..,x(6)]
               // with lexicographical ordering on x(1) and x(2)
               // and then
               // degree reverse lexicographical on x(3)..x(6)
@end example
@example
  ring r3=0,(x,y,z,a,b,c),(ds(3), dp(3));
               // defines a ring with name r3,
               // coefficient field Q
               // variables x,y,z,a,b,c
               // which is the ring (Q[a,b,c])[x,y,z]_(x,y,z)
@end example
@example
  ring r4=0,(x,y,z),(c,dp);
               // defines a ring with name r4,
               // coefficient field Q (rationals)
               // variables x,y,z
               // which is the polynomial ring Q[x,y,z]
               // with ordering of vectors by
               // first number of the component and then
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r5=(7,a),(x,y,z),dp;
               // defines a ring with name r5,
               // coefficient field K=(Z/7)(a)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // with ordering
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r6=(7,a),(x,y,z),dp;
  minpoly=a^2+a+3;
               // defines a ring with name r6,
               // coefficient field K=(Z/7)[a]/a^2+a+3
               // (the finite field with 49 elements)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // with ordering
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r7=(7^2,a),(x,y,z),dp;
                // defines a ring with name r7,
                // the same ring as r6
                // this option is offered for
                // a few powers of primes
                // (see file gftable/49)
                // the computations are faster
                // in this representation
@end example
@example
  ring r8=(181,A,B,Z),(x,y,z),dp;
               // defines a ring with name r8
               // coefficient field K=Z/181(A,B,Z)
               // variables x,y,z
               // which is the polynomial ring K[x,y,z]
               // degree reverse lexicographical on x,y,z
@end example
@example
  ring r9=real,(x,y,z),dp;
               // defines a ring with name r9
               // coefficient field R
               // (represented as floating point numbers)
               // variables x,y,z
               // which is the polynomial ring R[x,y,z]
               // degree reverse lexicographical on x,y,z
  number n=1.7e+2; // input format of real numbers
@end example

@item @strong{Note:}
Computations in rings with one parameter are faster
than computations with more parameters. (Cancellation of common factors
are only implemented in the first case)

@* Computation over the field @code{real} has computing errors because
of rounding.
@item @strong{Use in proc:}
All changes of the base ring by a definition
of a new ring or a setring command in a proc are local to this proc
(i.e. will not affect the calling procedure)
unless a @code{keepring} command is used.
@end table
@menu
* ring::
* Term orderings::
* qring:: define quotient rings
* charstr:: the coefficient field
* npars:: number of parameters
* nvars:: number of variables
* ordstr:: the monomial ordering
* parstr:: the parameters
* par:: the parameter as number
* varstr:: the ring variables
* var:: the ring variables as poly
* setring:: a local ring change
* keepring:: ring change in the next (upper) level
@end menu
@iftex
See @ref{ring}; @ref{Term orderings};
@ref{qring}; @ref{charstr}; @ref{npars};
@ref{nvars}; @ref{ordstr};
@ref{varstr}; @ref{var}; @ref{setring}; @ref{keepring}.
@end iftex

@c ---------------------------------------------------------------------------
@node Term orderings, ,General syntax of a ring definition, Rings and orderings
@subsection Term orderings
@cindex Term orderings

The most important term orderings or monomial orderings in @sc{Singular} are:
@*global or p-orderings: @code{lp, dp, wp, Dp, Wp} refer to a polynomial ring,
@*local or s-orderings: @code{ls, ds, ws, Ds, Ws} refer to a series ring,
@*matrix orderings: allow to create any ordering by a matrix,
@*product (or block) orderings of the above.

Given such an ordering say, ord, the ring r created by
@*@center @code{ring r = p,x(1..n),ord;}
@*
@tex
is by definition Loc K$[x_1,...,x_n]$, where K=Z/p and Loc denotes
localization with respect to the muliplicatively closed set
$$\{ 1+f | lead(f) < 1 \}.$$
Here lead means the leading monomial with respect to ord, 1
is the constant monomial 1 and $>$ means bigger with respect to
ord. For global orderings, $x_i > 1$, hence Loc K$[x_1,...,x_n]$ =
K$[x_1,...,x_n]$, for local orderings, $x_i < 1$, hence LocK$[x_1,...,x_n]$ =
Loc$_{(x)}$K[$x_1,...,x_n$] (= localization of K[$x_1,...,x_n$] with
respect to the maximal ideal $(x_1,...,x_n)$).
A product ordering which is for example
of the form (s-ordering(k),p-ordering(l)), n=k+l, (the variables
$x1,...,xk$ being s-ordered, $x_{k+1},...,x_n$ p-ordered) creates
           Loc$_(x)$K[$x_1,...,x_k] \otimes $K[$x_{k+1},...,x_n$].
Many other rings between the polynomial ring and the power
series ring are realized by the choice of an ordering.
@end tex
@ifinfo
is by definition Loc K[x(1),...,x(n)], where K=Z/p and Loc denotes
localization with respect to the muliplicatively closed set
@*@center @{ 1+f | lead(f) < 1 @}.
@*Here lead means the leading monomial with respect to ord, 1
is the constant monomial 1 and > means bigger with respect to
ord. For global orderings, x(i) > 1, hence Loc K[x(1),...,x(n)] =
K[x(1),...,x(n)], for local orderings, x(i) < 1, hence LocK[x(1),...,x(n)] =
Loc_(x)K[x(1),...,x(n)] (= localization of K[x(1),...,x(n)] with respect to the
maximal ideal (x(1),...,x(n))). A product ordering which is for example
of the form (s-ordering(k),p-ordering(l)), n=k+l, (the variables
x(1),...,x(k) being s-ordered, x(k+1),...,x(n) p-ordered) creates
           Loc_(x)K[x(1),...,x(k)] tensor K[x(k+1),...,x(n)].
Many other rings between the polynomial ring and the power
series ring are realized by the choice of an ordering.
@end ifinfo

The great variety of differnt orderings and their efficient
implementation makes @sc{Singular} a powerful tool for many different tasks
in Algebraic Geometry, Algebra and Singularity theory.

On the other hand it requires careful thinking about the 'correct'
ordering for a specific task. Even if the rings are the same,
the result of a standard basis computation depends on the
ordering. For instance, the commands dim, mult, degree, hilb,
etc. compute the dimension, multiplicity, etc. of the ideal
generated by the leading terms of the given generators. In
many cases of interest, e.g. if a degree-ordering is choosen
and if the generators are a standard basis, the computed
result will be the corresponding invariant of the ideal itself.
Nevertheless, it remains the task of the user to give a correct
interpretation of the result.

@iftex
--------------------------------------------------------------------------
@end iftex

@tex
A monomial ordering (term ordering) on $K[x_1, \ldots, x_n]$ is
a total ordering $<$ on the
set of monomials (power products) $\{x^\alpha|\alpha \in \bf{N}^n\}$
which is compatible with the
natural semigroup structure, i.e.\ $x^\alpha < x^\beta$ implies $x^\gamma
x^\alpha < x^\gamma x^\beta$ for any $\gamma \in \bf{N}^n$.
We do not require
$<$ to be  a wellordering.
@end tex
@ifinfo
A monomial ordering (term ordering) on $[x_1, ..., x_n] is
a total ordering < on the
set of monomials (power products) @{x^a | a in N^n@}
which is compatible with the
natural semigroup structure, i.e. x^a < x^b implies x^c*x^a < x^c*x^b for any
c in N^n.
We do not require
< to be  a wellordering.
@end ifinfo
See the literature cited in @ref{Introduction}, (section 'Background').

@sc{Singular} offers the following monomial orderings which are implemented
in an effective way:
@menu
* Global orderings:: lp, dp, wp, Dp, Wp.
* Local orderings:: ls, ds, ws, Ds, Ws.
* Module orderings:: c, C.
* Matrix orderings:: M.
* Product orderings::
* Extra weight vector:: a.
@end menu
@iftex
@itemize @bullet
@item
global orderings or p-orderings: @code{lp, dp, Dp, wp, Wp} (p refers to polynomial ring)
@item
local orderings or s-orderings: @code{ls, ds, Ds, ws, Ws} (s refers to series ring)
@item
module orderings @code{c, C} (ordering of the components of a vector)
@item
matrix orderings @code{M} (may be used to define any allowed ordering)
@item
any of the above orderings may be combined to yield product or
block orderings.
@item
ordering @code{a} (inserting an extra weight vector)
@end itemize
@end iftex

@tex
Global orderings are wellorderings (i.e.\ $1 < x_i$ for each variable
$x_i$), local orderings satisfy $1 > x_i$ for each variable.   If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not wellorderings.

If $K$ is the groundfield, $x = (x_1, \ldots, x_n)$ the
variables and $<$ a monomial ordering, then {\bf Loc K}$[x]$ denotes the
localization of $K[x]$ with respect to the multiplicatively closed set $\{1 +
g \mid g = 0$ or $g \in K[x]\backslash \{0\}$ and $L(g) < 1\}$.   $L(g)$
denotes the leading monomial of $g$, i.e.\ the biggest monomial of $g$ with
respect to $<$.   The result of any computation which uses standard basis
computations has to be interpreted in {\bf Loc K}$[x]$ (like @code{std, syz, res,
mres, sres, mult, degree, dim, hilb, mstd}, etc.).
@end tex
@ifinfo
Global orderings are wellorderings (i.e.1 < x_i for each variable
x_i), local orderings satisfy 1 > x_i for each variable.
If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not wellorderings.

If K is the groundfield, x = (x_1, @dots{}, x_n) the
variables and < a monomial ordering, then Loc K[x] denotes the
localization of K[x] with respect to the multiplicatively closed set @{1 +
g | g = 0 or g in K[x]\@{0@} and L(g) < 1@}.   L(g)
denotes the leading monomial of g, i.e. the biggest monomial of g with
respect to <.   The result of any computation which uses standard basis
computations has to be interpreted in Loc K[x] (like @code{std, syz, res,
mres, sres, mult, degree, dim, hilb, mstd}, etc.).
@end ifinfo


@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@node Implemented algorithms, The SINGULAR language, Rings and orderings, General concepts
@section Implemented algorithms
@cindex Implemented algorithms


The basic algorithm in @sc{Singular} is a general standard basis algorithm for
any monomial ordering which is compatible with the natural semigroup
structure of the exponents. This includes wellorderings (Buchberger algorithm)
and tangent cone orderings (Mora algorithm) as special cases.

Different syzygy algorithms, free resolutions (@code{sres, res, mres}) for computation of free resolutions
of modules over the above rings are implemented.

Combinatorial algorithms for computing dimensions, hilbert series, multiplicities, ... 

An algorithm for uni- and multivariate polynomial factorization.

See the file 'singular_algorithms.tex' for details and further algorithms.

@table @code
@item @strong{Commands to compute standard bases}
@table @asis
@item @code{facstd}
@ref{facstd}
@*computes the a list of Groebner bases via the Factorizing Groebenr Basis Algorithm: the intersection of the zero sets is the zero set of the given ideal
@item @code{fglm}
@ref{fglm}
@*computes the Groebner basis provided that a reduced Groebner basis w.r.t.
another ordering is known
@*The given ideal must be zero-dimensional.
@item @code{std}
@ref{std}
@*computes the standard and Groebner basis
(depending on the @code{ring} definition, see @ref{Rings and orderings}
and the options, see @ref{option})
@item @code{stdfglm}
@ref{stdfglm}
@*computes the Groebner basis in a ring with a "difficult" ordering
(i.e. lexicographical, ...) via @code{std} w.r.t. a "simple" ordering and
@code{fglm}
@*The given ideal must be zero-dimensional.
@item @code{stdhilbert}
@ref{stdhilbert}@*
computes the Groebner basis in a ring with a "difficult" ordering
(i.e. lexicographical, ...) via @code{std} w.r.t. a "simple" ordering and
a @code{std} computation guided by the hilbert series
(see @ref{hilb}, @ref{std})
@end table
@item @strong{Further processing of standard bases}
@table @asis
@item @code{degree}
@ref{degree}@*
computes the (Krull) dimension, codimension and the multiplicity
@item @code{dim}
@ref{dim}@*
computes the dimension of the ideal/module generated by
the leading monomials of the generators representing the given
ideal/module. This is also the dimension of the ideal if it is represented by
a standard basis.
@item @code{mult}
@ref{mult}@*
computes the degree of the monomial ideal/module generated by
the leading monomials of the input.
@item @code{reduce}
@ref{reduce}@*
reduces a polynomial, vector, ideal  or module
to its normal form with respect to an ideal or module represented
by a standard basis.
Return 0 if and only if the polynomial (resp. vector, ideal, module)
is an element (resp. subideal, submodule) of the ideal (resp. module).
@item @code{vdim}
@ref{vdim}@*
computes the vector space dimension of the ring (resp. free module)
modulo the ideal (resp. module)
@end table
@item @strong{Commands to compute resolutions}
@table @asis
@item @code{minres}
@ref{minres}@*
minimizes a free resolution of an ideal or module
@item @code{lres}
@ref{lres}@*
computes a free resolution of an ideal or module with LaScala's
method. The input should to be homogeneous.
@item @code{mres}
@ref{mres}@*
computes a minimal free resolution of an ideal or module
with the syzygy method.
@item @code{res}
@ref{res}@*
computes a free resolution of an ideal or module.
@*Depending on the input, the current ring and the options
@sc{Singular} chooses different algorithms: the syzygy method, Schreyer's method
or LaScala's method.
@item @code{sres}
@ref{sres}@*
computes a free resolution of an ideal or module with Schreyer's
method. The input has to be a standard basis.
@item @code{syz}
@ref{syz}@*
copmutes the first syzygy (i.e. the module of relations of the
given generators)
@end table
@item @strong{Further processing of resolutions}
@table @asis
@item @code{betti}
@ref{betti}@*
compute the graded Betti numbers of a module from a free resolution
@item @code{minres}
@ref{minres}@*
minimizes a free resolution of an ideal or module
@end table
@item @strong{Processing of polynomials}
@table @asis
@item @code{extgcd}
@ref{extgcd}@*
@item @code{factorize}
@ref{factorize}@*
@item @code{gcd}
@ref{gcd}@*
@end table
@end table


@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@node The SINGULAR language, Procedures, Implemented algorithms, General concepts
@section The SINGULAR language
@cindex The SINGULAR language

@sc{Singular} has a comfortable programming language similar to C
with @code{for}, @code{if} ... @code{else}, @code{while}   etc.

It is interpreted. Every user has therefore a convinient way
to write procedures (or libraries) for his own purposes, using
the functions of the kernel of @sc{Singular} and from other libraries.

See the section 'Writing procedures' of the tutorial.

@menu
* General command syntax::      
* Special characters::          
* Names and objects::           
* Type conversion and casting::  
* Control structures::          
@end menu

@node General command syntax, Special characters, The SINGULAR language, The SINGULAR language
@subsection General command syntax
@cindex General command syntax

The general form of a command is (with optional parts in square brackets):
@itemize @bullet
@item
a @strong{definition}:
@*   type_name name [ @code{=} expression ] @code{;}
@* @strong{Example:}
@example
  ring r;              // creates the default ring
  poly f = x^2 + y^3 ; // define polynomial f=x^2+y^3
  poly g=xy+z2;        // define polynomial g=x*y+z^2
  ideal I = f,g;       // ideal generated by f and g
  matrix m[3][3];      // creates a 3 x 3 zero matrix
  int i=2;             // define the integer i and set i to 2
@end example
@item
an @strong{assignment}:
@*   name  @code{=} expression @code{;}
@*   name @code{=} expression_list @code{;}
@* @strong{Example:}
@example
  f = x^2 + y^2 ;      //overwrites the old value of f
  I = jacob(f);
  f,g = I[1],x^2+y^2 ; //overwrites the old values of f and g
@end example
@item
a @strong{command}:
@*   command_name [ @code{(} argument_list @code{)} ] @code{.}
@* @strong{Example:}
@example
  degree(I);
@end example
@item
a @strong{print command}:
@*   expression @code{;}
@*   @code{type} name @code{;}
@*   @code{print(} expression @code{);}
@* @strong{Example:}
@example
@c example
  int i=2; i;
  type i;              // name [ level ] type value
  print(i);
@c example
@end example
@end itemize

The general syntax for a declaration command is
@*
  type name [ @code{=} expression ] @code{;}
@*
where type stands for one of the data types of @sc{Singular},
name for the name of the object you are creating and expression
is any expression of the type or one that can be converted to the type
of the object (see @ref{Expressions}).
The expression is defaulted whenever possible. @*
It is possible to redefine or overwrite an already existing object
(as an object of the same type).
A redefinition will
first set the variable to the default value and then compute the expression.
The difference between redefinition and overwriting is shown in the following
example:
@*
@*@strong{Example:}
@example
@c example
  int i=3;
  i=i+1;        // overwriting
  i;
  int i=i+1;   // redefinition
  i;
@c example
@end example

@c ------------------------------------------------------------
@node Special characters, Names and objects, General command syntax, The SINGULAR language
@subsection Special characters
@cindex Special characters
The following characters/operators have special meanings:
@table @asis
@item @code{!}
synonymous to @code{not}
@item @code{&&}
synonymous to @code{and}
@item @code{||}
synonymous to @code{or}
@item @code{<>},@code{!=}
not equal: e.g. @code{if (i<>j)...}
@item @code{>=}
bigger or equal
@item @code{>}
bigger
@item @code{<=}
smaller or equal
@item @code{<}
smaller, but also used for file input (@ref{filecmd})
@item @code{=}
assignment: e.g. @code{int i=4711;}
@item @code{==}
equal: e.g. @code{if (i==j)...}
@item  @code{[}, @code{]}
indices in strings, integer vectors, ideals, matrices, polynomials and lists
and to build (poly) vectors: e.g. @code{ s[3], m[1,3], i[1..3],[f,g+x,0,0,1]}
@item  @code{(}, @code{)}
in expressions, for indexed names and for argument lists
@item  @code{+}
addition
@item  @code{-}
subtraction
@item  @code{*}
multiplication
@item  @code{/}
division for numbers (coefficients of polynomials) and polynomials
@item  @code{%}
integer modulo
@item  @code{^}, @code{**}
power, exponentiation
@item  @code{@@}
is a letter
@item  @code{#}
the reserved name of a list of not specified parameters in procedures
(see @ref{procedures and Libraries}).
@item  @code{"}
to start and end string constants
@item  @code{`}
to start and end name substitution
@item  @code{?}
is equivalent to @code{help}
@item  @code{;}
the separator for statements
@item  @code{,}
the separator for expression lists and function arguments
@item  @code{//}
makes the rest of the line a comment
@item  @code{\}
escape character for @code{"} within strings (see @ref{string expressions})
@item  @code{..}
construct an intvec from start and end (see @ref{intvec expressions})
@item  @code{::}
access identifiers within packages (complete name is package_name::identifier)
@item  @code{$}
ends @sc{Singular}
@end table

@c ------------------------------------------------------------
@node Names and objects, Type conversion and casting, Special characters, The SINGULAR language
@subsection Names and objects
@cindex Names and objects

Every object in @sc{Singular} has a type and a value.
In most cases it has also a name and in some cases an attribute list
@ifset singularmanual
(see @ref{General syntax}).
@end ifset
@ifclear singularmanual
(see section 'General syntax' of the @sc{Singular Reference Manual}).
@end ifclear

Possible types are:
@code{ideal} (of a ring),
@code{int} (machine integers),
@code{intmat} (matrix of machine integers),
@code{intvec} (vector of machine integers),
@code{list} (list of objects),
@code{map} (between rings/qrings),
@code{matrix} (with polynomial entries),
@code{module} (submodule of a free module),
@code{number} (ground field),
@code{poly} (polynomial over the ground field),
@code{proc} (procedure in the @sc{Singular} programming language),
@code{qring} (quotient or factor ring modulo an ideal),
@code{ring} (commuative algebra over the ground field),
@code{string} (sequence of characters),
@code{vector} (of polynomials).
The interpreter uses also the types
@code{package} (set of related objects from a library),
@code{none} (a dummy return type) and
@code{?unknown type?} (in the error handling)
@ifset singularmanual
(see @ref{typeof}).
@end ifset
@ifclear singularmanual
(see section 'typeof' of the @sc{Singular Manual}).
@end ifclear

The most basic (and most complicated) object in @sc{Singular}
is a @code{ring} (and @code{qring}). Each object of type
@code{poly},
@code{ideal},
@code{vector},
@code{module},
@code{map},
@code{matrix},
@code{number}
belongs to a specific ring.
Also @code{list}, if one of the objects belong to a ring.
These objects are local to the ring, hence their names can be used for other
objects in other rings. Objects from one ring can be mapped to another
ring with an object of type @code{map}
(or with the commands @code{fetch} or @code{imap}).
The rings which are available in @sc{Singular} are described in
@ref{Baserings and ground fields}. They are all algebras over the ground
field. Hence, in oder to compute in one of the ground fields,
one has to define a ring (with at least one variable and a monomial
ordering).

The other types do not belong to a ring and can be accessed within every ring.

Usually @sc{Singular} (i.e. if possible) gives an error message or warning
when the same name is defined again. However be sure not to use the name
of an object as a name for a ring variable. This may not be considered
as an error, but the evaluation of the name may be confusing.

The following names are predefined commands or variables
and cannot be used otherwise:@*
@code{alternating},
@code{and},
@code{attrib},
@code{bareiss},
@code{basering},
@code{break},
@code{char},
@code{char_series},
@code{charstr},
@code{cleardenom},
@code{close},
@code{continue},
@code{contract},
@code{coef},
@code{coeffs},
@code{dbprint},
@code{def},
@code{defined},
@code{deg},
@code{degBound},
@code{degree},
@code{delete},
@code{det},
@code{diff},
@code{dim},
@code{div},
@code{dring},
@code{dump},
@code{echo},
@code{else},
@code{eval},
@code{exit},
@code{execute},
@code{export},
@code{extgcd},
@code{facstd},
@code{factorize},
@code{fetch},
@code{fglm},
@code{find},
@code{finduni},
@code{for},
@code{forif},
@code{freemodule},
@code{gcd},
@code{gen},
@code{getdump},
@code{help},
@code{hilb},
@code{homog},
@code{ideal},
@code{if},
@code{imap},
@code{indepSet},
@code{insert},
@code{int},
@code{interred},
@code{intersect},
@code{intmat},
@code{intvec},
@code{jacob},
@code{jet},
@code{kbase},
@code{keepring},
@code{kill},
@code{killattrib},
@code{koszul},
@code{lead},
@code{leadcoef},
@code{leadexp},
@code{LIB},
@code{lift},
@code{liftstd},
@code{link},
@code{list},
@code{listvar},
@code{map},
@code{matrix},
@code{maxideal},
@code{memory},
@code{minbase},
@code{minor},
@code{minpoly},
@code{minres},
@code{mod},
@code{module},
@code{monitor},
@code{mres},
@code{mstd},
@code{mult},
@code{multBound},
@code{nameof},
@code{names},
@code{ncols},
@code{newline},
@code{NF},
@code{noether},
@c @code{NOT},
@code{not},
@code{npars},
@code{nrows},
@code{number},
@code{nvars},
@code{open},
@code{or},
@code{ord},
@code{ordstr},
@code{option},
@code{package},
@code{pagelength},
@code{pagewidth},
@code{par},
@code{parameter},
@code{pardeg},
@code{parstr},
@code{pause},
@code{poly},
@code{preimage},
@code{prime},
@code{print},
@code{printlevel},
@code{proc},
@code{prune},
@code{qhweight},
@code{qring},
@code{quit},
@code{quote},
@code{quotient},
@code{random},
@c @code{rank},
@code{read},
@code{reduce},
@code{regularity},
@code{res},
@code{reservedName},
@code{resolution},
@code{resultant},
@code{return},
@code{ring},
@code{rtimer},
@code{rvar},
@code{setring},
@code{short},
@code{simplify},
@code{size},
@code{sortvec},
@code{sres},
@code{status},
@code{std},
@code{string},
@code{subst},
@code{system},
@code{syz},
@code{test},
@code{timer},
@code{TRACE},
@code{trace},
@code{transpose},
@code{type},
@code{typeof},
@code{var},
@code{varstr},
@code{vdim},
@code{vector},
@code{verbose},
@code{voice},
@code{wedge},
@code{weight},
@code{while},
@code{whileif},
@code{write}.

You  get a list of the reserved names by @code{reservedName();},
see @ref{reservedName}.

User defined global names start with a letter and consist only of letters and
digits.
They must not coincide with reserved names (keywords) and should not interfere
with monomials. All names are case sensitive.
Indexed names are built as
name followed by @code{(} int_expression @code{)}.
A list of indexed names can be built as a name followed by
@code{(} int_expression @code{)}.
@example
@c example
  ring R;
  int jindex=3;
  ideal j(3);
  ideal j(jindex);     // is equivalent with the above
  ideal j(2)=x;
  j(2..3);
@c example
@end example

Hier fehlt noch was ueber die defs.

@c ------------------------------------------------------------
@node Type conversion and casting, Control structures, Names and objects, The SINGULAR language
@subsection Type conversion and casting
@cindex Type conversion
Assignments convert the type of an expression to the type
of the left-hand side of the assignment.
Operations, which require certain
types of operands can also implicitly convert the type of an
expression (e.g. you can multiply a polynomial by an integer because
the integer is automatically converted to polynomial).
Possible conversions are:
@* @sp 1
@enumerate
@item
@code{int} @expansion{} @code{poly}
@item
@code{int} @expansion{} @code{number}
@item
@code{number} @expansion{} @code{poly}
@item
@code{int} @expansion{} @code{vector}
(i @expansion{} i*gen(1))
@item
@code{poly} @expansion{} @code{vector}
(p @expansion{} p*gen(1))
@item
@code{int} @expansion{} @code{intvec}
@item
@code{intvec} @expansion{} @code{intmat}
@item
@code{matrix} @expansion{} @code{module}
@item
@code{vector} @expansion{} @code{module}
@item
@code{ideal} @expansion{} @code{module}
@item
@code{ideal} @expansion{} @code{matrix}
@item
@code{vector} @expansion{} @code{matrix}
@item
@code{module} @expansion{} @code{matrix}
@item
@code{intvec} @expansion{} @code{matrix}
@item
@code{intmat} @expansion{} @code{matrix}
@item
@code{string} @expansion{} @code{proc}
@item
@code{resolution} @expansion{} @code{list}
@item
@code{list} @expansion{} @code{resolution}.
@end enumerate

Note that type conversions do not act transitively.

@cindex Type casting
An expression can be casted to another type by using a type name
as a function returning this type.
Possible type castings are:
@enumerate
@item
to @code{string} from @code{int}, @code{number}, @code{poly}, @code{vector},
 @code{ideal}, @code{matrix}, @code{module}, @code{map}, @code{proc}
@item
to @code{int} from @code{number}, @code{poly}
@item
to @code{number} from @code{poly}
@item
to @code{poly} from @code{int}, @code{number}
@item
to @code{ideal} from @code{vector}, @code{poly},
@code{matrix}, @code{int}, @code{number}
@item
to @code{ideal} from expression lists of @code{poly},
@code{int}, @code{number}. (The list may be empty)
@item
to @code{ideal} from @code{matrix}, @code{vector}, @code{poly}, @code{module}
@item
to @code{matrix} from @code{module}, @code{ideal}, @code{vector}.
@* There are two forms to convert something to a matrix:
if @code{matrix(xx)} is used then the size of the matrix will
be determined by xx.
But @code{matrix(xx,a,b)} may also be used - the result is
an a x b matrix.
@item
to @code{intvec} from expression lists of @code{int}. (The list may be empty)
@item
to @code{module} from expression lists of @code{vector}
@code{int}, @code{number}, @code{poly}. (The list may be empty)
@item
to @code{module} from @code{matrix}, @code{vector}, @code{ideal}.
@item
to @code{list} from expression lists of any type. (The list may be empty)
@end enumerate
@strong{Examples:}
@example
@c example
  ring r=0,x,(c,dp);
  number(3x);
  number(poly(3));
  ideal i=1,2,3,4,5,6;
  print(matrix(i));
  print(matrix(i,3,2));
  vector v=[1,2];
  print(matrix(v));
  module(matrix(i,3,2));
@c example
@end example



@c ------------------------------------------------------------
@node Control structures,  , Type conversion and casting, The SINGULAR language
@subsection Control structures
@cindex Control structures
@cindex block
Hier fehlen noch die Verweise auf Kapitel 5.3 und Kapitel 6.

A block is a sequence of commands surrounded by @{ and @}. Blocks
are used for proc, if, else, while and for statements.
@example
  @{
     command;
     @dots{}
  @}
@end example
@menu
* if::
* for::
* while::
* proc::
@end menu
@iftex
See @ref{if}; @ref{for}; @ref{while}; @ref{proc}
@end iftex


@c ---------------------------------------------------------------------------
@*----------------------------------------------------------------------------
@*@strong{Wohin damit????}
Procedures are user-defined functions containing sequences of @sc{Singular}
commands. Several procedures can be stored in a file which is then
called a library. Procedures and libraries have to comply with special
syntax-rules described in this chapter. 

The @sc{Singular} distribution contains sevaral libraries. 
@c @ifset singularmanual
(See @ref{SINGULAR libraries} for a complete list of available libraries.)
@c @end ifset
Further libraries are in preparation.
The user may add other procedures/libraries.
@c @ifset singularmanual
@c (see @ref{procedures}; @ref{Procedures and LIB}).
@c @end ifset
@ifclear singularmanual
(see 'procedures'; 'Procedures and LIB' of the @sc{Singular Manual}).
@end ifclear
@*----------------------------------------------------------------------------


@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@include libraries.tex

@c @node Procedures, Libraries, The SINGULAR language, General concepts
@c @section Procedures
@c @node Libraries, Debugging tools, Procedures, General concepts
@c @node Debugging tools, Implemented algorithms, Libraries, General concepts
