  @comment -*-texinfo-*-
@comment $Id: plureference.doc,v 1.47 2007-11-16 18:42:18 Singular Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex

@menu
* Functions @value{PSUFFIX}::
@end menu

@node Functions @value{PSUFFIX},  , Top, Top
@chapter  Functions @value{PSUFFIX}
%**end
@end ignore
@cindex Functions @value{PSUFFIX}

This chapter gives a complete reference of all functions and commands of the @sc{Plural} kernel, i.e. all built-in commands
 (for the @sc{Plural} libraries see @ref{PLURAL libraries}).

The general syntax of a function is
@format
                   [target =] function_name (<arguments>);
@end format


Note, that both @strong{Control structures} and @strong{System variables} of
 @sc{Plural} are the same as of @sc{Singular}
@ifset singularmanual
(see @ref{Control structures}, @ref{System variables}).
@end ifset
@ifclear singularmanual
(see corresponging sections in the @sc{Singular} Manual.
@end ifclear



@menu
* betti @value{PSUFFIX}::
* bracket::
* eliminate @value{PSUFFIX}::
* envelope::
* fetch @value{PSUFFIX}::
* imap @value{PSUFFIX}::
* intersect @value{PSUFFIX}::
* kbase @value{PSUFFIX}::
* lift @value{PSUFFIX}::
* liftstd @value{PSUFFIX}::
* minres @value{PSUFFIX}::
* modulo @value{PSUFFIX}::
* mres @value{PSUFFIX}::
* nc_algebra::
* ncalgebra::
* nres @value{PSUFFIX}::
* oppose::
* opposite::
* preimage @value{PSUFFIX}::
* quotient @value{PSUFFIX}::
* reduce @value{PSUFFIX}::
* ringlist @value{PSUFFIX}::
* slimgb @value{PSUFFIX}::
* std @value{PSUFFIX}::
* subst  @value{PSUFFIX}::
* syz @value{PSUFFIX}::
* twostd::
* vdim @value{PSUFFIX}::
@end menu

@c * Comparison between Singular and Plural functions::


@c -----------------------------
@node betti @value{PSUFFIX}, bracket, Functions @value{PSUFFIX}, Functions @value{PSUFFIX}
@section betti @value{PSUFFIX}
@cindex betti @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{betti (} list_expression @code{)}
@*@code{betti (} resolution_expression @code{)}
@*@code{betti (} list_expression @code{,} int_expression @code{)}
@*@code{betti (} resolution_expression @code{,} int_expression @code{)}
@item @strong{Type:}
intmat
@item @strong{Note:}
in the noncommutative case, computing Betti numbers makes sense only if the basering @math{R} has homogeneous relations
@item @strong{Purpose:}
with 1 argument: computes the graded Betti numbers of a minimal resolution of
@tex
$R^n/M$, if $R$ denotes the basering and
$M$ a homogeneous submodule of $R^n$ and the argument represents a
resolution of
$R^n/M$.
@end tex
@iftex
@*
@end iftex
@tex
The entry d of the intmat at place (i, j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of $R^n/M$ (the 0th (resp.\ 1st) syzygy module of $R^n/M$ is
$R^n$ (resp.\ $M$)).
@end tex
@ifinfo
R^n/M, if R denotes the basering and
M a homogeneous submodule of R^n and the argument represents a resolution of
R^n/M:
@*The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module
@c (= module of relations)
of R^n/M (the 0th (resp.@: 1st) syzygy module of R^n/M is R^n
(resp.@: M)).
@end ifinfo
The argument is considered to be the result of a @code{mres} or @code{nres}
command. This implies that a zero is only allowed (and counted) as a
generator in the first module.
@*For the computation @code{betti} uses only the initial monomials. This could lead to confusing results for a non-homogeneous input.

If the optional second argument is non-zero, the Betti numbers will be minimized.
@c The optional second argument is a switch for the minimization of the Betti
@c numbers. If it is 0 then the Betti numbers correspond exactly to the input -
@c otherwise the command is identical to the one-argument form.
@item @strong{Example:}
@smallexample
@c example
int i;int N=2;
ring r=0,(x(1..N),d(1..N),q(1..N)),Dp;
matrix D[3*N][3*N];
for (i=1;i<=N;i++)
{ D[i,N+i]=q(i)^2; }
def W=nc_algebra(1,D); setring W;
// this algebra is a kind of homogenized Weyl algebra
W;
ideal I = x(1),x(2),d(1),d(2),q(1),q(2);
option(redSB);
option(redTail);
resolution R = mres(I,0);
// thus R will be the full length minimal resolution
print(betti(R),"betti");
@c example
@end smallexample
@end table


@c -----------------------------
@node bracket, eliminate @value{PSUFFIX}, betti @value{PSUFFIX}, Functions @value{PSUFFIX}
@section bracket
@cindex bracket

@table @code
@item @strong{Syntax:}
@code{bracket (} poly_expression, poly_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
Computes the Lie bracket @code{[p,q]=pq-qp} of the first polynomial with
the second. Uses special routines, based on the Leibniz rule.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,Q),(x,y,z),Dp;
minpoly=Q^2-Q+1;
matrix C[3][3];  matrix D[3][3];
C[1,2]=Q2;    C[1,3]=1/Q2;  C[2,3]=Q2;
D[1,2]=-Q*z;  D[1,3]=1/Q*y; D[2,3]=-Q*x;
def R=nc_algebra(C,D); setring R;
// this is a quantum deformation of U(so_3),
// where Q is a 6th root of unity
poly p=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z;
// p is the central element of the algebra
p=p^3; // any power of a central element is central
poly q=(x+Q*y+Q^2*z)^4;
// take q to be some big noncentral element
size(q); // check how many monomials are in big poly q
bracket(p,q); // check p*q=q*p
// a more common behaviour of the bracket follows:
bracket(x+Q*y+Q^2*z,z);
@c example
@end smallexample
@end table

@c ---------------------------------------
@node eliminate @value{PSUFFIX}, envelope, bracket, Functions @value{PSUFFIX}
@section eliminate @value{PSUFFIX}
@cindex eliminate @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
eliminates variables occurring as factors of the second argument from an
ideal (resp.@: a submodule of a free module), by intersecting it
(resp. each component of the submodule) with the subring not containing these variables.
@item @strong{Note:}
@code{eliminate} does not need neither a special ordering on the basering nor a Groebner basis as input.
@item @strong{Remark:}
 in a noncommutative algebra, not every subset of a set of variables generates
a proper subalgebra. But if it is so, there may be cases, when no elimination is possible.
In these situations error messages will be reported.

@item @strong{Example:}
@smallexample
@c example error
ring r=0,(e,f,h,a),Dp;
matrix d[4][4];
d[1,2]=-h; d[1,3]=2*e; d[2,3]=-2*f;
def R=nc_algebra(1,d); setring R;
// this algebra is U(sl_2), tensored with K[a] over K
option(redSB);
option(redTail);
poly  p = 4*e*f+h^2-2*h - a;
// p is a central element with parameter
ideal I = e^3, f^3, h^3-4*h, p; // take this ideal
// and intersect I with the ring K[a]
ideal J = eliminate(I,e*f*h);
// if we want substitute 'a' with a value,
// it has to be a root of this polynomial
J;
// now we try to eliminate h,
// that is we intersect I with the subalgebra S,
// generated by e and f.
// But S is not closed in itself, since f*e-e*f=-h !
// the next command will definitely produce an error
eliminate(I,h);
// since a commutes with e,f,h, we can eliminate it:
eliminate(I,a);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node  envelope, fetch @value{PSUFFIX}, eliminate @value{PSUFFIX}, Functions @value{PSUFFIX}
@section envelope
@cindex envelope

@table @code
@item @strong{Syntax:}
@code{envelope (} ring_name @code{)}
@item @strong{Type:}
ring
@item @strong{Purpose:}
creates an enveloping algebra of a given algebra, that is
@ifinfo
A_env = A tensor A_opp, where A_opp is the
opposite algebra of A.
@end ifinfo
@tex
$A^{env} = A \otimes_K A^{opp}$, where $A^{opp}$ is the
opposite algebra of $A$.
@end tex
@item @strong{Remark:}
You have to activate the ring with the @code{setring} command.
For the presentation, see explanation of @code{opposite} in @ref{opposite}.
@smallexample
@c example
LIB "ncalg.lib";
def A = makeUsl2();
setring A; A;
def Aenv = envelope(A);
setring Aenv;
Aenv;
@c example
@end smallexample
@end table
@c ref
See
@ref{oppose};
@ref{opposite}.
@c ref

@c ---------------------------------------
@node fetch @value{PSUFFIX}, imap @value{PSUFFIX}, envelope, Functions @value{PSUFFIX}
@section fetch @value{PSUFFIX}
@cindex fetch @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{fetch (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
maps objects between rings.
@code{fetch} is the identity map between rings and qrings,
the i-th variable of the source ring is mapped to the i-th
variable of the basering.  The coefficient fields must be compatible.
(See @ref{map @value{PSUFFIX}} for a description of possible mappings between
different ground fields).
@*@code{fetch} offers a convenient way to change
variable names or orderings, or to map objects from a ring to a quotient
ring of that ring or vice versa.
@item @strong{Note:}
Compared with @code{imap}, @code{fetch} uses the position of the ring
variables, not their names.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def Usl2 = makeUsl2(); // this algebra is U(sl_2)
setring Usl2;
option(redSB);
option(redTail);
poly  C  = 4*e*f+h^2-2*h; // the central element of Usl2
ideal I  = e^3,f^3,h^3-4*h;
ideal J  = twostd(I);
matrix M = matrix(J);
 // print a compact presentation of J:
print(matrix(ideal(J[1..5]))); // first 5 generators
print(matrix(ideal(J[6..size(J)]))); // last generators
ideal QC = twostd(C-8);
qring Q  = QC;
ideal QJ = fetch(Usl2,J);
QJ = std(QJ);
// thus QJ is the image of I in the factor-algebra QC
print(matrix(QJ)); // print QJ compactly
@c example
@end smallexample
@end table
@c ref
See
@ref{imap @value{PSUFFIX}};
@ref{map @value{PSUFFIX}};
@ref{qring @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node imap @value{PSUFFIX}, intersect @value{PSUFFIX}, fetch @value{PSUFFIX}, Functions @value{PSUFFIX}
@section imap @value{PSUFFIX}
@cindex imap @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{imap (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
identity map on common subrings.  @code{imap} is the map between rings
and qrings with compatible ground fields which is the identity on
variables and parameters of the same name and 0 otherwise.
(See @ref{map @value{PSUFFIX}} for a description of possible mappings between
different ground fields).
Useful for mappings from a homogenized ring to the original ring or
for mappings from/to rings with/without parameters. Compared with
@code{fetch}, @code{imap} uses the names of variables and parameters.
Unlike @code{map} and @code{fetch}, @code{imap} can map parameters to variables.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
ring ABP=0,(p4,p5,a,b),dp; //  a commutative ring
def Usl3 = makeUsl(3);
def BIG  = Usl3+ABP;
setring BIG;
poly P4 = 3*x(1)*y(1)+3*x(2)*y(2)+3*x(3)*y(3);
P4 = P4 +h(1)^2+h(1)*h(2)+h(2)^2-3*h(1)-3*h(2);
// P4 is a central element of Usl3 of degree 2
poly P5 = 4*x(1)*y(1) + h(1)^2 - 2*h(1);
// P5 is a central element of the subalgebra of U(sl_3),
// generated by x(1),y(1),h(1)
ideal J = x(1),x(2),h(1)-a,h(2)-b;
// we are interested in the module U(sl_3)/J,
// which depends on parameters a,b
ideal I = p4-P4, p5-P5;
ideal K = I, J;
ideal E = eliminate(K,x(1)*x(2)*x(3)*y(1)*y(2)*y(3)*h(1)*h(2));
E; // this is the ideal of central characters in ABP
// what are the characters on nonzero a,b?
ring abP = (0,a,b),(p4,p5),dp;
ideal abE = imap(BIG, E);
option(redSB);
option(redTail);
abE = std(abE);
// here come characters (indeed, we have only one)
// that is a maximal ideal in K[p4,p5]
abE;
@c example
@end smallexample
@end table
@c ref
See
@ref{fetch @value{PSUFFIX}};
@ref{map @value{PSUFFIX}};
@ref{qring @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref



@c ------------------------------------------------
@node intersect @value{PSUFFIX}, kbase @value{PSUFFIX}, imap @value{PSUFFIX}, Functions @value{PSUFFIX}
@section  intersect @value{PSUFFIX}
@cindex  intersect @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{intersect (}expression_list of ideal_expression  @code{)}
@*@code{intersect (}expression_list of module_expression  @code{)}

@item @strong{Type:}
ideal, resp. module

@item @strong{Purpose:}
computes the intersection of ideals, resp. modules.
@item @strong{Example:}
@c // 1. from [BGV], p.213, Ex.2.5. answer: [0,xy^2],[y^2,-xy]
@c // 2. from [BGV], p.148, Ex.3.8
@smallexample
@c example
ring r=0,(x,y),dp;
def R=nc_algebra(-1,0);
setring R;
module M=[x,x],[y,0];
module N=[0,y^2],[y,x];
option(redSB);
module Res;
Res=intersect(M,N);
print(Res);
kill r,R;
//--------------------------------
LIB "ncalg.lib";
ring r=0,(x,d),dp;
def RR=Weyl(); // make r into Weyl algebra
setring RR;
ideal I = x+d^2;
ideal J = d-1;
ideal H = intersect(I,J);
H;
@c example
@end smallexample
@end table



@c ------------------------------------------------
@node kbase @value{PSUFFIX}, lift @value{PSUFFIX}, intersect @value{PSUFFIX}, Functions @value{PSUFFIX}
@section kbase @value{PSUFFIX}
@cindex kbase @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{kbase (} ideal_expression @code{)}
@*@code{kbase (} module_expression @code{)}
@*@code{kbase (} ideal_expression@code{,} int_expression@code{)}
@*@code{kbase (} module_expression@code{,} int_expression@code{)}
@item @strong{Type:}
the same as the input type of the first argument
@item @strong{Purpose:}

computes the vector space basis of the
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the initial terms of the given generators.
@* If the factor-module is not of finite dimension, -1 is returned.

If the generators form a Groebner basis,
this is the same as the vector space basis of the
factor-module.

@item @strong{Note:}
in the noncommutative case, a ring modulo an ideal has a ring stucture
if and only if the ideal is two-sided.
@item @strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;  d[1,3]=2x;  d[2,3]=-2y;
def R=nc_algebra(1,d); // this algebra is U(sl_2)
setring R;
ideal i=x2,y2,z2-1;
i=std(i);
print(matrix(i));  // print a compact presentation of i
kbase(i);
vdim(i);
ideal j=x,z-1;
j=std(j);
kbase(j,3);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{vdim @value{PSUFFIX}}.
@c ref


@c -------------------------------------------------
@node lift @value{PSUFFIX}, liftstd @value{PSUFFIX}, kbase @value{PSUFFIX}, Functions @value{PSUFFIX}
@section lift @value{PSUFFIX}
@cindex lift @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{lift (} ideal_expression@code{,} subideal_expression @code{)}
@*@code{lift (} module_expression@code{,} submodule_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the (left) transformation matrix which expresses the (left) generators of a
submodule in terms of the (left) generators of a module.  Uses different
algorithms for modules which are (resp.@: are not) represented by a
Groebner basis.
@* More precisely, if  @code{m} is the
module, @code{sm} the submodule,
and @code{T} the transformation matrix returned by
lift, then @code{transpose(matrix(sm)) = transpose(T)*transpose(m)}
and @code{module(transpose(sm)) = module(transpose(T)*transpose(m))}.
If  @code{m} and @code{sm} are ideals, @code{ideal(sm) = ideal(transpose(T)*transpose(m))}.

@item @strong{Note:}
Gives a warning if @code{sm} is not a submodule.
@item @strong{Example:}
@smallexample
@c example
ring r = (0,a),(e,f,h),(c,dp);
matrix D[3][3];
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
def R=nc_algebra(1,D); // this algebra is a parametric U(sl_2)
setring R;
ideal i = e,h-a; // consider this parametric ideal
i = std(i);
print(matrix(i)); // print a compact presentation of i
poly Z = 4*e*f+h^2-2*h; // a central element
Z = Z - NF(Z,i); // a central character
ideal j = std(Z);
j;
matrix T = lift(i,j);
print(T);
ideal tj = ideal(transpose(T)*transpose(matrix(i)));
std(ideal(j-tj)); // test
@c example
@end smallexample
@end table
@c ref
See
@ref{liftstd @value{PSUFFIX}};
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}}.
@c ref


@c -----------------------------------------
@node liftstd @value{PSUFFIX}, minres @value{PSUFFIX}, lift @value{PSUFFIX}, Functions @value{PSUFFIX}
@section liftstd @value{PSUFFIX}
@cindex liftstd @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{liftstd (} ideal_expression@code{,} matrix_name @code{)}
@*@code{liftstd (} module_expression@code{,} matrix_name @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a Groebner basis of an ideal or module and the transformation
matrix from the given ideal, resp.@: module, to the Groebner basis.
@*That is, if @code{m} is the ideal or module, @code{sm} is the Groebner
basis of  @code{m}, returned by @code{liftstd}, and @code{T} is the transformation matrix,
then @code{transpose(matrix(sm))=transpose(T)*transpose(matrix(m))} and
@code{sm=module(transpose(transpose(T)*transpose(matrix(m))))}.

If @code{m} is an ideal, @code{sm=ideal(transpose(T)*transpose(matrix(m)))}.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = makeUsl2();
setring A;  // this algebra is U(sl_2)
ideal i = e2,f;
option(redSB);
option(redTail);
matrix T;
ideal j = liftstd(i,T);
// the Groebner basis in a compact form:
print(matrix(j));
print(T);  // the transformation matrix
ideal tj = ideal(transpose(T)*transpose(matrix(i)));
std(ideal(j-tj)); // test
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node  minres @value{PSUFFIX}, modulo @value{PSUFFIX}, liftstd @value{PSUFFIX}, Functions @value{PSUFFIX}
@section minres @value{PSUFFIX}
@cindex minres @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{minres (} list_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{minres (} resolution_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
minimizes a free resolution of an ideal or module
given by the list_expression, resp.@: resolution_expression.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = makeUsl2();
setring A; // this algebra is U(sl_2)
ideal i=e,f,h;
i=std(i);
resolution F=nres(i,0);   F;
print(matrix(F[1])); // print F's compactly
print(matrix(F[2]));
print(matrix(F[3]));
resolution MF=minres(F);  MF;
print(matrix(MF[1]));
print(matrix(MF[2]));
print(matrix(MF[3]));
@c example
@end smallexample
@end table

@c ref
See
@ref{mres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node modulo @value{PSUFFIX}, mres @value{PSUFFIX}, minres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section modulo @value{PSUFFIX}
@cindex modulo @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{modulo (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{modulo (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
@code{modulo(h1,h2)}
@ifinfo
represents h1/(h1 intersect h2) (isomorphic to (h1+h2)/h2)
@end ifinfo
@tex
represents $h_1/(h_1 \cap h_2) \cong (h_1+h_2)/h_2$
@end tex
, where
@tex
$h_1$ and $h_2$
@end tex
@ifinfo
h1 and h2
@end ifinfo
are considered as submodules of the same free module
@tex
$R^s$
@end tex
@ifinfo
R^s
@end ifinfo
(s=1 for ideals).
@*Let
@tex
$H_1$ (resp.\ $H_2$)
@end tex
@ifinfo
H1 (resp. H2)
 be the matrix of size l x k (resp.@: l x m), having the generators of
 h1 (resp.@: h2)
@end ifinfo
@tex
 be the matrix of size $l \times k$ (resp.\ $l \times m$), having the
generators of $h_1$ (resp.\ $h_2$)
@end tex
as columns.
@* Then
@tex
$h_1/(h_1 \cap h_2) \cong R^k / ker(\overline{H_1})$
@end tex
@ifinfo
@format
                                                    __
      h1/(h1 intersect h2) is isomorphic to R^k/ker(H1)

@*
@end format
@end ifinfo
, where
@tex
$\overline{H_1}: R^k \rightarrow R^s/Im(H_2)=R^s/h_2$
is the induced map.
@end tex
@ifinfo
@format
         __
         H1: R^k ----> R^l/Im(H2)=R^l/h2 is the induced map.

@*
@end format
@end ifinfo
@*@code{modulo(h1,h2)} returns generators of
the kernel of this induced map.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = makeUsl2();
setring A; // this algebra is U(sl_2)
option(redSB);
option(redTail);
ideal I = e2,f2,h2-1;
I = twostd(I);
print(matrix(I)); // print I in a compact form
ideal E = std(e);
ideal T = modulo(E,I);
T = NF(std(I+T),I);
T = std(T);
T;
@c example
@end smallexample
@end table
@c ref
See also
@ref{syz @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node  mres @value{PSUFFIX}, nc_algebra, modulo @value{PSUFFIX}, Functions @value{PSUFFIX}
@section mres @value{PSUFFIX}
@cindex mres @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression @code{)}
@*@code{mres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the
Groebner basis method. More precisely, let A=@code{matrix}(M), then @code{mres}
computes a free resolution of
@ifinfo
coker(A)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@end ifinfo
@tex
$coker(A)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M
\longrightarrow 0,$$
@end tex
where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are a (possibly) minimal set of generators
of @math{M}.
If the int expression k is not zero, then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, $i= 1 \ldots k$.
@end tex
@ifinfo
Mi=module(Ai), i=1...k.
@end ifinfo
@*@code{mres(M,0)} returns a resolution consisting of at most n+2 modules,
where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then @code{L[1]} consists of a minimal set of generators of the input, @code{L[2]}
consists of a minimal set of generators for the first syzygy module of
@code{L[1]}, etc., until @code{L[p+1]}, such that
@ifinfo
L[i]<>0 for i<=p,
@end ifinfo
@tex
${\tt L[i]}\neq 0$ for $i \le p$,
@end tex
 but @code{L[p+1]} (the first syzygy module of @code{L[p]})
is 0 (if the basering is not a qring).
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = makeUsl2();
setring A; // this algebra is U(sl_2)
option(redSB);
option(redTail);
ideal i = e,f,h;
i = std(i);
resolution M=mres(i,0);
M;
print(matrix(M[1])); // print M's in a compact way
print(matrix(M[2]));
// see the exactness at this point
std(ideal(transpose(M[2])*transpose(M[1])));
print(matrix(M[3]));
// see the exactness at this point
std(ideal(transpose(M[3])*transpose(M[2])));
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@c ref


@c -----------------------------
@node nc_algebra, ncalgebra, mres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section nc_algebra
@cindex nc_algebra

@table @code
@item @strong{Syntax:}
@*@code{nc_algebra(} matrix_expression C, matrix_expression D @code{)}
@*@code{nc_algebra(} number_expression n, matrix_expression D @code{)}
@*@code{nc_algebra(} matrix_expression C, poly_expression p @code{)}
@*@code{nc_algebra(} number_expression n, poly_expression p @code{)}
@item @strong{Type:}
ring
@item @strong{Purpose:}
Executed in the basering @code{r}, say, in k variables
@tex
$ x_1, \ldots, x_k ,\;$
@end tex
@ifinfo
 x_1,... ,x_k,
@end ifinfo
@code{nc_algebra} creates the
noncommutative extension of @code{r} subject to relations
@tex
$ \{ x_j x_i=c_{ij} \cdot x_i x_j + d_{ij}, 1 \leq i <j \leq k \}, $
where $c_{ij}$ and $d_{ij}$ must be put into two strictly upper
@end tex
@ifinfo
@{x_j x_i=c_@{ij@} ..., x_i x_j + d_@{ij@} , 0< i <j < k+1 @}.
where c_@{ij@}  and d_@{ij@  must be put into two strictly upper
@end ifinfo
 triangular matrices @code{C} with entries
@tex
$c_{ij}$
@end tex
@ifinfo
c_@{ij@}
@end ifinfo
 from the ground field of @code{r}
and @code{D}  with  polynomial entries
@tex
$ d_{ij}$
@end tex
@ifinfo
d_@{ij@}
@end ifinfo
 from @code{r}. See all the details in @ref{G-algebras}.
@* If
@tex
$\forall i<j$, $c_{ij} = n$
@end tex
@ifinfo
for all i<j, c_@{ij@} = n
@end ifinfo
 , one can input a number @code{n} instead of matrix @code{C}.
@* If
@tex
$\forall i<j$, $d_{ij} = p$
@end tex
@ifinfo
for all i<j, d_@{ij@} = p
@end ifinfo
 , one can input a poly @code{p} instead of matrix @code{D}.

@item @strong{Remark:}
At present, @sc{Plural} does not check the non-degeneracy conditions (@pxref{G-algebras}) while setting an algebra.

@item @strong{Example:}
@smallexample
@c example
LIB "nctools.lib";
// ------- first example: C, D are matrices --------
ring r1 = (0,Q),(x,y,z),Dp;
minpoly = rootofUnity(6);
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;   C[1,3]=1/Q2;  C[2,3]=Q2;
D[1,2]=-Q*z; D[1,3]=1/Q*y; D[2,3]=-Q*x;
def S=nc_algebra(C,D);
// this algebra is a quantum deformation U'_q(so_3),
// where Q is a 6th root of unity
setring S;S;
kill r1,S;
// ----- second example: number n=1, D is a matrix
ring r2=0,(Xa,Xb,Xc,Ya,Yb,Yc,Ha,Hb),dp;
matrix d[8][8];
d[1,2]=-Xc; d[1,4]=-Ha; d[1,6]=Yb;  d[1,7]=2*Xa;
d[1,8]=-Xa; d[2,5]=-Hb; d[2,6]=-Ya; d[2,7]=-Xb;
d[2,8]=2*Xb; d[3,4]=Xb; d[3,5]=-Xa; d[3,6]=-Ha-Hb;
d[3,7]=Xc;   d[3,8]=Xc; d[4,5]=Yc; d[4,7]=-2*Ya;
d[4,8]=Ya;  d[5,7]=Yb; d[5,8]=-2*Yb;
d[6,7]=-Yc; d[6,8]=-Yc;
def S=nc_algebra(1,d);  // this algebra is U(sl_3)
setring S;S;
kill r2,S;
// ---- third example: C is a matrix, p=0 is a poly
ring r3=0,(a,b,c,d),lp;
matrix c[4][4];
c[1,2]=1; c[1,3]=3; c[1,4]=-2;
c[2,3]=-1; c[2,4]=-3; c[3,4]=1;
def S=nc_algebra(c,0); // it is a quasi--commutative algebra
setring S;S;
kill r3,S;
// -- fourth example : number n = -1, poly p = 3w
ring r4=0,(u,v,w),dp;
def S=nc_algebra(-1,3w);
setring S;S;
kill r4,S;
@c example
@end smallexample
@end table
@c ref
See also
@ref{ncalg_lib};
@ref{nctools_lib};
@ref{qmatrix_lib};
@c ref


@c -----------------------------
@node ncalgebra, nres @value{PSUFFIX}, nc_algebra, Functions @value{PSUFFIX}
@section ncalgebra
@cindex ncalgebra

@table @code
@item @strong{Syntax:}
@*@code{ncalgebra(} matrix_expression C, matrix_expression D @code{)}
@*@code{ncalgebra(} number_expression n, matrix_expression D @code{)}
@*@code{ncalgebra(} matrix_expression C, poly_expression p @code{)}
@*@code{ncalgebra(} number_expression n, poly_expression p @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
Works like @ref{nc_algebra} but changes the basering.

@item @strong{Remark:}
This function is @strong{depreciated} and should be substituted by @code{nc_algebra},
since it violates the general @sc{Singular} policy: only @ref{ring} and @ref{setring} can change the basering.

@end table
@c ref
See also
@ref{nc_algebra};
@ref{nctools_lib};
@c ref

@c ---------------------------------------
@node  nres @value{PSUFFIX}, oppose, ncalgebra, Functions @value{PSUFFIX}
@section nres @value{PSUFFIX}
@cindex nres @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{nres (} ideal_expression@code{,} int_expression @code{)}
@*@code{nres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module which is minimized
from the second module on (by the Groebner basis method).
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = makeUsl2();
setring A; // this algebra is U(sl_2)
option(redSB);
option(redTail);
ideal i = e,f,h;
i = std(i);
resolution F=nres(i,0);
F;
// print the resolution componentwise:
print(matrix(F[1]));
print(matrix(F[2]));
// see the exactness at this point:
std(ideal(transpose(F[2])*transpose(F[1])));
print(matrix(F[3]));
// see the exactness at this point:
std(ideal(transpose(F[3])*transpose(F[2])));
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@ref{mres @value{PSUFFIX}};
@c ref

@c ---------------------------------------
@node  oppose, opposite, nres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section oppose
@cindex oppose

@table @code
@item @strong{Syntax:}
@code{oppose (} ring_name, name @code{)}
@item @strong{Type:}
poly, vector, ideal, module or matrix (the same type as the second argument)
@item @strong{Purpose:}
for a given object in the given ring, creates its opposite object
in the opposite (@ref{opposite}) ring (the last one is assumed to be the current ring).
@item @strong{Remark:}
for any object
@tex
 $O, \; (O^{opp})^{opp} = O$.
@end tex
@ifinfo
 O,  (O^opp)^opp = O.
@end ifinfo
@smallexample
@c example
LIB "ncalg.lib";
def r = makeUsl2();
setring r;
matrix m[3][4];
poly   p  = (h^2-1)*f*e;
vector v  = [1,e*h,0,p];
ideal  i  = h*e, f^2*e,h*f*e;
m         = e,f,h,1,0,h^2, p,0,0,1,e^2,e*f*h+1;
module mm = module(m);
def b     = opposite(r);
// we will oppose these objects: p,v,i,m,mm
setring b; b;
poly P    = oppose(r,p);
vector V  = oppose(r,v);
ideal  I  = oppose(r,i);
matrix M  = oppose(r,m);
module MM = oppose(r,mm);
setring r;   // now let's check the correctness:
// print compact presentations of objects
print(matrix(oppose(b,P)-p));
print(matrix(oppose(b,V)-v));
print(matrix(oppose(b,I)-i));
print(matrix(oppose(b,M)-m));
print(matrix(oppose(b,MM)-mm));
@c example
@end smallexample
@end table
@c ref
See
@ref{envelope};
@ref{opposite}.
@c ref

@c ---------------------------------------
@node opposite, preimage @value{PSUFFIX}, oppose, Functions @value{PSUFFIX}
@section opposite
@cindex opposite

@table @code
@item @strong{Syntax:}
@code{opposite (} ring_name @code{)}
@item @strong{Type:}
ring
@item @strong{Purpose:}
creates an opposite algebra of a given algebra.
@item @strong{Note:}
activate the ring with the @code{setring} command.
@* An opposite algebra of a given algebra (@math{A},.) is
an algebra (@math{A},*) with the same vectorspace but with the opposite
multiplication, i.e.
@*
@tex
$\forall \; f,g \in A^{opp}$, a new multiplication $*$ on $A^{opp}$
is defined to be $f*g := g \cdot f$.
@end tex

@ifinfo
for any f,g in A_opp, a multiplication @code{*} on A_opp is defined to
be f @code{*} g := gf.
@end ifinfo

@item @strong{Remark:}
Starting from the variables x_1,...,x_N and the ordering @code{<}
of the given algebra,
an opposite algebra will have variables X_N,...,X_1
(where the case and the position are reverted). Moreover, it is
equipped with an opposed ordering @code{<_opp} (it is given
by the matrix, obtained from the matrix ordering of @code{<}
with the reverse order of columns).
@smallexample
@c example
LIB "ncalg.lib";
def B = makeQso3(3);
// this algebra is a quantum deformation of U(so_3),
// where the quantum parameter is a 6th root of unity
setring B; B;
def Bopp = opposite(B);
setring Bopp;
Bopp;
@c example
@end smallexample
@end table
@c ref
See
@ref{envelope};
@ref{oppose}.
See also a Section @ref{Matrix orderings}.
@c ref

@c ---------------------------------------
@node preimage @value{PSUFFIX}, quotient @value{PSUFFIX}, opposite, Functions @value{PSUFFIX}
@section preimage @value{PSUFFIX}
@cindex preimage @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{preimage (} ring_name@code{,} map_name@code{,} ideal_name @code{)}
@*@code{preimage (} ring_name@code{,} ideal_expression@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the preimage of an ideal under a given map.
The second argument has to be a map from the basering to the given ring
(or an ideal defining such a map),
and the ideal has to be an ideal in the given ring.
@item @strong{Note:}
To compute the kernel of a map, the preimage of zero has to be determined.
Hence there is no special command for computing the kernel of a map in
@sc{Plural}.
@item @strong{Remark:}
In the noncommutative case, it is implemented only for maps @math{A} -> @math{B}, where @math{A} is  a commutative ring.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
ring   R = 0,a,dp;
def Usl2 = makeUsl2();
setring Usl2;
poly  C = 4*e*f+h^2-2*h;
// C is a central element of U(sl2)
ideal I = e^3, f^3, h^3-4*h;
ideal J = twostd(I); // two-sided GB
ideal K = std(I);    // left GB
map Phi = R,C;
setring R;
ideal PreJ = preimage(Usl2,Phi,J);
// the central character of J
PreJ;
factorize(PreJ[1],1);
// hence, there are two simple characters for J
ideal PreK = preimage(Usl2,Phi,K);
// the central character of K
PreK;
factorize(PreK[1],1);
// hence, there are three simple characters for K

@c example
@end smallexample
@end table
@c ref
See
@ref{map @value{PSUFFIX}};
@ref{ideal @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref



@c ---------------------------------------
@node quotient @value{PSUFFIX}, reduce @value{PSUFFIX}, preimage @value{PSUFFIX}, Functions @value{PSUFFIX}
@section quotient @value{PSUFFIX}
@cindex quotient @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{quotient (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quotient (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Syntax:}
@code{quotient (} module_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the ideal quotient, resp.@: module quotient. Let @code{R} be the
basering, @code{I,J} ideals and @code{M} a module in
@ifinfo
R^n.
@end ifinfo
@tex
${\tt R}^n$.
@end tex
Then
@itemize
@item
@code{quotient(I,J)}=
@ifinfo
@{a in R | aJ in I @}
@end ifinfo
@tex
$\{a \in R \mid aJ \subset I\}$,
@end tex
@item
@code{quotient(M,J)}=
@ifinfo
@{b in R | bJ in M @}.
@end ifinfo
@tex
$\{b \in R^n \mid bJ \subset M\}$.
@end tex
@end itemize
@item @strong{Note:}
It an only be used for two-sided ideals (bimodules), otherwise the
result may have no meaning.

@item @strong{Example:}
@c // from [BGV], Ex.3.17, p.150, modified by q
@smallexample
@c example
//------ a very easy example ------------
ring r=(0,q),(x,y),Dp;
def R=nc_algebra(q,0); // this algebra is a quantum plane
setring R;
option(returnSB);
poly f1  = x^3+2*x*y^2+2*x^2*y;
poly f2  = y;
poly f1' = x^2;
poly f2' = x+y;
ideal i = f1,f2;
ideal I = twostd(i);
ideal j = f1',f2';
ideal J = twostd(j);
quotient(I,J);
kill r,R;
//------- a bit more complicated example
LIB "ncalg.lib";
def Usl2 = makeUsl2();
// this algebra is U(sl_2)
setring Usl2;
ideal i = e3,f3,h3-4*h;
ideal I = std(i);
poly  C = 4*e*f+h^2-2*h;
ideal H = twostd(C-8);
option(returnSB);
ideal Q = quotient(I,H);
// print a compact presentation of Q:
print(matrix(Q));
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node reduce @value{PSUFFIX}, ringlist @value{PSUFFIX}, quotient @value{PSUFFIX}, Functions @value{PSUFFIX}
@section reduce @value{PSUFFIX}
@cindex reduce @value{PSUFFIX}
@cindex NF
@table @code
@item @strong{Syntax:}

@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, ideal  or module to its @strong{left} normal form with
respect to an ideal or module represented by a left Groebner basis.
Returns 0 if and only if the polynomial (resp.@: vector, ideal, module)
is an element (resp.@: subideal, submodule) of the ideal (resp.@: module).
The result may have no meaning if the second argument is not a left Groebner basis.
@*The third (optional) argument 1 of type int forces a reduction which considers only the leading term and does no tail reduction.
@item @strong{Note:}
The commands @code{reduce} and @code{NF} are synonymous.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,a),(e,f,h),Dp;
matrix d[3][3];
d[1,2]=-h;  d[1,3]=2e;  d[2,3]=-2f;
def R=nc_algebra(1,d);
setring R;
// this algebra is a parametric U(sl_2)
ideal I = e2, f2, h2-1;
I = std(I);
// print a compact presentation of I
print(matrix(I));
ideal J = e, h-a;
J = std(J);
// print a compact presentation of J
print(matrix(J));
poly z=4*e*f+h^2-2*h;
// z is the central element of U(sl_2)
NF(z,I);  // the central character of I:
NF(z,J); // the central character of J:
poly nz = z - NF(z,J); // nz will belong to J
NF(nz,J);
@c example
@end smallexample
@end table

@c ref
See also
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node ringlist @value{PSUFFIX}, slimgb @value{PSUFFIX}, reduce @value{PSUFFIX}, Functions @value{PSUFFIX}
@section ringlist @value{PSUFFIX}
@cindex ringlist @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{ringlist (} ring_expression @code{)}
@*@code{ringlist (} qring_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
decomposes a ring/qring into a list of 6 (or 4 in the commutative case)
components.
@* The first 4 components are common both for the commutative and for the
non-commutative cases, the 5th and the 6th appear only in the non-commutative case.

@enumerate 5
@item square matrix with nonzero upper triangle, containing
structural coefficients of a G-algebra (this corresponds to the
matrix C from the definition of @ref{G-algebras})
@item square matrix, containing structural polynomials of a G-algebra
(this corresponds to the matrix D from the definition of @ref{G-algebras})
@end enumerate
@item @strong{Example:}
@smallexample
@c example
// consider the quantized Weyl algebra
ring r = (0,q),(x,d),Dp;
def RS=nc_algebra(q,1);
setring RS;
list l = ringlist(RS);
l;
// now, change the relation d*x = q*x*d +1
// into the relation d*x=(q2+1)*x*d + q*d + 1
matrix S = l[5]; // matrix of coefficients
S[1,2] = q^2+1;
l[5] = S;
matrix T = l[6]; // matrix of polynomials
T[1,2] = q*d+1;
l[6] = T;
def rr = ring(l);
setring rr; rr;
// compare with the ring we started with:
setring RS; RS;
@c example
@end smallexample
@end table

@c ref
See also
@ref{ring @value{PSUFFIX}};
@ref{ringlist}.
@c ref


@c ---------------------------------------
@node slimgb @value{PSUFFIX}, std @value{PSUFFIX}, ringlist @value{PSUFFIX}, Functions @value{PSUFFIX}
@section slimgb @value{PSUFFIX}
@cindex slimgb @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{slimgb (} ideal_expression@code{)}

@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns a left Groebner basis of a left ideal with respect to the
global monomial ordering of the basering.
@item @strong{Note:}
The commutative algorithm is described in the diploma thesis of Michael Brickenstein "Neue Varianten zur Berechnung von Groebnerbasen",
written 2004 under supervision of G.-M. Greuel in Kaiserslautern.

It is designed to keep polynomials slim (short with small coefficients).
Currently best results are examples over function fields (parameters).

The current implementation may not be optimal for weighted degree orderings.

The program only supports the options @code{prot}, which will give protocol output and @code{redSB} for returning a reduced Groebner basis.
The protocol messages of @code{slimgb} mean the following:
@* @code{M[n,m]} means a parallel reduction of @code{n} elements with @code{m} non-zero output elements,
@* @code{b} notices an exchange trick described in the thesis and
@* @code{e} adds a reductor with non-minimal leading term.

For a detailed commutative example see @ref{slim Groebner bases}.

@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def U = makeUsl(2);
// U is the U(sl_2) algebra
setring U;
ideal I = e^3, f^3, h^3-4*h;
option(redSB);
ideal J = slimgb(I);
J;
// compare slimgb with std:
ideal K = std(I);
print(matrix(NF(K,J)));
print(matrix(NF(J,K)));
// hence both Groebner bases are equal
@c example
@end smallexample
@end table
@c ref
See
@ref{option};
@ref{std @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node std @value{PSUFFIX}, subst  @value{PSUFFIX}, slimgb @value{PSUFFIX}, Functions @value{PSUFFIX}
@section std @value{PSUFFIX}
@cindex std @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} poly_expression @code{)}
@*@code{std (} module_expression@code{,} vector_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis (see @ref{Groebner bases in G-algebras} for a definition)
of an ideal or module with respect to the
monomial ordering of the basering.
@c is a set of generators such that
@c the leading terms generate the leading ideal, resp.@: module.

Use an optional second argument of type poly, resp.@: vector,
to construct the Groebner basis from an already computed one (given as the
first argument) and one additional generator (the second argument).
@item @strong{Note:}
To view the progress of long running computations, use
@code{option(prot)}.
@ifset singularmanual
(@pxref{option}(prot)).
@end ifset

@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def R = makeUsl2();
// this algebra is U(sl_2)
setring R;
ideal I = e2, f2, h2-1;
I=std(I);
I;
kill R;
//------------------------------------------
def RQ = makeQso3(3);
// this algebra is U'_q(so_3),
// where Q is a 6th root of unity
setring RQ;
RQ;
ideal J=x2, y2, z2;
J=std(J);
J;
@c example
@end smallexample
@end table
@c ref
See also
@ref{ideal @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref


@c -------------------------------------------------
@node subst  @value{PSUFFIX}, syz @value{PSUFFIX}, std @value{PSUFFIX}, Functions @value{PSUFFIX}
@section subst @value{PSUFFIX}
@cindex subst @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{subst (} poly_expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} vector _expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} ideal_expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} module _expression,ring_variable, poly_expression @code{)}

@item @strong{Type:}
poly, vector, ideal or module (corresponding to the first argument)

@item @strong{Purpose:}
 substitutes a ring variable by a polynomial.

@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def R = makeUsl2();
// this algebra is U(sl_2)
setring R;
poly C  = e*f*h;
poly C1 = subst(C,e,h^3);
C1;
poly C2 = subst(C,f,e+f);
C2;
@c example
@end smallexample
@end table
@c ref
@c ref


@c -------------------------------------------------
@node syz @value{PSUFFIX}, twostd, subst  @value{PSUFFIX}, Functions @value{PSUFFIX}
@section syz @value{PSUFFIX}
@cindex syz @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e., the module of relations of the given
generators) of the ideal, resp.@: module.
@item @strong{Note:}
if @code{S} is a matrix of a left syzygy module of left submodule given by matrix @code{M}, then
@code{transpose(S)*transpose(M) = 0}.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def R = makeQso3(3);
setring R;
option(redSB);
// we wish to have completely reduced bases:
option(redTail);
ideal tst;
ideal J = x3+x,x*y*z;
print(syz(J));
ideal K = x+y+z,y+z,z;
module S = syz(K);
print(S);
tst = ideal(transpose(S)*transpose(K));
// check the property of a syzygy module (tst==0):
size(tst);
 // now compute the Groebner basis of K ...
K = std(K);
// ... print a matrix presentation of K ...
print(matrix(K));
S = syz(K); // ... and its syzygy module
print(S);
tst = ideal(transpose(S)*transpose(K));
// check the property of a syzygy module (tst==0):
size(tst);
// but the "commutative" syzygy property does not hold
size(ideal(matrix(K)*matrix(S)));
@c example
@end smallexample
@end table
@c ref
See also
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{mres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@c ref


@c ------------------------------
@node twostd, vdim @value{PSUFFIX}, syz @value{PSUFFIX}, Functions @value{PSUFFIX}
@section twostd
@cindex twostd

@table @code
@item @strong{Syntax:}
  @code{twostd(} ideal_expression@code{)};
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis of the two-sided ideal,
generated by the input, treated as a set of two-sided generators.
@ifset singularmanual
see @ref{std}
@end ifset
@item @strong{Remark:}
There are algebras with no two-sided ideals except 0 and the
whole algebra (like Weyl algebras).
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def U = makeUsl2(); // this algebra is U(sl_2)
setring U;
ideal i= e^3, f^3, h^3 - 4*h;
option(redSB);
option(redTail);
ideal I = std(i);
print(matrix(I)); // print a compact presentation of I
ideal J = twostd(i);
// print a compact presentation of J:
print(matrix(ideal(J[1..6]))); // first 6 gen's
print(matrix(ideal(J[7..size(J)]))); // the rest of gen's
// compute the set of elements present in J but not in I
ideal K = NF(J,I);
K = K+0; // simplify K
print(matrix(K));
@c example
@end smallexample
@end table


@c -------------------------------------------------------------------------
@c @node vdim @value{PSUFFIX},Comparison between Singular and Plural functions , twostd, Functions @value{PSUFFIX}
@node vdim @value{PSUFFIX},, twostd, Functions @value{PSUFFIX}
@section vdim @value{PSUFFIX}
@cindex vdim @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{vdim (} ideal_expression @code{)}
@*@code{vdim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the vector space dimension of the
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the leading terms of the given generators.
@* If the factor-module is not of finite dimension, -1 is returned.

If the generators form a Groebner basis,
this is the same as the vector space dimension of the
factor-module.

@item @strong{Note:}
In the noncommutative case, a ring modulo an ideal has a ring stucture if and only if the ideal is two-sided.
@item @strong{Example:}
@smallexample
@c example
ring R=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;  d[1,3]=2x;  d[2,3]=-2y;
def RS=nc_algebra(1,d); //U(sl_2)
setring RS;
option(redSB); option(redTail);
ideal I=x3,y3,z3-z;
I=std(I);
I;
vdim(I);

@c example
@end smallexample
@end table
@c ref
See also
@ref{ideal @value{PSUFFIX}};
@ref{std @value{PSUFFIX}};
@ref{kbase @value{PSUFFIX}}.
@c ref

@c @node Comparison between Singular and Plural functions, ,vdim @value{PSUFFIX}, Functions @value{PSUFFIX}
@c @section Comparison between Singular and Plural functions
@c @cindex Singular vs Plural

@c @multitable @columnfractions .45 .45
@c @item @code{SINGULAR} @tab @code{PLURAL}
@c @item @ref{std}       @tab @ref{std  @value{PSUFFIX}}
@c @item @ref{deg}       @tab deg
@c @item @code{---}      @tab @ref{twostd}
@c @item @ref{det}       @tab @code{---}
@c @end multitable


@c @c ---------------------------------------
@c @node Control structures @value{PSUFFIX}, System variables @value{PSUFFIX}, Functions @value{PSUFFIX}, Functions and system variables @value{PSUFFIX}
@c @section Control structures @value{PSUFFIX}
@c @cindex Control structures @value{PSUFFIX}

@c See SINGULAR Manual
@c @ifset singularmanual
@c @c ref
@c (@ref{Control structures})
@c @c ref
@c @end ifset

@c @c ---------------------------------------
@c @node System variables @value{PSUFFIX},  , Control structures @value{PSUFFIX}, Functions and system variables @value{PSUFFIX}
@c @section System variables @value{PSUFFIX}
@c @cindex System variables @value{PSUFFIX}

@c See SINGULAR Manual


@c @ifset singularmanual
@c (@pxref{System variables})
@c @end ifset


