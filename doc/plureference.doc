@comment -*-texinfo-*-
@comment $Id: plureference.doc,v 1.3 2003-02-06 15:51:39 levandov Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plureference.info
@settitele PLURAL
@node Top, Functions and system variables
@menu
* Functions and system variables::
@end menu
@node  Functions and system variables,Mathematical background , Data types, Top
@chapter Functions and system variables
%**end
@end ignore


-----------------------------
@menu
* Functions::
* Control structures::
* System variables::
@end menu

@c ---------------------------------------
@node Functions, Control structures, Functions and system variables, Functions and system variables
@section Functions
@cindex Functions

This section gives a complete reference of all functions, commands and
special variables of the @sc{Plural} kernel (i.e., all built-in
commands).

The general syntax of a function is
@format
                   [target =] function_name (<arguments>);
@end format


@menu
* bracket::
* minres::
* mres::
* nres::
* option::
* plural::
* reduce::
* res::
* std::
* syz:: 
* twostd::
@end menu



@c -----------------------------
@node bracket, memory,,Functions
@subsection bracket

@table @code
@item @strong{Syntax:}
@code{system (}"bracket", poly_expression p, poly_expression q @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
Computes the Lie bracket @code{[p,q]=pq-qp} of the first polynomial with
the second in a special way.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
// it is Quantum deformation of U(so_3).
poly p=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z;
// it is the central element  
p=p^3;
p;
poly q=(x+Q*y+Q^2*z)^4;
q;
system("bracket",p,q);
@c example
@end smallexample 
@end table


@c ---------------------------------------
@node  memory, minres,bracket, Functions
@subsection memory
@cindex memory
@cindex memory managment
@table @code
@item @strong{Syntax:}
@code{memory (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns statistics concerning the memory management:
@itemize @bullet
@item @code{memory(0)} is the number of active (used) bytes,
@item @code{memory(1)} is the number of bytes allocated from the
operating system,
@item @code{memory(2)} is the maximal number of bytes ever allocated from the
operating system during the current @sc{Singular} session.
@end itemize
@item @strong{Note:}
To monitor the memory usage during ongoing computations the option
@code{mem} should be set (using the command @code{option(mem);}, see
also @ref{option}).
@item @strong{Example:}
@smallexample
@c example
  ring r=0,(x(1..500)),dp;
  poly p=(x(1)+x(500))^50;
  proc ReportMemoryUsage()
  {  "Memory currently used by SINGULAR     :",memory(0),"Byte (",
     memory(0)/1023, "KByte)" +newline+
     "Memory currently allocated from system:",memory(1), "Byte (",
     memory(1)/1023, "KByte)";
     "Maximal memory allocated from system  :",memory(2), "Byte (",
     memory(2)/1023, "KByte)";
  }
  ReportMemoryUsage();
  kill p;
  ReportMemoryUsage(); // less memory used: p killed
  kill r;
  ReportMemoryUsage(); // even less memory: r killed
@c example
@end smallexample
@end table
@c ref

@c ref


c ---------------------------------------
@node  minres, mres, memory, Functions
@subsection minres
@cindex minres

@table @code
@item @strong{Syntax:}
@code{minres (} list_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{minres (} resolution_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
minimizes a free resolution of an ideal or module
given by the list_expression, resp.@: resolution_expression.
@item @strong{Example:}

@c @smallexample
@c @c example
@c   ring r1=32003,(x,y),dp;
@c   ideal i=x5+xy4,x3+x2y+xy2+y3;
@c   resolution rs=lres(i,0);
@c   rs;
@c   list(rs);
@c   minres(rs);
@c   list(rs);
@c @c example
@c @end smallexample
@end table

@c @c ref
@c See
@c @ref{res};
@c @ref{mres};
@c @ref{sres}.
@c @c ref




@c ---------------------------------------
@node  mres, nres, minres, Functions
@subsection mres
@cindex mres
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression @code{)}
@*@code{mres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the
standard basis method. More precisely, let A=@code{matrix}(M), then @code{mres}
computes a free resolution of
@ifinfo
coker(A)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@end ifinfo
@tex
$coker(A)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M
\longrightarrow 0,$$
@end tex
where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are a minimal set of generators
of M if the basering is local or if M is homogeneous.
If the int expression k is not zero then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1...k.
@end tex
@ifinfo
Mi=module(Ai), i=1...k.
@end ifinfo
@*@code{mres(M,0)} returns a resolution consisting of at most n+2 modules,
where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then @code{L[1]} consists of a minimal set of generators of the input, @code{L[2]}
consists of a minimal set of generators for the first syzygy module of
@code{L[1]}, etc., until @code{L[p+1]}, such that
@ifinfo
L[i]<>0 for i<=p,
@end ifinfo
@tex
${\tt L[i]}\neq 0$ for $i \le p$,
@end tex
 but @code{L[p+1]}, the first syzygy module of @code{L[p]},
is 0 (if the basering is not a qring).
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@c @smallexample
@c @c example
@c   ring r=31991,(t,x,y,z,w),ls;
@c   ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
@c           t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
@c   resolution L=mres(M,0);
@c   L;
@c   // projective dimension of M is 5
@c @c example
@c @end smallexample
@end table
@c @c ref
@c See
@c @ref{ideal};
@c @ref{hres};
@c @ref{lres};
@c @ref{module};
@c @ref{res};
@c @ref{sres}.
@c @c ref




@node  nres, option, mres, Functions
@subsection nres
@cindex nres
@table @code
@item @strong{Syntax:}
@code{nres (} ideal_expression@code{,} int_expression @code{)}
@*@code{nres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module M which is minimized from
the second module on (by the standard basis method).

More precisely, let
@tex
$A_1$=matrix(M),
@end tex
@ifinfo
A1=matrix(M),
@end ifinfo
then @code{nres} computes a free resolution of
@ifinfo
coker(A1)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@end ifinfo
@tex
$coker(A_1)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M\longrightarrow 0,$$
@end tex
@*where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are the given set of generators of M.
If the int expression k is not zero then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*@code{nres(M,0)} returns a list of n modules where n is the number of
variables of the basering.
Let @code{list L=nres(M,0);} then @code{L[1]=M} is identical to the input,
@code{L[2]} is a minimal set of generators for the first syzygy
module of  @code{L[1]}, etc.
@ifinfo
(L[i]=M_i
@end ifinfo
@tex
(${\tt L[i]}=M_i$
@end tex
in the notations from above).
@item @strong{Example:}
@c @smallexample
@c @c example
@c   ring r=31991,(t,x,y,z,w),ls;
@c   ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
@c           t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
@c   resolution L=nres(M,0);
@c   L;
@c @c example
@c @end smallexample
@end table
@c @c ref
@c See
@c @ref{ideal};
@c @ref{lres};
@c @ref{hres};
@c @ref{module};
@c @ref{mres};
@c @ref{res};
@c @ref{resolution};
@c @ref{sres}.
@c @c ref






@c ---------------------------------------
@node option, nres, plural , Functions
@subsection option
@cindex option
@table @code
@item @strong{Syntax:}
@code{option ()}
@item @strong{Type:}
string
@item @strong{Purpose:}
lists all defined options.
@*
@item @strong{Syntax:}
@code{option (} option_name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
sets an option.
@item @strong{Note:}
To disable an option, use the prefix @code{no}.
@*
@item @strong{Syntax:}
@code{option ( get )}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
dumps the state of all options to an intvec.
@*
@item @strong{Syntax:}
@code{option ( set,} intvec_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
restores the state of all options from an intvec (produced by
@code{option(get)}).
@sp 1
@item @strong{Values:}
The following options are used to manipulate the behavior of
computations and act like boolean switches. Use the prefix @code{no} to
disable an option. Notice that some options are ring dependent and reset
to their default values on a change of the current basering.
@table @asis
@c ---------
@item @code{prot}
@cindex prot, option
@cindex protocoll of computations
@cindex progress watch
shows protocol information indicating the
progress during the following computations:
@code{mres},
@code{minres},
@code{res},
@code{std},
@code{syz}.
@c ---------
@item @code{redSB}
@cindex redSB, option
@cindex reduced standard basis
computes a reduced standard basis in any standard basis computation.
@c ---------
@item @code{redTail}
@cindex redTail, option
reduction of the tails of polynomials during standard basis
computations. This option is ring dependent. By default, it is set for
rings with global degree orderings and not set for all other rings.
@c ---------

@end table
@*
The following options, which also control computations, are special,
since they are not manipulated by the @code{option} command but by a
direct assignment of a value. Reset the option by assigning the value 0;
the command @code{option(none)} will not reset them! If there is a
non-zero value assigned, the command @code{option()} prints the option.
@*
The last set of options controls the output of @sc{Plural}:
@table @asis
@item @code{mem}
@cindex mem, option
shows memory usage in square brackets (see @ref{memory}).

@c @smallexample
@c @c example
@c   option(prot);
@c   option();
@c   ring r=0,x,dp;
@c   degBound=22;
@c   option();
@c   intvec i=option(get);
@c   option(none);
@c   option(set,i);
@c   option();
@c @c example
@c @end smallexample
@end table

@*The output reported on @code{option(prot)} has the following meaning:
@multitable @columnfractions .01 .14 .11 .65

@item @tab @tab @tab
@item @tab @code{mres}
@tab @code{[}@math{d}@code{]}
@tab computations of the @math{d}-th syzygy module
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{minres}
@tab @code{[}@math{d}@code{]}
@tab minimizing of the @math{d}-th syzygy module
@item @tab @tab @tab
@item @tab @code{reduce}
@tab @code{r} @tab reduced a leading term
@item @tab @tab @tab
@item @tab @code{std}
@tab @code{[}@math{m}@code{:}@math{n}@code{]}
@tab internal ring change to poly representation with exponent bound
@math{m} and @math{n} words in exponent vector
@item @tab @tab @tab
@item @tab @code{syz} @tab @tab all characters: like the output of @code{std}
@end multitable

@c @c ref
@c See
@c @ref{std}.
@c @c ref








@c -----------------------------
@node plural,reduce, option ,Functions 
@subsection plural

@table @code
@item @strong{Syntax:}
@*@code{system(}"PLURAL", matrix_expression C, matrix_expression D @code{)} 
@*@code{system(}"PLURAL", number_expression n, matrix_expression D @code{)}
@*@code{system(}"PLURAL", matrix_expression C, poly_expression p @code{)}
@*@code{system(}"PLURAL", number_expression n, poly_expression p @code{)}
@item @strong{Type:}
@item @strong{Purpose:} 
Based on the given ring @code{r}, say, with "k" variables, strictly upper
triangular matrices with numbers @code{(C)} from the field of @code{r}
and polynomials from @code{r(D)}     

@item @strong{Example:}
@smallexample
@c example
ring r1=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
// it is Quantum deformation of U(so_3).
r1;
kill r1;
ring r2=0,(Xa,Xb,Xc,Ya,Yb,Yc,Ha,Hb),dp;
matrix d[8][8];
d[1,2]=-Xc; d[1,4]=-Ha; d[1,6]=Yb;
d[1,7]=2*Xa; d[1,8]=-Xa; d[2,5]=-Hb;
d[2,6]=-Ya; d[2,7]=-Xb; d[2,8]=2*Xb;
d[3,4]=Xb; d[3,5]=-Xa; d[3,6]=-Ha-Hb;
d[3,7]=Xc; d[3,8]=Xc; d[4,5]=Yc;
d[4,7]=-2*Ya; d[4,8]=Ya; d[5,7]=Yb;
d[5,8]=-2*Yb; d[6,7]=-Yc; d[6,8]=-Yc;
system("PLURAL",1,d);
// it is U(sl_3)
r2;
kill r2;
ring r3=0,(a,b,c,d),lp;
matrix c[4][4];
c[1,2]=1; c[1,3]=3; c[1,4]=-2;
c[2,3]=-1; c[2,4]=-3; c[3,4]=1;
system("PLURAL",c,0);
// it  is some quasi--commutative algebra
r3;
kill r3;
ring r4=0,(t,u,v,w),dp;
system("PLURAL",-1,0);
// it is anticommutative algebra
r4;
kill r4;
@c example
@end smallexample
@end table



@c ---------------------------------------
@node reduce, plural , , Functions
@subsection reduce
@cindex reduce
@cindex NF
@table @code
@item @strong{Syntax:}

@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} poly_expression@code{,} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} poly_expression@code{,} module_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} matrix_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} matrix_expression@code{,} module_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, ideal  or module to its normal form with respect to an ideal or module represented by a standard basis.
Returns 0 if and only if the polynomial (resp.@: vector, ideal, module)
is an element (resp.@: subideal, submodule) of the ideal (resp.@: module).
The result may have no meaning if the second argument is not a standard basis.
@*The third (optional) argument 1 of type int forces a reduction which considers only the leading term and does no tail reduction.
@*If a second argument @code{u} of type poly or matrix is given, the first argument @code{p} is replaced by @code{p/u}.
This works only for zero dimensional ideals (resp.@: modules) in the third argument and gives, even in a local ring, a reduced normal form which is the projection to the quotient by the ideal (resp.@: module).
One may give a degree bound in the fourth argument with respect to a weight vector in the fifth argument in order in order to make the third argument zero dimensional.
If some of the weights are zero, the procedure may not terminate!
@item @strong{Note:}
The commands @code{reduce} and @code{NF} are synonymous.
@item @strong{Example:}
@smallexample
@c example
  ring r1 = 0,(z,y,x),ds;
  poly s1=2x5y+7x2y4+3x2yz3;
  poly s2=1x2y2z2+3z8;
  poly s3=4xy5+2x2y2z3+11x10;
  ideal i=s1,s2,s3;
  ideal j=std(i);
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j);
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j,1);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal};
@ref{module};
@ref{vector};
@ref{std}.
@c ref

@c -----------------------------
@node  res, , , Functions
@subsection res
@cindex res





@c ---------------------------------------
@node std,syz,res, Functions
@subsection std
@cindex std
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} poly_expression @code{)}
@*@code{std (} module_expression@code{,} vector_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a standard basis of an ideal or module with respect to the
monomial ordering of the basering.
A standard basis is a set of generators such that
the leading terms generate the leading ideal, resp.@: module.


@*Use an optional second argument of type poly, resp.@: vector,
to construct the standard basis from an already computed one (given as the
first argument) and one additional generator (the second argument).
@item @strong{Note:}
@*To view the progress of long running computations, use
@code{option(prot)} (see @ref{option}(prot)).

@item @strong{Example:}
@smallexample
@c example
  // local computation
  ring r=32003,(x,y,z),ds;
  poly s1=1x2y+151xyz10+169y21;
  poly s2=1xz14+6x2y4+3z24;
  poly s3=5y10z10x+2y20z10+y10z20+11x3;
  ideal i=s1,s2,s3;
  ideal j=std(i);
  degree(j);
  // Hilbert driven elimination (standard)
  ring rhom=32003,(x,y,z,h),dp;
  ideal i=homog(imap(r,i),h);
  ideal j=std(i);
  intvec iv=hilb(j,1);
  ring rlex=32003,(x,y,z,h),lp;
  ideal i=fetch(rhom,i);
  ideal j=std(i,iv);
  j=subst(j,h,1);
  j[1];
  // Hilbert driven elimination (ideal is quasihomogeneous)
  intvec w=10,1,1;
  ring whom=32003,(x,y,z),wp(w);
  ideal i=fetch(r,i);
  ideal j=std(i);
  intvec iw=hilb(j,1,w);
  ring wlex=32003,(x,y,z),lp;
  ideal i=fetch(whom,i);
  ideal j=std(i,iw,w);
  j[1];
@c example
@end smallexample
@end table
@c @c ref
@c See
@c @ref{ideal};
@c @ref{ring};
@c @ref{option};
@c @ref{facstd};
@c @ref{fglm};
@c @ref{groebner};
@c @ref{mstd};
@c @ref{stdfglm};
@c @ref{stdhilb}.
@c @c ref


@c -------------------------------------------------
@node syz, trace, system, Functions
@subsection syz
@cindex syz
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e., the module of relations of the given
generators) of the ideal, resp.@: module.
@item @strong{Example:}
@smallexample
@c example
  ring R=0,(x,y),(c,dp);
  ideal i=x,y;
  syz(i);
@c example
@end smallexample
@end table
@c @c ref
@c See
@c @ref{ideal};
@c @ref{lres};
@c @ref{hres};
@c @ref{module};
@c @ref{mres};
@c @ref{nres};
@c @ref{res};
@c @ref{sres.
@c @c ref




@c ------------------------------
@node twostd, ,syz, Functions 
@subsection twostd
@cindex twostd

@table @code
@item @strong{Syntax:}
@code{system (}"twostd", ideal_expression@code{)}; 
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis of the two-sided ideal ,
generated by the input, treated as a set of two-sided generators.
@item @strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d); 
// it is algebra U(sl_2)
int N=3;
poly f=1;
for(int n=0;n<=N;n++)
{ 
  f=f*(z+N-2*n);
}
f;
ideal i=x^(N+1),y^(N+1),f;
option(redSB);
option(redTail);
ideal I=std(i);
I;
ideal J=system("twostd",i);
J;
@c example
@end smallexample
@item @strong{Remark:}
There are algebras with no two-sided ideals (like Weyl algebras)
@end table





@c ------------------------------------
@c ---------------------------------------
@node Control structures, System variables, Functions, Functions and system variables
@section Control structures
@cindex Control structures
@cindex block
@ifinfo
@*List of all supported control structures.
@end ifinfo
@menu
* break::
* breakpoint::
* continue::
* else::
* export::
* for::
* if::
* keepring::
* quit::
* return::
* while::
* ~::
@ifset namespaces
* exportto::
* importfrom::
* load::
* unload::
@end ifset
@end menu

A sequence of commands surrounded by curly brackets (@code{@{} and
@code{@}}) is a so called block. Blocks are used in @sc{Singular} in
order to define procedures and to collect commands belonging to
@code{if}, @code{else}, @code{for} and @code{while} statements and to the
@code{example} part in libraries. Even if
the sequence of statements consists of only a single command it has to be
surrounded by curly brackets!
Variables which are defined inside a block
are not local to that block. Note that there is no ending semicolon at
the end of the block.
@table @code
@item @strong{Example:}
@smallexample
if ( i>j )
@{
  // This is the block
  int temp;
  temp=i;
  i=j;
  j=temp;
  kill temp;
@}
@end smallexample
@end table

@c ---------------------------------------
@node break, breakpoint, Control structures, Control structures
@subsection break
@cindex break
@table @code
@item @strong{Syntax:}
@code{break;}
@item @strong{Purpose:}
leaves the innermost @code{for} or @code{while} block.
@item @strong{Example:}
@smallexample
while (1)
@{
  @dots{}
  if ( @dots{} )
  @{
    break; // leave the while block
  @}
@}
@end smallexample
@end table
@c ref
See
@ref{Control structures};
@ref{for};
@ref{while}.
@c ref
@c ---------------------------------------
@node breakpoint, continue, break, Control structures
@subsection breakpoint
@cindex breakpoint
@table @code
@item @strong{Syntax:}
@code{breakpoint(} proc_name @code{);}
@*@code{breakpoint(} proc_name@code{,} line_no @code{);}
@item @strong{Purpose:}
sets a breakpoint at the beginning of the specified procedure or
at the given line.
@strong{Note:} Line number 1 is the first line of a library (for
procedures from libraries), resp.@: the line with the @code{@{}.
@*A line number of -1 removes all breakpoint from that procedure.
@item @strong{Example:}
@smallexample
@c example
breakpoint(groebner);
breakpoint(groebner, 176);
breakpoint(groebner, -1);
@c example
@end smallexample
@end table
@c ref
See
@ref{~};
@c ref

@c ---------------------------------------
@node continue, else, breakpoint, Control structures
@subsection continue
@cindex continue
@table @code
@item @strong{Syntax:}
@code{continue;}
@item @strong{Purpose:}
skips the rest of the innermost @code{for} or @code{while} loop und jumps
to the beginning of the block. This command is only valid inside a
@code{for} or a @code{while} construction.
@item @strong{Note:}
Unlike the C-construct it @strong{does not execute the increment statement}.
The command @code{continue} is mainly for internal use.
@item @strong{Example:}
@smallexample
for (int i = 1 ; i<=10; i=i+1)
@{
   @dots{}
   if (i==3) @{ i=8;continue; @}
     // skip the rest if i is 3 and
     // continue with the next i: 8
   i;
@}
@expansion{} 1
@expansion{} 2
@expansion{} 8
@expansion{} 9
@expansion{} 10
@end smallexample
@end table
@c ref
See
@ref{Control structures};
@ref{for};
@ref{while}.
@c ref
@c ---------------------------------------
@node else, export, continue, Control structures
@subsection else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} true_block @code{else} false_block
@item @strong{Purpose:}
executes false_block if the boolean_expression of the @code{if} statement
is false. This command is only valid in combination with an @code{if}
command.
@item @strong{Example:}
@smallexample
int i=3;
if (i > 5)
@{
  "i is bigger than 5";
@}
else
@{
  "i is smaller than 6";
@}
@expansion{} i is smaller than 6
@end smallexample
@end table

@c @c ref
@c See
@c @ref{if};
@c @ref{boolean expressions};
@c @ref{Control structures}.
@c @c ref
@c ---------------------------------------
@ifset namespaces
@node export, exportto, else, Control structures
@end ifset
@ifclear namespaces
@node export, for, else, Control structures
@end ifclear
@subsection export
@cindex export
@table @code
@item @strong{Syntax:}
@code{export} name @code{;}
@*@code{export} list_of_names @code{;}
@item @strong{Purpose:}
converts a local variable of a procedure to a global one.
@item @strong{Note:}
Objects defined in a ring are not automatically exported
when exporting the ring (use @code{keepring} instead).
@item @strong{Example:}
@smallexample
proc p1
@{
  int i,j;
  export(i);
  intmat m;
  listvar();
  export(m);
@}
p1();
@expansion{} // m                    [1]  intmat 1 x 1
@expansion{} // j                    [1]  int 0
@expansion{} // i                    [0]  int 0
listvar();
@expansion{} // m                    [0]  intmat 1 x 1
@expansion{} // i                    [0]  int 0
@end smallexample
@end table

@ifset namespaces
@c ref
See
@ref{exportto}; @ref{keepring}.
@c ref
@end ifset
@ifclear namespaces
@c ref
See
@ref{keepring}.
@c ref
@end ifclear
@c ---------------------------------------
@ifset namespaces
@c ---------------------------------------
@node exportto, importfrom, export, Control structures
@subsection exportto
@cindex exportto
@table @code
@item @strong{Syntax:}
@code{exportto(} package_name @code{, }name @code{);}
@*@code{exportto(} package_name @code{,} list_of_names @code{);}
@item @strong{Purpose:}
converts a local variable of a procedure to a global one.
package_name can be @code{Current}, @code{Up}, @code{Top} or any other
identifier of type package.

@item @strong{Note:}
Objects defined in a ring are not automatically exported
when exporting the ring (use @code{keepring} instead).
@item @strong{Example:}
@smallexample
proc p1
@{
  int i,j;
  exportto(Current,i);
  intmat m;
  listvar();
  exportto(Top,m);
@}
p1();
@expansion{} // m                    [1]  intmat 1 x 1
@expansion{} // j                    [1]  int 0
@expansion{} // i                    [0]  int 0
listvar();
@expansion{} // m                    [0]  intmat 1 x 1
@expansion{} // i                    [0]  int 0
@end smallexample
@end table
@c ref
See @ref{keepring}.
@c ref
@c ---------------------------------------
@node importfrom, load, exportto, Control structures
@subsection importfrom
@cindex importfrom
@table @code
@item @strong{Syntax:}
@code{importfrom(}@code{);}
@end table

@c ref
See @ref{exportto}.
@c ref
@c ---------------------------------------
@node load, unload, importfrom, Control structures
@subsection load
@cindex load
@table @code
@item @strong{Syntax:}
@code{load(} string_expression @code{);}
@*@code{load(}string_expression@code{,"with");}
@item @strong{Type:}
none
@item @strong{Purpose:}
@c reads a library of procedures or functions from a file. If the given
@c filename does not start with  @kbd{~}, @kbd{.} or @kbd{/}, the following
@c directories are searched for (in that order): the current directory, the
@c directories given in the environment variable @code{SINGULARPATH}, some
@c default directories relative to the location of the @sc{Singular}
@c executable program, and finally some default absolute directories. You
@c can view the search path which @sc{Singular} uses to locate its
@c libraries, by starting up @sc{Singular} with the option @code{-v}, or by
@c issuing the command @code{system("with");"}.
reads a library of procedures from a file. If the given filename does
not start with @kbd{.} or @kbd{/}, the following directories are
searched for (in that order): the current directory, the directories given in
the environment variable @code{SINGULARPATH}, some default directories
relative to the location of the @sc{Singular} executable program, and
finally some default absolute directories. You can view the search path
which @sc{Singular} uses to locate its libraries, by starting up
@sc{Singular} with the option @code{-v}, or by issuing the command
@code{system("with");"}.

Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
library @code{standard.lib} is automatically loaded at start-up time.
@end table

All loaded libraries are displayed by the @code{listvar(package);}
command:
@smallexample
@c example
  option(loadLib);   // show loading of libraries;
                     // standard.lib is loaded
  listvar(package);
                     // the names of the procedures of inout.lib
  load("inout.lib"); // are now known to Singular
  listvar(package);
@c example
@end smallexample

Each time a library @ref{Singular library} / dynamic module @ref{dynamic
module} is loaded, the corresponding namespace is created, if it does
not already exist.

The name of this namespace corresponding to a Singular library is
derived from the name of the library file. The first letter is
capitalized and everything to right of the left-most dot is
dropped.
For a dynamic module the packagename is hard-coded in the binary file.

@sc{Singular} also supports autoloading of packages.
To use this features, just specify the identifier by its full name:

@smallexample
@c example error
  listvar(package);
  Inout::version;     // full name of a variable in the package Inout
  listvar(package);   // the package Inout has been autoloaded
@c example
@end smallexample

For autoloading the base of the filename is generated by converting the
packagename to lowercase letters. The search is done in the standard
@sc{Singular} search path, first looking for a file of this name, and then
appending to the base @code{.lib}, @code{.so}, @code{.sl} (in this order).


An identifier of type @code{package} is created and all procedures are
stored in that package.
Before loading the type of the file is checking. For an Singular
library, the package is set as filename until the first '.' in the name
with an uppercase first letter. If the library to load is an binary file
with procedures written in an higher language (e.g. C, C++, ...) the
package name s hard-code in the library.


The second argument @code{"with"} will automatically export all none
static procedures to the toplevel.


Only the names of the procedures in the library are loaded, the body of
the procedures is read during the first call of this procedure. This minimizes
memory consumption by unused procedures.  When @sc{Singular} is started
with the @code{-q} or @code{--quiet} option, no message about the
loading of a library is displayed.  More exactly, option @code{-q} (and
likewise @code{--quiet}) unsets option @code{loadLib} to inhibit
monitoring of library loading (@pxref{option}).

Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
library @code{standard.lib} is automatically loaded at start-up time.

@smallexample
@c example
  option(loadLib); // show loading of libraries; standard.lib is loaded
                   // the names of the procedures of inout.lib
  load("inout.lib"); // are now known to Singular
  listvar();
@c example
@end smallexample
@c @c ref
@c See
@c @ref{Command line options};
@c @ref{Procedures and libraries};
@c @ref{SINGULAR libraries};
@c @ref{proc};
@c @ref{standard_lib};
@c @ref{package};
@c @ref{string};
@c @ref{system}.
@c @ref{LIB};
@c @ref{exportto};
@c @ref{importfrom};
@c @ref{Namespaces};
@c @ref{dynamic module}
@c @c ref

@c ---------------------------------------
@node unload, for, load, Control structures
@subsection unload
@cindex unload
@table @code
@item @strong{Syntax:}
@code{unload(}@code{);}
@end table
@c ---------------------------------------
@end ifset
@c ---------------------------------------
@ifset namespaces
@node for, if, unload, Control structures
@end ifset
@ifclear namespaces
@node for, if, export, Control structures
@end ifclear
@subsection for
@cindex for
@table @code
@item @strong{Syntax:}
@code{for (} init_command@code{;}
boolean_expression@code{;}
iterate_commands@code{)} block
@item @strong{Purpose:}
repetitive, conditional execution of a command block.
@*The command init_command is executed first. Then boolean_expression is
evaluated. If its value is TRUE the block is executed, otherwise the
@code{for} statement is complete. After each execution of the block, the
command iterate_command is executed and boolean_expression is
evaluated. This is repeated until boolean_expression evaluates to FALSE.
@*The command @code{break;} leaves the innermost @code{for} construct.
@item @strong{Example:}
@smallexample
// sum of 1 to 10:
int s=0;
for (int i=1; i<=10; i=i+1)
@{
   s=s+i;
@}
s;
@expansion{} 55
@end smallexample
@end table
@c ref
See
@ref{Control structures};
@ref{boolean expressions};
@ref{while};
@ref{if};
@ref{break};
@ref{continue}.
@c ref
@c ---------------------------------------
@node if, keepring, for, Control structures
@subsection if
@cindex if
@cindex else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} true_block
@*@code{if (} boolean_expression @code{)} true_block @code{else} false_block
@item @strong{Purpose:}
executes true_block if the boolean condition is true. If the @code{if}
statement is followed by an @code{else} statement and the boolean
condition is false, then false_block is executed.
@item @strong{Example:}
@smallexample
int i = 9;
matrix m[i][i];
if (i > 5 and typeof(m) == "matrix")
@{
  m[i][i] = i;
@}
@end smallexample
@end table
@c ref
See
@ref{else};
@ref{break};
@ref{Control structures};
@ref{boolean expressions}.
@c ref
@c ---------------------------------------
@node keepring, quit, if, Control structures
@subsection keepring
@cindex keepring
@table @code
@item @strong{Syntax:}
@code{keepring} name @code{;}
@item @strong{Purpose:}
moves the specified ring to the next (upper) level. This command can only
be used inside of procedures and it should be the last command before the
@code{return} statement. There it provides the possibility to keep
a ring which is local to the procedure (and its objects) accessible after
the procedure ended without making the ring global.
@item @strong{Example:}
@smallexample
proc P1
@{
  ring r=0,x,dp;
  keepring r;
@}
proc P2
@{
  "inside P2: " + nameof(basering);
  P1();
  "inside P2, after call of P1: " + nameof(basering);
@}
ring r1= 0,y,dp;
P2();
@expansion{} inside P2: r1
@expansion{} inside P2, after call of P1: r
"at top level: " + nameof(basering);
@expansion{} at top level: r1
@end smallexample
@end table
@c ref
See
@ref{ring}.
@c ref
@c ---------------------------------------
@node quit, return, keepring, Control structures
@subsection quit
@cindex quit
@cindex exit
@table @code
@item @strong{Syntax:}
@code{quit;}
@item @strong{Purpose:}
quits @sc{Singular};
works also from inside a procedure. The commands @code{quit} and
@code{exit} are synonymous.
@item @strong{Example:}
@smallexample
  quit;
@end smallexample
@end table
@c ---------------------------------------
@node return, while, quit, Control structures
@subsection return
@cindex return
@table @code
@item @strong{Syntax:}
@code{return (} expression_list @code{);}
@*@code{return ();}
@item @strong{Type:}
any
@item @strong{Purpose:}
returns the result(s) of a procedure and can only be used inside a
procedure. Note that the brackets are required even if no return value
is given.
@item @strong{Example:}
@smallexample
proc p2
@{
  int i,j;
  for(i=1;i<=10;i++)
  @{
    j=j+i;
  @}
  return(j);
@}
// can also return an expression list, i.e., more than one value
proc tworeturn ()
@{ return (1,2); @}
int i,j = tworeturn();
// return type may even depend on the input
proc type_return (int i)
@{
  if (i > 0) @{return (i);@}
  else @{return (list(i));@}
@}
// then we need def type (or list) to collect value
def t1 = type_return(1);
def t2 = type_return(-1);
@end smallexample
@end table
@c ref
See
@ref{Data types};
@ref{proc}.
@c ref
@c ---------------------------------------
@node while, ~ , return, Control structures
@subsection while
@cindex while
@table @code
@item @strong{Syntax:}
@code{while (}boolean_expression@code{)} block
@item @strong{Purpose:}
repetitive, conditional execution of block.
@*The boolean_expression is evaluated and if its value is TRUE, the
block gets executed. This is repeated until boolean_expression evaluates
to FALSE.  The command @code{break} leaves the innermost @code{while}
construction.
@item @strong{Example:}
@smallexample
int i = 9;
while (i>0)
@{
   // @dots{} // do something for i=9, 8, ..., 1
   i = i - 1;
@}
while (1)
@{
   // @dots{}   // do something forever
   if (i == -5) // but leave the loop if i is -5
   @{
     break;
   @}
@}
@end smallexample
@end table
@c @c ref
@c See
@c @ref{Control structures};
@c @ref{boolean expressions};
@c @ref{break}.
@c @c ref

@c ---------------------------------------
@node ~, , while, Control structures
@subsection ~ (break point)
@cindex ~
@cindex break point
@table @code
@item @strong{Syntax:}
@code{~;}
@item @strong{Purpose:}
sets a break point. Whenever @sc{Singular} reaches the command @code{~;}
in a sequence of commands it prompts for input. The user may now input
lines of @sc{Singular} commands. The line length cannot exceed 80
characters.
@sc{Singular} proceeds with the execution of the command following @code{~;}
as soon as it receives an empty line.
@item @strong{Example:}
@smallexample
proc t
@{
  int i=2;
  ~;
  return(i+1);
@}
t();
@expansion{} -- break point in t --
@expansion{} -- 0: called    from STDIN --
// here local variables of the procedure can be accessed
i;
@expansion{} 2
@expansion{} -- break point in t --

@expansion{} 3
@end smallexample
@end table


@c ---------------------------------------
@node System variables,  , Control structures, Functions and system variables
@section System variables
@cindex System variables
@ifinfo
@*List of all system variables.
@end ifinfo
@menu
* degBound::
* echo::
* minpoly::
* multBound::
* noether::
* printlevel::
* short::
* timer::
* TRACE var::
* rtimer::
* voice::
@end menu
@c ---------------------------------------
@c @node alternating, degBound, System variables, System variables
@c @subsection alternating
@c @cindex alternating
@c @table @code
@c @item @strong{Syntax:}
@c @code{alternating =} int_expression@code{;}
@c @*int_variable @code{= alternating;}
@c @item @strong{Purpose:}
@c describes the position of the first alternating variable in the current
@c basering, thus creating the tensor
@c product of a polynomial ring with an exterior algebra.
@c @*Remark: Setting @code{alternating=1;} defines the exterior algebra.
@c @item @strong{Note:}
@c These algebras are only available in those versions of
@c @sc{Singular} which are compiled with the SRING option.
@c The SRING version is
@c significantly slower for usual (commutative) ring operations.
@c @item @strong{Example:}
@c @example
@c   // define the exterior algebra in 3 variables x, y, z
@c   ring r=0,(x,y,z),dp;
@c   alternating=1;
@c   y*x;
@c   @expansion{} -1*xy
@c @end example
@c @end table
@c @c ref
@c See
@c @ref{ring};
@c @ref{int expressions}.
@c @c ref
@c @c -----------------------------------------------------
@node degBound, echo, System variables, System variables
@subsection degBound
@cindex degBound
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
The standard basis computation is stopped if the total
(weighted) degree
exceeds @code{degBound}.
@* @code{degBound} should not be used for a global ordering with inhomogeneous
input.
@*Reset this bound by setting @code{degBound} to 0.
@item @strong{Example:}
@smallexample
degBound = 7;
option();
@expansion{} //options for 'std'-command: degBound
ideal j=std(i);
degBound;
@expansion{} 7
degBound = 0; //resets degree bound to infinity
@end smallexample
@end table
@c ref
See
@ref{deg};
@ref{int};
@ref{option};
@ref{std}.
@c ref
@c -----------------------------------------------------
@node echo, minpoly, degBound, System variables
@subsection echo
@cindex echo
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
input is echoed if @code{echo} >= @code{voice}.
@*@code{echo} is a local setting for a procedure and defaulted to 0.
@*@code{echo} does not affect the output of commands.
@item @strong{Example:}
@c this example cannot be a computed one - echo interferes with -e
@smallexample
echo = 1;
int i = echo;
@expansion{} int i = echo;
@end smallexample
@end table
@c ref
See
@ref{int};
@ref{voice}.
@c ref

@c -----------------------------------------------------
@node minpoly, multBound, echo, System variables
@subsection minpoly
@cindex minpoly
@table @code
@item @strong{Type:}
number
@item @strong{Purpose:}
describes the coefficient field of the current basering as
an algebraic extension with the minimal polynomial equal to @code{minpoly}.
Setting the @code{minpoly} should be the first command after
defining the ring.
@item @strong{Note:}
The minimal polynomial has to be specified in the syntax of a polynomial.
Its variable is not one of the ring variables, but the algebraic element
which is being adjoined to the field.
Algebraic extensions in @sc{singular} are only possible over the rational
numbers or over Z/p, p a prime number.
@c @*@strong{Warning:}
@*@sc{Singular} does not check whether the given
polynomial is irreducible! It can be checked in advance with the
function 
@code{factorize} (@pxref{factorize}).

@item @strong{Example:}
@smallexample
@c example
  //(Q[i]/(i^2+1))[x,y,z]:
  ring Cxyz=(0,i),(x,y,z),dp;
  minpoly=i^2+1;
  i2;  //this is a number, not a poly
@c example
@end smallexample
@end table
@c ref
See
@ref{factorize};
@ref{ring}.
@c ref
@c -----------------------------------------------------
@node multBound, noether, minpoly, System variables
@subsection multBound
@cindex multBound
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
The standard basis computation is stopped if the ideal is
zero-dimensional in a ring with local ordering
and its multiplicity (@code{mult}) is lower than @code{multBound}.
@*Reset this bound by setting @code{multBound} to 0.
@item @strong{Example:}
@smallexample
multBound = 20;
option();
@expansion{}    //options for 'std'-command: multBound
ideal j=std(i);
multBound;
@expansion{} 20
multBound = 0;  //disables multBound
@end smallexample
@end table
@c ref
See
@ref{int};
@ref{mult};
@ref{option};
@ref{std}.
@c ref
@c -----------------------------------------------------
@node noether, printlevel, multBound, System variables
@subsection noether
@cindex noether
@table @code
@item @strong{Type:}
poly
@item @strong{Purpose:}
The standard basis computation in local rings
cuts off  all monomials above
(in the sense of the monomial ordering)
the monomial @code{noether} during the computation.
@*Reset @code{noether} by setting @code{noether} to 0.
@item @strong{Example:}
@smallexample
@c example
  ring R=32003,(x,y,z),ds;
  ideal i=x2+y12,y13;
  std(i);
  noether=x11;
  std(i);
  noether=0; //disables noether
@c example
@end smallexample
@end table
@c ref
See
@ref{poly};
@ref{std}.
@c ref
@c -----------------------------------------------------
@node printlevel, short, noether, System variables
@subsection printlevel
@cindex printlevel
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
sets the debug level for @code{dbprint}.
If @code{printlevel} >= @code{voice} then @code{dbprint} is equivalent to
@code{print}, otherwise nothing is printed.
@item @strong{Note:}
@xref{Procedures in a library}, for a small example about how this
is used for the display of comments while procedures are executed.
@item @strong{Example:}
@smallexample
@c example
  voice;
  printlevel=0;
  dbprint(1);
  printlevel=voice;
  dbprint(1);
@c example
@end smallexample
@end table
@c ref
See
@ref{int};
@ref{dbprint};
@ref{voice}.
@c ref
@c -----------------------------------------------------
@node short, timer, printlevel, System variables
@subsection short
@cindex short
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
the output of monomials is done in the short manner,
if @code{short} is non-zero. A C-like notion is used, if short is zero.
Both notations may be used as input.
@*The default depends on the names of the ring variables
(0 if there are names of variables longer than 1 character, 1 otherwise). Every
change of the basering sets @code{short} to the previous value for
that ring. In other words, the value of the variable @code{short} is
"ring-local".
@item @strong{Example:}
@smallexample
@c example
  ring r=23,x,dp;
  int save=short;
  short=1;
  2x2,x2;
  short=0;
  2x2,x2;
  short=save;  //resets short to the previous value
@c example
@end smallexample
@end table
@c ref
See
@ref{int}.
@c ref
@c -----------------------------------------------------
@node timer, TRACE var, short, System variables
@subsection timer
@cindex timer
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
@enumerate
@item
the CPU time (i.e, user and system time) used for each command is
printed if timer >0 , if this
time is bigger than a (customizable) minimal time and
if @code{printlevel+1 >= voice} (which is by default true on the
@sc{Singular} top level, but not true while procedures are executed).

@item
yields the used CPU time since the start-up of @sc{Singular} in a
(customizable) resolution.
@end enumerate

The default setting of @code{timer} is 0, the default minimal time is
0.5 seconds, and the default timer resolution is 1 (i.e., the default unit
of time is one second). The minimal time and timer resolution
can be set using the command line options @code{--min-time} and
@code{--ticks-per-sec} and can be checked using
@code{system("--min-time")} and @code{system("--ticks-per-sec")}.

How to use @code{timer} in order to measure the time for a sequence of
commands, see example below.

@item @strong{Note for Windows95/98:}
The value of the @code{timer} cannot be used (resp.@: trusted) when
@sc{Singular} is run under Windows95/98 (this is due to the shortcomings
of the Windows95/98 operating system). Use @ref{rtimer}, instead.

@item @strong{Example:}
@smallexample
@c example
  timer=1; // The time of each command is printed
  int t=timer; // initialize t by timer
  ring r=0,(x,y,z),dp;
  poly p=(x+2y+3z+4xy+5xz+6yz)^20;
  // timer as int_expression:
  t=timer-t;
  t;  // yields the time in ticks-per-sec (default 1)
      // since t was initialized by timer
  int tps=system("--ticks-per-sec");
  t/tps; // yields the time in seconds truncated to int
@c example
@end smallexample
@end table
@c ref
See
@ref{Command line options};
@ref{printlevel};
@ref{rtimer};
@ref{system};
@ref{voice}.
@c ref
@c ---------------------------------------
@node TRACE var, rtimer, timer, System variables
@subsection TRACE
@cindex TRACE

@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
sets level of debugging.
@table @asis
@item @code{TRACE=0}
no debugging messages are printed.
@item @code{TRACE=1}
messages about entering and leaving of procedures are displayed.
@item @code{TRACE=3}
messages about entering and leaving of procedures together with
line numbers are displayed.
@item @code{TRACE=4}
each line is echoed and the interpretation of commands
in this line is suspended until the user presses @code{RETURN}.
@end table
@*@code{TRACE} is defaulted to 0.
@*@code{TRACE} does not affect the output of commands.
@item @strong{Example:}
@smallexample
@c example
  TRACE=1;
  LIB "general.lib";
  sum(1..100);
@c example
@end smallexample
@end table
@c ref
See
@ref{int}.
@c ref
@c ---------------------------------------
@node rtimer, voice, TRACE var, System variables
@subsection rtimer
@cindex timer
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
identical to @code{timer} (@pxref{timer}), except that real times (i.e.,
wall-clock) times are reported, instead of CPU times. This can be
trusted on all operating systems (including Windows95/98).

@end table
@c ---------------------------------------
@node voice,, rtimer, System variables
@subsection voice
@cindex voice

@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
shows the nesting level of procedures.
@item @strong{Note:}
@xref{Guidelines for writing a library}, for an small example how this is used
for the display of comments while procedures are executed.
@item @strong{Example:}
@smallexample
@c example
  voice;
@c example
proc p
@{
  voice;
@};
p();
@expansion{} 2
@end smallexample
@end table
@c ref
See
@ref{dbprint};
@ref{listvar};
@ref{printlevel}.
@c ref
@c ---------------------------------------
