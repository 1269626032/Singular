  @comment -*-texinfo-*-
@comment $Id: plureference.doc,v 1.12 2003-04-25 18:34:57 levandov Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plureference.info
@settitele PLURAL
@node Top, Functions and system variables@value{PSUFFIX}, (dir), (dir)
@menu
* Functions and system variables@value{PSUFFIX}::
@end menu
@node  Functions and system variables@value{PSUFFIX},  , Top, Top
@chapter Functions and system variables@value{PSUFFIX}
%**end
@end ignore


@c -----------------------------
@menu
* Functions@value{PSUFFIX}::
* Control structures@value{PSUFFIX}::
* System variables@value{PSUFFIX}::
@end menu

@c ---------------------------------------
@node Functions@value{PSUFFIX}, Control structures@value{PSUFFIX}, Functions and system variables@value{PSUFFIX}, Functions and system variables@value{PSUFFIX}
@section Functions@value{PSUFFIX}
@cindex Functions@value{PSUFFIX}

This section gives a complete reference of all functions, commands and
special variables of the @sc{Plural} kernel (i.e., all built-in
commands).

The general syntax of a function is
@format
                   [target =] function_name (<arguments>);
@end format


@menu
* bracket::
* eliminate@value{PSUFFIX}::
* kbase@value{PSUFFIX}::
* memory@value{PSUFFIX}::
* minres@value{PSUFFIX}::
* mres@value{PSUFFIX}::
* nres@value{PSUFFIX}::
* option@value{PSUFFIX}::
* plural::
* reduce@value{PSUFFIX}::
* std@value{PSUFFIX}::
* syz@value{PSUFFIX}:: 
* twostd::
* vdim@value{PSUFFIX}::
@end menu



@c -----------------------------
@node bracket, eliminate@value{PSUFFIX}, Functions@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection bracket
@cindex bracket

@table @code
@item @strong{Syntax:}
@code{system (}"bracket", poly_expression p, poly_expression q @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
Computes the Lie bracket @code{[p,q]=pq-qp} of the first polynomial with
the second in a special way.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
// it is Quantum deformation of U(so_3).
poly p=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z;
// it is the central element  
p=p^3;
p;
poly q=(x+Q*y+Q^2*z)^4;
// it is big noncentral element
q;
system("bracket",p,q); 
@c example
@end smallexample 
@end table

@c ---------------------------------------
@node eliminate@value{PSUFFIX}, kbase@value{PSUFFIX}, bracket, Functions@value{PSUFFIX}
@subsection eliminate@value{PSUFFIX}
@cindex eliminate@value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
eliminates variables occurring as factors of the second argument from an
ideal, resp.@: module, by intersecting it with the subring not containing
these variables.
@*@code{eliminate} does not need a special ordering nor a Groebner basis as input.
@c @item @strong{Note:}
@c Since elimination is expensive, for homogeneous input it might be useful
@c first to compute the Hilbert function of the ideal (first
@c argument) with a fast ordering (e.g., @code{dp}). Then make use of it to speed
@c up the computation: a Hilbert-driven elimination uses the intvec
@c provided as the third argument.
@item @strong{Example:}
@smallexample
@c example error
ring r=0,(e,f,h,a),Dp;
matrix d[4][4];
d[1,2]=-h;
d[1,3]=2*e;
d[2,3]=-2*f;
system("PLURAL",1,d);
// it is U(sl_2)+K[a]
option(redSB);
option(redTail);
poly p=4*e*f+h^2-2*h-a;
// this is central element with parameter
ideal I=e^3,f^3, h^3-4*h,p;
ideal J=eliminate(I,efh);
// this will give us the central character of I
J;
// now we try to eliminate h, that is to intersect with subalgebra [e,f]
// which is not is not admissible subalgebra!
eliminate(I,h); 
eliminate(I,a);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal@value{PSUFFIX}};
@ref{module@value{PSUFFIX}};
@ref{std@value{PSUFFIX}}.
@c ref
@c ------------------------------------------------
@node kbase@value{PSUFFIX}, memory@value{PSUFFIX}, eliminate@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection kbase@value{PSUFFIX}
@cindex kbase@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{kbase (} ideal_expression @code{)}
@*@code{kbase (} module_expression @code{)}
@*@code{kbase (} ideal_expression@code{,} int_expression@code{)}
@*@code{kbase (} module_expression@code{,} int_expression@code{)}
@item @strong{Type:}
the same as the input type of the first argument
@item @strong{Purpose:}

computes the vector space basis of the 
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the initial terms of the given generators. 
@* If the factor-module is not of finite dimension, -1 is returned.
  
If the generators form a Groebner basis,
this is the same as the vector space basis of the 
factor-module. 

@item @strong{Note:}
you have the ring structure on the ring modulo the ideal if and only
if the ideal is two-sided. 

@item @strong{Example:}
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  matrix d[3][3];
  d[1,2]=-z;
  d[1,3]=2x;
  d[2,3]=-2y;
  system("PLURAL",1,d);
  ideal i=x2,y2,z2-1;
  i=std(i);
  i;
  kbase(i);
  vdim(i);
  ideal j=x,z-1;
  j=std(j);
  kbase(j,3);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal@value{PSUFFIX}};
@ref{module@value{PSUFFIX}};
@ref{vdim@value{PSUFFIX}}.
@c ref
@c ---------------------------------------
@node  memory@value{PSUFFIX}, minres@value{PSUFFIX}, kbase@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection memory@value{PSUFFIX}
@cindex memory@value{PSUFFIX}
@cindex memory managment
@table @code
@item @strong{Syntax:}
@code{memory (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns statistics concerning the memory management:
@itemize @bullet
@item @code{memory(0)} is the number of active (used) bytes,
@item @code{memory(1)} is the number of bytes allocated from the
operating system,
@item @code{memory(2)} is the maximal number of bytes ever allocated from the
operating system during the current @sc{Plural} session.
@end itemize
@item @strong{Note:}
To monitor the memory usage during ongoing computations the option
@code{mem} should be set (using the command @code{option(mem);} .
@ifset singularmanual
see also @ref{option}).
@end ifset
@item @strong{Example:}
@smallexample
@c example
ring r=0,(x(1..100)),dp;
system("PLURAL",-1,0);
poly p=(x(1)+x(100))^50;
proc ReportMemoryUsage()
{  "Memory currently used by SINGULAR     :",memory(0),"Byte (",
   memory(0)/101023, "KByte)" +newline+
   "Memory currently allocated from system:",memory(1), "Byte (",
   memory(1)/1023, "KByte)";
   "Maximal memory allocated from system  :",memory(2), "Byte (",
   memory(2)/1023, "KByte)";
}
ReportMemoryUsage();
kill p;
ReportMemoryUsage(); // less memory used: p killed
kill r; 
@c example
@end smallexample
@end table
@c ref
@ref{option@value{PSUFFIX}};
@c ref


@c ---------------------------------------
@node  minres@value{PSUFFIX}, mres@value{PSUFFIX}, memory@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection minres@value{PSUFFIX}
@cindex minres@value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{minres (} list_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{minres (} resolution_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
minimizes a free resolution of an ideal or module
given by the list_expression, resp.@: resolution_expression.
@item @strong{Example:}

@smallexample
@c example
ring A=0,(x,y,z),Dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d);
ideal i=x,y,z;
i=std(i);
resolution F=nres(i,0);
F;
int a;
for (a=1;a<=size(list(F));a++)
{
printf("Module: %s",a);
print(matrix(F[a]));
}
resolution MF=minres(F);
MF;
for (a=1;a<=size(list(MF));a++)
{
printf("Module: %s",a);
print(matrix(MF[a]));
}
@c example
@end smallexample
@end table

@c ref
See
@ref{mres@value{PSUFFIX}};
@ref{nres@value{PSUFFIX}}.
@c ref




@c ---------------------------------------
@node  mres@value{PSUFFIX}, nres@value{PSUFFIX}, minres@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection mres@value{PSUFFIX}
@cindex mres@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression @code{)}
@*@code{mres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the
Groebner basis method. More precisely, let A=@code{matrix}(M), then @code{mres}
computes a free resolution of
@ifinfo
coker(A)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@end ifinfo
@tex
$coker(A)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M
\longrightarrow 0,$$
@end tex
where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are a (possibly) minimal set of generators
of M. 
If the int expression k is not zero then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1...k.
@end tex
@ifinfo
Mi=module(Ai), i=1...k.
@end ifinfo
@*@code{mres(M,0)} returns a resolution consisting of at most n+2 modules,
where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then @code{L[1]} consists of a minimal set of generators of the input, @code{L[2]}
consists of a minimal set of generators for the first syzygy module of
@code{L[1]}, etc., until @code{L[p+1]}, such that
@ifinfo
L[i]<>0 for i<=p,
@end ifinfo
@tex
${\tt L[i]}\neq 0$ for $i \le p$,
@end tex
 but @code{L[p+1]}, the first syzygy module of @code{L[p]},
is 0 (if the basering is not a qring).
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c example
ring A=0,(x,y,z),Dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d);
ideal i=x,y,z;
i=std(i);
resolution M=mres(i,0);
M;
for (int a=1;a<=size(list(M));a++)
{ 
printf("Module: %s",a);
print(matrix(M[a]));
}

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal@value{PSUFFIX}};
@ref{minres@value{PSUFFIX}};
@ref{nres@value{PSUFFIX}};
@ref{module@value{PSUFFIX}};

@c ref



@c ---------------------------------------
@node  nres@value{PSUFFIX}, option@value{PSUFFIX}, mres@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection nres@value{PSUFFIX}
@cindex nres@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{nres (} ideal_expression@code{,} int_expression @code{)}
@*@code{nres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module M which is minimized
from  the second module on (by the Groebner basis method).

@c More precisely, let
@c @tex
@c $A_1$=matrix(M),
@c @end tex
@c @ifinfo
@c A1=matrix(M),
@c @end ifinfo
@c then @code{nres} computes a free resolution of
@c @ifinfo
@c coker(A1)=F0/M
@c @format
@c                     A2       A1
@c       ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@c @end format
@c @end ifinfo
@c @tex
@c $coker(A_1)=F_0/M$
@c $$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M\longrightarrow 0,$$
@c @end tex
@c @*where the columns of the matrix
@c @tex
@c $A_1$
@c @end tex
@c @ifinfo
@c A1
@c @end ifinfo
@c are the given set of generators of M.
@c If the int expression k is not zero then the computation stops after k steps
@c and returns a list of modules
@c @tex
@c $M_i={\tt module}(A_i)$, i=1..k.
@c @end tex
@c @ifinfo
@c Mi=module(Ai), i=1..k.
@c @end ifinfo
@c @*@code{nres(M,0)} returns a list of n modules where n is the number of
@c variables of the basering.
@c Let @code{list L=nres(M,0);} then @code{L[1]=M} is identical to the input,
@c @code{L[2]} is a minimal set of generators for the first syzygy
@c module of  @code{L[1]}, etc.
@c @ifinfo
@c (L[i]=M_i
@c @end ifinfo
@c @tex
@c (${\tt L[i]}=M_i$
@c @end tex
@c in the notations from above).
@c @item @strong{Example:}
@smallexample
@c example
ring A=0,(x,y,z),Dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d);
ideal i=x,y,z;
i=std(i);
resolution F=nres(i,0);
F;
for (int a=1;a<=size(list(F));a++)
{ 
printf("Module: %s",a);
print(matrix(F[a]));
}

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal@value{PSUFFIX}};
@ref{module@value{PSUFFIX}};
@ref{minres@value{PSUFFIX}};
@ref{mres@value{PSUFFIX}};
@c ref


@c ---------------------------------------
@node option@value{PSUFFIX}, plural, nres@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection option@value{PSUFFIX}
@cindex option@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{option ()}
@item @strong{Type:}
string
@item @strong{Purpose:}
lists all defined options.
@*
@item @strong{Syntax:}
@code{option (} option_name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
sets an option.
@item @strong{Note:}
To disable an option, use the prefix @code{no}.
@*
@item @strong{Syntax:}
@code{option ( get )}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
dumps the state of all options to an intvec.
@*
@item @strong{Syntax:}
@code{option ( set,} intvec_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
restores the state of all options from an intvec (produced by
@code{option(get)}).
@sp 1
@item @strong{Values:}
The following options are used to manipulate the behavior of
computations and act like boolean switches. Use the prefix @code{no} to
disable an option. Notice that some options are ring dependent and reset
to their default values on a change of the current basering.

@table @asis
@c ---------
@item @code{prot}
@cindex prot, option
@cindex protocoll of computations
@cindex progress watch
shows protocol information indicating the
progress during the following computations:
@code{mres},
@code{minres},
@code{res},
@code{std},
@code{syz}.
@c ---------
@item @code{redSB}
@cindex redSB, option
@cindex reduced Groebner basis
computes a reduced Groebner basis in any related computation.
@c ---------
@item @code{redTail}
@cindex redTail, option
reduction of the tails of polynomials during Groebner basis
computations. This option is ring dependent. By default, it is set for
rings with global degree orderings and not set for all other rings.
@c ---------

@end table
@*
The following options, which also control computations, are special,
since they are not manipulated by the @code{option} command but by a
direct assignment of a value. Reset the option by assigning the value 0;
the command @code{option(none)} will not reset them! If there is a
non-zero value assigned, the command @code{option()} prints the option.
@*
The last set of options controls the output of @sc{Plural}:
@table @asis

@item  @code{mem}
@cindex mem, option
@ifset  singularmanual 
shows memory usage in square brackets (see @ref{memory}).
@end ifset
@ifclear singularmanual
shows memory usage in square brackets (see @ref{memory@value{PSUFFIX}}).
@end ifclear  

@c @smallexample
@c @c example
@c   option(prot);
@c   option();
@c   ring r=0,x,dp;
@c   degBound=22;
@c   option();
@c   intvec i=option(get);
@c   option(none);
@c   option(set,i);
@c   option();
@c @c example
@c @end smallexample
@end table

@*The output reported on @code{option(prot)} has the following meaning:
@multitable @columnfractions .01 .14 .11 .65

@item @tab @tab @tab
@item @tab @code{mres}
@tab @code{[}@math{d}@code{]}
@tab computations of the @math{d}-th syzygy module
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{minres}
@tab @code{[}@math{d}@code{]}
@tab minimizing of the @math{d}-th syzygy module
@item @tab @tab @tab
@item @tab @code{reduce}
@tab @code{r} @tab reduced a leading term
@item @tab @tab @tab
@item @tab @code{std}
@tab @code{[}@math{m}@code{:}@math{n}@code{]}
@tab internal ring change to poly representation with exponent bound
@math{m} and @math{n} words in exponent vector
@item @tab @tab @tab
@item @tab @code{syz} @tab @tab all characters: like the output of @code{std}
@end multitable

@end table

@c ref
See
@ref{std@value{PSUFFIX}}.
@c ref








@c -----------------------------
@node plural, reduce@value{PSUFFIX}, option@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection plural
@cindex plural

@table @code
@item @strong{Syntax:}
@*@code{system(}"PLURAL", matrix_expression C, matrix_expression D @code{)} 
@*@code{system(}"PLURAL", number_expression n, matrix_expression D @code{)}
@*@code{system(}"PLURAL", matrix_expression C, poly_expression p @code{)}
@*@code{system(}"PLURAL", number_expression n, poly_expression p @code{)}
@item @strong{Type:} ring
@item @strong{Purpose:} 
Based on the given ring @code{r}, say, with "k" variables, strictly upper
triangular matrices with numbers @code{(C)} from the ground field of @code{r}
and polynomials from @code{(D)} from @code{r}.

@item @strong{Remark:}
At present, we do not perform checks of leading monomial condition
and non-degeneracy conditions (@pxref{G-algebras}), while setting an algebra. 



@item @strong{Example:}
@smallexample
@c example
ring r1=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
// it is quantum deformation U'_q(so_3)
// specialized at the 3rd root of q=Q^2 is specialized at the 3rd root of
// unity
r1;
kill r1;
ring r2=0,(Xa,Xb,Xc,Ya,Yb,Yc,Ha,Hb),dp;
matrix d[8][8];
d[1,2]=-Xc; d[1,4]=-Ha; d[1,6]=Yb;
d[1,7]=2*Xa; d[1,8]=-Xa; d[2,5]=-Hb;
d[2,6]=-Ya; d[2,7]=-Xb; d[2,8]=2*Xb;
d[3,4]=Xb; d[3,5]=-Xa; d[3,6]=-Ha-Hb;
d[3,7]=Xc; d[3,8]=Xc; d[4,5]=Yc;
d[4,7]=-2*Ya; d[4,8]=Ya; d[5,7]=Yb;
d[5,8]=-2*Yb; d[6,7]=-Yc; d[6,8]=-Yc;
system("PLURAL",1,d);
// it is U(sl_3)
r2;
kill r2;
ring r3=0,(a,b,c,d),lp;
matrix c[4][4];
c[1,2]=1; c[1,3]=3; c[1,4]=-2;
c[2,3]=-1; c[2,4]=-3; c[3,4]=1;
system("PLURAL",c,0);
// it is some quasi--commutative algebra
r3;
kill r3;
ring r4=0,(t,u,v,w),dp;
system("PLURAL",-1,0);
// it is anticommutative algebra
r4;
kill r4;

@c example
@end smallexample
@end table



@c ---------------------------------------
@node reduce@value{PSUFFIX}, std@value{PSUFFIX}, plural, Functions@value{PSUFFIX}
@subsection reduce@value{PSUFFIX}
@cindex reduce@value{PSUFFIX}
@cindex NF
@table @code
@item @strong{Syntax:}

@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, ideal  or module to its normal form with
respect to an ideal or module represented by a Groebner basis.
Returns 0 if and only if the polynomial (resp.@: vector, ideal, module)
is an element (resp.@: subideal, submodule) of the ideal (resp.@: module).
The result may have no meaning if the second argument is not a Groebner basis.
@*The third (optional) argument 1 of type int forces a reduction which considers only the leading term and does no tail reduction.
@item @strong{Note:}
The commands @code{reduce} and @code{NF} are synonymous.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,a),(e,f,h),Dp;
matrix d[3][3];
d[1,2]=-h;
d[1,3]=2e;
d[2,3]=-2f;
system("PLURAL",1,d);
// it is parametric U(sl_2)
ideal I=e2,f2,h2-1;
I=std(I);
ideal J=e,h-a;
J=std(J);
poly z=4*e*f+h^2-2*h;
// z is the central element
// the central character of I:
NF(z,I);
// the central character of J:
NF(z,J);
@c example
@end smallexample
@end table

@c ref
See
@ref{ideal@value{PSUFFIX}};
@ref{module@value{PSUFFIX}};
@ref{std@value{PSUFFIX}}.
@c ref

@ifset singularmanual
@c ref
@ref{vector}.
@c ref
@end ifset 

@ifclear singularmanual
see also @code{vector} in @sc{Singular} manual.
@end ifclear   

@c ---------------------------------------
@node std@value{PSUFFIX}, syz@value{PSUFFIX}, reduce@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection std@value{PSUFFIX}
@cindex std@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} poly_expression @code{)}
@*@code{std (} module_expression@code{,} vector_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a Groebner basis of an ideal or module with respect to the
monomial ordering of the basering.
A Groebner basis is a set of generators such that
the leading terms generate the leading ideal, resp.@: module.

Use an optional second argument of type poly, resp.@: vector,
to construct the Groebner basis from an already computed one (given as the
first argument) and one additional generator (the second argument).
@item @strong{Note:}
To view the progress of long running computations, use
@code{option(prot)} 
@ifset singularmanual 
(@pxref{option}(prot)).
@end ifset

@item @strong{Example:}
@smallexample
@c example
ring R=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d); //U(sl_2)
ideal I=x3,y3,z3-z;
I=std(I);
I;
kill R;
ring Rq3=(0,Q),(x,y,z),dp; //U'_q(so_3)
minpoly=Q^4+Q^2+1; // at the 3rd root of unity
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
ideal J=x3,y3,z3-z;
J=std(J);
J;

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal@value{PSUFFIX}};
@ref{ring@value{PSUFFIX}};
@ref{option@value{PSUFFIX}};
@c ref


@c -------------------------------------------------
@node syz@value{PSUFFIX}, twostd, std@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection syz@value{PSUFFIX}
@cindex syz@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e., the module of relations of the given
generators) of the ideal, resp.@: module.
@item @strong{Example:}
@smallexample
@c example
ring Rq=(0,Q),(x,y,z),dp; //U_q(so_3)
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
poly Cq=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z;
poly C1=x^3+x;
poly C2=y^3+y;
poly C3=z^3+z;
ideal I=Cq,C1,C2,C3;
I=std(I);
module a=syz(I);
print(a);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal@value{PSUFFIX}};
@ref{module@value{PSUFFIX}};
@ref{mres@value{PSUFFIX}};
@ref{nres@value{PSUFFIX}};
@ref{minres@value{PSUFFIX}};
@c ref




@c ------------------------------
@node twostd, vdim@value{PSUFFIX}, syz@value{PSUFFIX}, Functions@value{PSUFFIX}
@subsection twostd
@cindex twostd

@table @code
@item @strong{Syntax:}
  @code{system (}"twostd", ideal_expression@code{)}; 
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis of the two-sided ideal,
generated by the input, treated as a set of two-sided generators.
@ifset singularmanual
see @ref{std}
@end ifset

@item @strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d); 
// it is algebra U(sl_2)
int N=3;
poly f=1;
for(int n=0;n<=N;n++)
{ 
  f=f*(z+N-2*n);
}
f;
ideal i=x^(N+1),y^(N+1),f;
option(redSB);
option(redTail);
ideal I=std(i);
I;
ideal J=system("twostd",i);
J;

@c example
@end smallexample
@item @strong{Remark:}
There are algebras with no two-sided ideals (like Weyl algebras).
@end table


@c -------------------------------------------------------------------------
@node vdim@value{PSUFFIX},  , twostd, Functions@value{PSUFFIX}
@subsection vdim@value{PSUFFIX}
@cindex vdim@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{vdim (} ideal_expression @code{)}
@*@code{vdim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the vector space dimension of the 
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the leading terms of the given generators. 
@* If the factor-module is not of finite dimension, -1 is returned.
  
If the generators form a Groebner basis,
this is the same as the vector space dimension of the 
factor-module. 

@item @strong{Note:}
you have the ring structure on the ring modulo the ideal if and only
if the ideal is two-sided. 

@item @strong{Example:}
@smallexample
@c example
ring R=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d); //U(sl_2)
ideal I=x3,y3,z3-z;
I=std(I);
I;
vdim(I);

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal@value{PSUFFIX} };
@ref{std@value{PSUFFIX} };
@ref{kbase@value{PSUFFIX}}.
@c ref

@ifset singularmanual
@c ref
@ref{dim};
@ref{degree};
@ref{mult};
@c ref
@end ifset

@ifclear singularmanual
see also @sc{Singular} manual sections dim, degree, mult, kbase.
@end ifclear



@c ---------------------------------------
@node Control structures@value{PSUFFIX}, System variables@value{PSUFFIX}, Functions@value{PSUFFIX}, Functions and system variables@value{PSUFFIX}
@section Control structures@value{PSUFFIX}
@cindex Control structures@value{PSUFFIX}
@cindex block

See SINGULAR Manual
@ifset singularmanual
@c ref
(@ref{Control structures})
@c ref
@end ifset

@c ---------------------------------------
@node System variables@value{PSUFFIX},  , Control structures@value{PSUFFIX}, Functions and system variables@value{PSUFFIX}
@section System variables@value{PSUFFIX}
@cindex System variables@value{PSUFFIX}

See SINGULAR Manual


@ifset singularmanual
(@pxref{System variables})
@end ifset


