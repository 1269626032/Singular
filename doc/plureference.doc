  @comment -*-texinfo-*-
@comment $Id: plureference.doc,v 1.29 2005-04-29 08:56:20 Singular Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plureference.info
@settitele PLURAL
@node Top, Functions @value{PSUFFIX}, (dir), (dir)
@menu
* Functions @value{PSUFFIX}::   
@end menu

@node Functions @value{PSUFFIX},  , Top, Top
@chapter  Functions @value{PSUFFIX}
%**end
@end ignore



@cindex Functions @value{PSUFFIX}
This chapter gives a complete reference of all functions, commands and
special variables of the @sc{Plural} kernel (i.e., all built-in
commands).

The general syntax of a function is
@format
                   [target =] function_name (<arguments>);
@end format


@menu
* betti @value{PSUFFIX}::       
* bracket::                     
* eliminate @value{PSUFFIX}::   
* envelope::                    
* fetch @value{PSUFFIX}::       
* imap @value{PSUFFIX}::        
* intersect @value{PSUFFIX}::   
* kbase @value{PSUFFIX}::       
* lift @value{PSUFFIX}::        
* liftstd @value{PSUFFIX}::     
* minres @value{PSUFFIX}::      
* modulo @value{PSUFFIX}::      
* mres @value{PSUFFIX}::        
* ncalgebra::                   
* nres @value{PSUFFIX}::        
* oppose::                      
* opposite::                    
* preimage @value{PSUFFIX}::    
* quotient @value{PSUFFIX}::    
* reduce @value{PSUFFIX}::      
* std @value{PSUFFIX}::         
* subst  @value{PSUFFIX}::      
* syz @value{PSUFFIX}::         
* twostd::                      
* vdim @value{PSUFFIX}::
* Comparison between Singular and Plural functions::
@end menu



@c -----------------------------
@node betti @value{PSUFFIX}, bracket, Functions @value{PSUFFIX}, Functions @value{PSUFFIX}
@section betti @value{PSUFFIX}
@cindex betti @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{betti (} list_expression @code{)}
@*@code{betti (} resolution_expression @code{)}
@*@code{betti (} list_expression @code{,} int_expression @code{)}
@*@code{betti (} resolution_expression @code{,} int_expression @code{)}
@item @strong{Type:}
intmat
@item @strong{Note:}
in the noncommutative case, computing Betti numbers makes sense only if the basering @math{R} has homogeneous relations
@item @strong{Purpose:}
with 1 argument: computes the graded Betti numbers of a minimal resolution of
@tex
$R^n/M$, if $R$ denotes the basering and
$M$ a homogeneous submodule of $R^n$ and the argument represents a
resolution of
$R^n/M$.
@end tex
@iftex
@*
@end iftex
@tex
The entry d of the intmat at place (i, j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of $R^n/M$ (the 0th (resp.\ 1st) syzygy module of $R^n/M$ is
$R^n$ (resp.\ $M$)).
@end tex
@ifinfo
R^n/M, if R denotes the basering and
M a homogeneous submodule of R^n and the argument represents a resolution of
R^n/M:
@*The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module 
@c (= module of relations) 
of R^n/M (the 0th (resp.@: 1st) syzygy module of R^n/M is R^n
(resp.@: M)).
@end ifinfo
The argument is considered to be the result of a @code{mres} or @code{nres}
command. This implies that a zero is only allowed (and counted) as a
generator in the first module.
@*For the computation @code{betti} uses only the initial monomials. This could lead to confusing results for a non-homogeneous input.

If the optional second argument is non-zero, the Betti numbers will be minimized.
@c The optional second argument is a switch for the minimization of the Betti
@c numbers. If it is 0 then the Betti numbers correspond exactly to the input -
@c otherwise the command is identical to the one-argument form.
@item @strong{Example:}
@smallexample
@c example
int i;int N=2;
ring r=0,(x(1..N),d(1..N),q(1..N)),Dp;
matrix D[3*N][3*N];
for (i=1;i<=N;i++)
{ D[i,N+i]=q(i)^2; }
ncalgebra(1,D); // this algebra is a kind of homogenized Weyl algebra
r;
ideal I = x(1),x(2),d(1),d(2),q(1),q(2);
option(redSB);
option(redTail);
resolution R = mres(I,0); // the full length minimal resolution
print(betti(R),"betti");
@c example
@end smallexample
@end table


@c -----------------------------
@node bracket, eliminate @value{PSUFFIX}, betti @value{PSUFFIX}, Functions @value{PSUFFIX}
@section bracket
@cindex bracket

@table @code
@item @strong{Syntax:}
@code{bracket (} poly_expression, poly_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
Computes the Lie bracket @code{[p,q]=pq-qp} of the first polynomial with
the second. Uses special routines, based on the Leibniz rule.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,Q),(x,y,z),Dp;
minpoly=Q^2-Q+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;    C[1,3]=1/Q2;  C[2,3]=Q2;
D[1,2]=-Q*z;  D[1,3]=1/Q*y; D[2,3]=-Q*x; 
ncalgebra(C,D);  // this is a quantum deformation of U(so_3) with q a 6th root of unity
poly p=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z; // this is the central element  
p=p^3; // it is still central
poly q=(x+Q*y+Q^2*z)^4;  // take some big noncentral element
size(q); // check how many monomials are in q
bracket(p,q); // check p*q=q*p
@c example
@end smallexample 
@end table

@c ---------------------------------------
@node eliminate @value{PSUFFIX}, envelope, bracket, Functions @value{PSUFFIX}
@section eliminate @value{PSUFFIX}
@cindex eliminate @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
eliminates variables occurring as factors of the second argument from an
ideal, resp.@: module, by intersecting it with the subring not containing
these variables.
@item @strong{Note:}  
@code{eliminate} does not need neither a special ordering on the basering nor a Groebner basis as input.
@item @strong{Remark:}
 in noncommutative case, not every subset of a set of variables generates
a proper subalgebra. Even if it is so, there may be cases, when still
no elimination is possible. In these situations special error messages
will be returned.

@item @strong{Example:}
@smallexample
@c example error
ring r=0,(e,f,h,a),Dp;
matrix d[4][4];
d[1,2]=-h; d[1,3]=2*e; d[2,3]=-2*f;
ncalgebra(1,d);  // this algebra is U(sl_2), tensored with K[a] over K
option(redSB);
option(redTail);
poly  p = 4*e*f+h^2-2*h-a;  // this is central element with parameter
ideal I = e^3,f^3, h^3-4*h,p;
ideal J = eliminate(I,e*f*h);  // this will give us the central character of I
J;
// now we try to eliminate h, that is to intersect I with subalgebra S,
// generated by e and f. But S is not closed in itself:
eliminate(I,h); 
// since a commutes with e,f,h, we can eliminate it:
eliminate(I,a);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node  envelope, fetch @value{PSUFFIX}, eliminate @value{PSUFFIX}, Functions @value{PSUFFIX}
@section envelope
@cindex envelope

@table @code
@item @strong{Syntax:}
@code{envelope (} ring_name @code{)}
@item @strong{Type:}
ring
@item @strong{Purpose:}
creates an enveloping algebra of a given algebra, that is 
@ifinfo
A_env = A tensor A_opp, where A_opp is the
opposite algebra of A.
@end ifinfo
@tex
$A^{env} = A \otimes_K A^{opp}$, where $A^{opp}$ is the
opposite algebra of $A$.
@end tex
@item @strong{Remark:}
You have to activate the ring with the @code{setring} command.
For the presentation, see explanation of @code{opposite}.
@smallexample
@c example 
LIB "ncalg.lib";
def A = sl2();
setring A; A;
def Aenv = envelope(A);
setring Aenv; 
Aenv;
@c example
@end smallexample
@end table
@c ref
See
@ref{oppose};
@ref{opposite}.
@c ref

@c ---------------------------------------
@node fetch @value{PSUFFIX}, imap @value{PSUFFIX}, envelope, Functions @value{PSUFFIX}
@section fetch @value{PSUFFIX}
@cindex fetch @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{fetch (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
maps objects between rings.
@code{fetch} is the identity map between rings and qrings,
the i-th variable of the source ring is mapped to the i-th
variable of the basering.  The coefficient fields must be compatible.
(See @ref{map} for a description of possible mapping between
different ground fields).
@*@code{fetch} offers a convenient way to change
variable names or orderings, or to map objects from a ring to a quotient
ring of that ring or vice versa.
@item @strong{Note:}
Compared with @code{imap}, @code{fetch} uses the position of the ring
variables, not their names.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def Usl2 = sl2(); // this algebra is U(sl_2)
setring Usl2;
option(redSB); 
option(redTail);
poly  C  = 4*e*f+h^2-2*h; // the central element of U(sl2)
ideal I  = e^3,f^3,h^3-4*h;
ideal J  = twostd(I);
print(matrix(J));  // print a compact presentation of J
ideal QC = twostd(C-8);
qring Q  = QC;
ideal QJ = fetch(Usl2,J);
QJ = std(QJ);
print(matrix(QJ)); // print a compact presentation of QJ
@c example
@end smallexample
@end table
@c ref
See
@ref{imap @value{PSUFFIX}};
@ref{map @value{PSUFFIX}};
@ref{qring @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node imap @value{PSUFFIX}, intersect @value{PSUFFIX}, fetch @value{PSUFFIX}, Functions @value{PSUFFIX}
@section imap @value{PSUFFIX}
@cindex imap @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{imap (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
identity map on common subrings.  @code{imap} is the map between rings
and qrings with compatible ground fields which is the identity on
variables and parameters of the same name and 0 otherwise.
(See @ref{map} for a description of possible mapping between
different ground fields).
Useful for mapping from a homogenized ring to the original ring or
for mappings from/to rings with/without parameters. Compared with
@code{fetch}, @code{imap} uses the names of variables and parameters.
Unlike @code{map} and @code{fetch}, @code{imap} can map parameters to variables.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
ring ABP=0,(p4,p5,a,b),dp; //  a commutative ring
def Usl3 = sl(3);
def BIG  = Usl3+ABP;
setring BIG;
poly P4 = 3*x(1)*y(1)+3*x(2)*y(2)+3*x(3)*y(3)+h(1)^2+h(1)*h(2)+h(2)^2-3*h(1)-3*h(2);  // central element of U(sl_3) of degree 2
poly P5 = 4*x(1)*y(1) + h(1)^2 - 2*h(1); // central element of the subalgebra of U(sl_3), isomorphic to U(sl_2)
ideal J = x(1),x(2),h(1)-a,h(2)-b; // we are interested in the module U(sl_3)/J, depending on parameters a,b
ideal I = p4-P4, p5-P5;
ideal K = I, J;
ideal E = eliminate(K,x(1)*x(2)*x(3)*y(1)*y(2)*y(3)*h(1)*h(2));
E; // this is the ideal of central characters in ABP
ring abP = (0,a,b),(p4,p5),dp; // what are the characters on nonzero a,b?
ideal abE = imap(BIG, E);
option(redSB);
option(redTail);
abE = std(abE);
abE; // here they are - we have only one character  
@c example
@end smallexample
@end table
@c ref
See
@ref{fetch @value{PSUFFIX}};
@ref{map @value{PSUFFIX}};
@ref{qring @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref



@c ------------------------------------------------
@node intersect @value{PSUFFIX}, kbase @value{PSUFFIX}, imap @value{PSUFFIX}, Functions @value{PSUFFIX}
@section  intersect @value{PSUFFIX}
@cindex  intersect @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{intersect (}expression_list of ideal_expression  @code{)}
@*@code{intersect (}expression_list of module_expression  @code{)}

@item @strong{Type:}
ideal, resp. module 

@item @strong{Purpose:}
computes the intersection of ideals, resp. modules. 
@item @strong{Example:}
@c // 1. from [BGV], p.213, Ex.2.5. answer: [0,xy^2],[y^2,-xy]
@c // 2. from [BGV], p.148, Ex.3.8
@smallexample
@c example
ring r=0,(x,y),dp;
ncalgebra(-1,0);
module M=[x,x],[y,0];
module N=[0,y^2],[y,x];
option(redSB);
module Res;
Res=intersect(M,N);
print(Res);
kill r;
//--------------------------------
LIB "ncalg.lib";
ring r=0,(x,d),dp;
Weyl(); // make r into Weyl algebra
ideal I = x+d^2;
ideal J = d-1;
ideal H = intersect(I,J);
H;
@c example
@end smallexample
@end table



@c ------------------------------------------------
@node kbase @value{PSUFFIX}, lift @value{PSUFFIX}, intersect @value{PSUFFIX}, Functions @value{PSUFFIX}
@section kbase @value{PSUFFIX}
@cindex kbase @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{kbase (} ideal_expression @code{)}
@*@code{kbase (} module_expression @code{)}
@*@code{kbase (} ideal_expression@code{,} int_expression@code{)}
@*@code{kbase (} module_expression@code{,} int_expression@code{)}
@item @strong{Type:}
the same as the input type of the first argument
@item @strong{Purpose:}

computes the vector space basis of the 
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the initial terms of the given generators. 
@* If the factor-module is not of finite dimension, -1 is returned.
  
If the generators form a Groebner basis,
this is the same as the vector space basis of the 
factor-module. 

@item @strong{Note:}
in the noncommutative case, a ring modulo an ideal has a ring stucture 
if and only if an ideal is two-sided. 
@item @strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;  d[1,3]=2x;  d[2,3]=-2y;
ncalgebra(1,d); // this algebra is U(sl_2)
ideal i=x2,y2,z2-1;
i=std(i);
print(matrix(i));  // print a compact presentation of i
kbase(i);
vdim(i);
ideal j=x,z-1;
j=std(j);
kbase(j,3);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{vdim @value{PSUFFIX}}.
@c ref


@c -------------------------------------------------
@node lift @value{PSUFFIX}, liftstd @value{PSUFFIX}, kbase @value{PSUFFIX}, Functions @value{PSUFFIX}
@section lift @value{PSUFFIX}
@cindex lift @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{lift (} ideal_expression@code{,} subideal_expression @code{)}
@*@code{lift (} module_expression@code{,} submodule_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the left transformation matrix which expresses the generators of a
submodule in terms of the generators of a module.  Uses different
algorithms for modules which are (resp.@: are not) represented by a
Groebner basis.
@* More precisely, if  @code{m} is the
module, @code{sm} the submodule,
and @code{T} the transformation matrix returned by
lift, then @code{transpose(matrix(sm)) = transpose(T)*transpose(m)}
and @code{module(transpose(sm)) = module(transpose(T)*transpose(m))}.
If  @code{m} and @code{sm} are ideals, @code{ideal(sm) = ideal(transpose(T)*transpose(m))}.

@item @strong{Note:}
Gives a warning if @code{sm} is not a submodule.
@item @strong{Example:}
@smallexample
@c example
ring r = (0,a),(e,f,h),(c,dp);
matrix D[3][3];
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
ncalgebra(1,D); // this algebra is a parametric U(sl_2)
ideal i = e,h-a;
i = std(i);
print(matrix(i)); // print a compact presentation of i
poly Z = 4*e*f+h^2-2*h; // central element
Z = Z - NF(Z,i); //central character
ideal j = std(Z);
j;
matrix T = lift(i,j);
print(T);
ideal tj = ideal(transpose(T)*transpose(matrix(i)));
std(ideal(j-tj)); // test
@c example
@end smallexample
@end table
@c ref
See
@ref{liftstd @value{PSUFFIX}};
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}}.
@c ref


@c -----------------------------------------
@node liftstd @value{PSUFFIX}, minres @value{PSUFFIX}, lift @value{PSUFFIX}, Functions @value{PSUFFIX}
@section liftstd @value{PSUFFIX}
@cindex liftstd @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{liftstd (} ideal_expression@code{,} matrix_name @code{)}
@*@code{liftstd (} module_expression@code{,} matrix_name @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a Groebner basis of an ideal or module and the transformation
matrix from the given ideal, resp.@: module, to the Groebner basis.
@*That is, if @code{m} is the ideal or module, @code{sm} is the Groebner
basis of  @code{m}, returned by @code{liftstd}, and @code{T} is the transformation matrix,
then @code{transpose(matrix(sm))=transpose(T)*transpose(matrix(m))} and 
@code{sm=module(transpose(transpose(T)*transpose(matrix(m))))}.

If @code{m} is an ideal, @code{sm=ideal(transpose(T)*transpose(matrix(m)))}.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = sl2();
setring A;  // this algebra is U(sl_2)
ideal i = e2,f;
option(redSB);
option(redTail);
matrix T;
ideal j = liftstd(i,T);
print(matrix(j)); // the Groebner basis, printed in a compact form
print(T);  // the tansformation matrix
ideal tj = ideal(transpose(T)*transpose(matrix(i)));
std(ideal(j-tj)); // test
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node  minres @value{PSUFFIX}, modulo @value{PSUFFIX}, liftstd @value{PSUFFIX}, Functions @value{PSUFFIX}
@section minres @value{PSUFFIX}
@cindex minres @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{minres (} list_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{minres (} resolution_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
minimizes a free resolution of an ideal or module
given by the list_expression, resp.@: resolution_expression.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = sl2();
setring A; // this algebra is U(sl_2)
ideal i=e,f,h;
i=std(i);
resolution F=nres(i,0);   F;
print(matrix(F[1])); // print compact presentations of F's
print(matrix(F[2]));
print(matrix(F[3]));
resolution MF=minres(F);  MF;
print(matrix(MF[1]));
print(matrix(MF[2]));
print(matrix(MF[3]));
@c example
@end smallexample
@end table

@c ref
See
@ref{mres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node modulo @value{PSUFFIX}, mres @value{PSUFFIX}, minres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section modulo @value{PSUFFIX}
@cindex modulo @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{modulo (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{modulo (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
@code{modulo(h1,h2)}
@ifinfo
represents h1/(h1 intersect h2) (isomorphic to (h1+h2)/h2)
@end ifinfo
@tex
represents $h_1/(h_1 \cap h_2) \cong (h_1+h_2)/h_2$
@end tex
, where
@tex
$h_1$ and $h_2$
@end tex
@ifinfo
h1 and h2
@end ifinfo
are considered as submodules of the same free module
@tex
$R^s$
@end tex
@ifinfo
R^s
@end ifinfo
(s=1 for ideals). 
@*Let
@tex
$H_1$ (resp.\ $H_2$)
@end tex
@ifinfo
H1 (resp. H2)
 be the matrix of size l x k (resp.@: l x m), having the generators of
 h1 (resp.@: h2)
@end ifinfo
@tex
 be the matrix of size $l \times k$ (resp.\ $l \times m$), having the
generators of $h_1$ (resp.\ $h_2$)
@end tex
as columns.
@* Then
@tex
$h_1/(h_1 \cap h_2) \cong R^k / ker(\overline{H_1})$
@end tex
@ifinfo
@format
                                                    __
      h1/(h1 intersect h2) is isomorphic to R^k/ker(H1)

@*
@end format
@end ifinfo
, where
@tex
$\overline{H_1}: R^k \rightarrow R^s/Im(H_2)=R^s/h_2$
is the induced map.
@end tex
@ifinfo
@format
         __
         H1: R^k ----> R^l/Im(H2)=R^l/h2 is the induced map.

@*
@end format
@end ifinfo
@*@code{modulo(h1,h2)} returns generators of
the kernel of this induced map.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = sl2();
setring A; // this algebra is U(sl_2)
option(redSB);
option(redTail);
ideal I = e2,f2,h2-1;
I = twostd(I);
print(matrix(I)); // print a compact presentation of I
ideal E = std(e);
ideal T = modulo(E,I);
T = NF(std(I+T),I);
T = std(T);
T;
@c example
@end smallexample
@end table
@c ref
See also
@ref{syz @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node  mres @value{PSUFFIX}, ncalgebra, modulo @value{PSUFFIX}, Functions @value{PSUFFIX}
@section mres @value{PSUFFIX}
@cindex mres @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression @code{)}
@*@code{mres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the
Groebner basis method. More precisely, let A=@code{matrix}(M), then @code{mres}
computes a free resolution of
@ifinfo
coker(A)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@end ifinfo
@tex
$coker(A)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M
\longrightarrow 0,$$
@end tex
where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are a (possibly) minimal set of generators
of @math{M}. 
If the int expression k is not zero, then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, $i= 1 \ldots k$.
@end tex
@ifinfo
Mi=module(Ai), i=1...k.
@end ifinfo
@*@code{mres(M,0)} returns a resolution consisting of at most n+2 modules,
where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then @code{L[1]} consists of a minimal set of generators of the input, @code{L[2]}
consists of a minimal set of generators for the first syzygy module of
@code{L[1]}, etc., until @code{L[p+1]}, such that
@ifinfo
L[i]<>0 for i<=p,
@end ifinfo
@tex
${\tt L[i]}\neq 0$ for $i \le p$,
@end tex
 but @code{L[p+1]} (the first syzygy module of @code{L[p]})
is 0 (if the basering is not a qring).
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = sl2();
setring A; // this algebra is U(sl_2)
option(redSB);
option(redTail);
ideal i = e,f,h;
i = std(i);
resolution M=mres(i,0);
M;
print(matrix(M[1])); // print compact presentations of M's
print(matrix(M[2]));
std(ideal(transpose(M[2])*transpose(M[1]))); // see the exactness at this point
print(matrix(M[3]));
std(ideal(transpose(M[3])*transpose(M[2]))); // see the exactness at this point
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@c ref


@c -----------------------------
@node ncalgebra, nres @value{PSUFFIX}, mres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section ncalgebra
@cindex ncalgebra

@table @code
@item @strong{Syntax:}
@*@code{ncalgebra(} matrix_expression C, matrix_expression D @code{)} 
@*@code{ncalgebra(} number_expression n, matrix_expression D @code{)}
@*@code{ncalgebra(} matrix_expression C, poly_expression p @code{)}
@*@code{ncalgebra(} number_expression n, poly_expression p @code{)}
@item @strong{Type:} ring
@item @strong{Purpose:} 
Executed in the basering @code{r}, say, in k variables
@tex 
$ x_1, \ldots, x_k ,\;$
@end tex
@ifinfo
 x_1,... ,x_k, 
@end ifinfo
creates the
noncommutative extension on @code{r} subject to relations
@tex 
$ \{ x_j x_i=c_{ij} \cdot x_i x_j + d_{ij}, 1 \leq i <j \leq k \}, $
where $ c_{ij}$ and $d_{ij}$ should be organized into two strictly upper
@end tex
@ifinfo
@{x_j x_i=c_@{ij@} ..., x_i x_j + d_@{ij@} , 0< i <j < k+1 @}.
where c_@{ij@}  and d_@{ij@  should be organized into two strictly upper
@end ifinfo
 triangular matrices @code{C} with entries
@tex 
$c_{ij}$ 
@end tex
@ifinfo
c_@{ij@} 
@end ifinfo
 from the ground field of @code{r} 
and @code{D}  with  polynomial entries
@tex 
$ d_{ij}$ 
@end tex
@ifinfo
d_@{ij@} 
@end ifinfo
 from @code{r}. 
@* If
@tex 
$\forall i<j$, $c_{ij} = n$ 
@end tex
@ifinfo
for all i<j, c_@{ij@} = n
@end ifinfo
 , one can input a number @code{n} instead of matrix @code{C}.
@* If
@tex 
$\forall i<j$, $d_{ij} = p$ 
@end tex
@ifinfo
for all i<j, d_@{ij@} = p
@end ifinfo
 , one can input a poly @code{p} instead of matrix @code{D}.

@item @strong{Remark:}
At present, we do not perform checks of non-degeneracy conditions (@pxref{G-algebras}) while setting an algebra. 

@item @strong{Example:}
@smallexample
@c example
LIB "nctools.lib";
// ------- first example: C, D are matrices -------------------
ring r1 = (0,Q),(x,y,z),Dp;
minpoly = RootOfUnity(6);
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;   C[1,3]=1/Q2;  C[2,3]=Q2;
D[1,2]=-Q*z; D[1,3]=1/Q*y; D[2,3]=-Q*x; 
ncalgebra(C,D); // this algebra is a quantum deformation U'_q(so_3), with Q^2 being the 3rd root of unity
r1;
kill r1;
// -------- second example : number n=1, D is a matrix --
ring r2=0,(Xa,Xb,Xc,Ya,Yb,Yc,Ha,Hb),dp;
matrix d[8][8];
d[1,2]=-Xc; d[1,4]=-Ha;  d[1,6]=Yb;     d[1,7]=2*Xa; d[1,8]=-Xa; 
d[2,5]=-Hb; d[2,6]=-Ya;  d[2,7]=-Xb;    d[2,8]=2*Xb;
d[3,4]=Xb; d[3,5]=-Xa;   d[3,6]=-Ha-Hb; d[3,7]=Xc;   d[3,8]=Xc; 
d[4,5]=Yc; d[4,7]=-2*Ya; d[4,8]=Ya;     d[5,7]=Yb;
d[5,8]=-2*Yb; d[6,7]=-Yc; d[6,8]=-Yc;
ncalgebra(1,d);  // this algebra is U(sl_3)
r2;
kill r2;
// -------- third example : C is a matrix, p = 0 is a poly ---
ring r3=0,(a,b,c,d),lp;
matrix c[4][4];
c[1,2]=1; c[1,3]=3; c[1,4]=-2;
c[2,3]=-1; c[2,4]=-3; c[3,4]=1;
ncalgebra(c,0); // it is a quasi--commutative algebra
r3;
kill r3;
// -------- third example : number n = -1, poly p = 3w --
ring r4=0,(u,v,w),dp;
ncalgebra(-1,3w);
r4;
kill r4;
@c example
@end smallexample
@end table
@c ref
See also 
@ref{ncalg_lib};
@ref{nctools_lib};
@ref{qmatrix_lib};
@c ref


@c ---------------------------------------
@node  nres @value{PSUFFIX}, oppose, ncalgebra, Functions @value{PSUFFIX}
@section nres @value{PSUFFIX}
@cindex nres @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{nres (} ideal_expression@code{,} int_expression @code{)}
@*@code{nres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module which is minimized
from the second module on (by the Groebner basis method).
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def A = sl2();
setring A; // this algebra is U(sl_2)
option(redSB);
option(redTail);
ideal i = e,f,h;
i = std(i);
resolution F=nres(i,0);
F;
print(matrix(F[1]));  // print the resolution componentwise
print(matrix(F[2]));
std(ideal(transpose(F[2])*transpose(F[1]))); // see the exactness at this point
print(matrix(F[3]));
std(ideal(transpose(F[3])*transpose(F[2]))); // see the exactness at this point
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@ref{mres @value{PSUFFIX}};
@c ref

@c ---------------------------------------
@node  oppose, opposite, nres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section oppose
@cindex oppose

@table @code
@item @strong{Syntax:}
@code{oppose (} ring_name, name @code{)}
@item @strong{Type:}
poly, vector, ideal, module or matrix (the same type as the second argument)
@item @strong{Purpose:}
for a given object in the given ring, creates its opposite object
in the opposite ring (the last one is assumed to be the current ring).
@item @strong{Remark:}
for any object
@tex
 $O, \; (O^{opp})^{opp} = O$.
@end tex
@ifinfo
 O,  (O^opp)^opp = O. 
@end ifinfo
@smallexample
@c example 
LIB "ncalg.lib";
def r = sl2();
setring r;
matrix m[3][4];
poly   p  = (h^2-1)*f*e;
vector v  = [1,e*h,0,p];
ideal  i  = h*e, f^2*e,h*f*e;
m         = e,f,h,1,0,h^2, p,0,0,1,e^2,e*f*h+1;
module mm = module(m); 
def b     = opposite(r);
setring b; b;   // we will oppose this collection of objects
poly P    = oppose(r,p); 
vector V  = oppose(r,v);
ideal  I  = oppose(r,i);
matrix M  = oppose(r,m);
module MM = oppose(r,mm);
setring r;   // now let's check the correctness:
print(matrix(oppose(b,P)-p)); // print compact presentations of objects
print(matrix(oppose(b,V)-v));
print(matrix(oppose(b,I)-i));
print(matrix(oppose(b,M)-m));
print(matrix(oppose(b,MM)-mm));
@c example
@end smallexample
@end table
@c ref
See
@ref{envelope};
@ref{opposite}.
@c ref

@c ---------------------------------------
@node opposite, preimage @value{PSUFFIX}, oppose, Functions @value{PSUFFIX}
@section opposite
@cindex opposite

@table @code
@item @strong{Syntax:}
@code{opposite (} ring_name @code{)}
@item @strong{Type:}
ring
@item @strong{Purpose:}
creates an opposite algebra of a given algebra.
@item @strong{Note:}
You have to activate the ring with the @code{setring} command.
@* An opposite algebra of a given algebra is
an algebra with the same vectorspace but with the opposite
multiplication, i.e.
@*
@tex
$\forall \; f,g \in A^{opp}$, a new multiplication $*$ on $A^{opp}$ 
is defined to be $f*g := g \cdot f$.
@end tex

@ifinfo
for any f,g in A_opp, a multiplication @code{*} on A_opp is defined to
be f @code{*} g := gf.
@end ifinfo

@item @strong{Remark:}
Starting from the variables x_1,...,x_N and the ordering @code{<}
of the given algebra,
an opposite algebra will have variables X_N,...,X_1 
(where the case and the position are reverted). Moreover, it is
equipped with an opposed ordering @code{<_opp} (it is given
by the matrix, obtained from the matrix ordering of @code{<}
with the reverse order of columns).
@smallexample
@c example 
LIB "ncalg.lib";
def B = Qso3(3);  //this algebra is a quantum deformation of U(so_3), where the quantum parameter is a 3rd root of unity
setring B; B;
def Bopp = opposite(B);
setring Bopp; 
Bopp;
@c example
@end smallexample
@end table
@c ref
See
@ref{envelope};
@ref{oppose}.
@c ref

@c ---------------------------------------
@node preimage @value{PSUFFIX}, quotient @value{PSUFFIX}, opposite, Functions @value{PSUFFIX}
@section preimage @value{PSUFFIX}
@cindex preimage @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{preimage (} ring_name@code{,} map_name@code{,} ideal_name @code{)}
@*@code{preimage (} ring_name@code{,} ideal_expression@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the preimage of an ideal under a given map.
The second argument has to be a map from the basering to the given ring
(or an ideal defining such a map),
and the ideal has to be an ideal in the given ring.
@item @strong{Note:}
To compute the kernel of a map, the preimage of zero has to be determined.
Hence there is no special command for computing the kernel of a map in
@sc{Plural}. 
@item @strong{Remark:}
in the noncommutative case, it is implemented only for maps A -> B, where A is  a commutative ring
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
ring   R = 0,a,dp;
def Usl2 = sl2();
setring Usl2;
poly  C = 4*e*f+h^2-2*h; // the central element of U(sl2)
ideal I = e^3, f^3, h^3-4*h;
ideal J = twostd(I); // two-sided GB
ideal K = std(I);    // left GB
map Phi = R,C;
setring R;
ideal PreJ = preimage(Usl2,Phi,J); // central character of J
PreJ;
factorize(PreJ[1],1); // there are two simple characters for J
ideal PreK = preimage(Usl2,Phi,K); // central character of K
PreK;
factorize(PreK[1],1); // there are three simple characters for K
 
@c example
@end smallexample
@end table
@c ref
See
@ref{map @value{PSUFFIX}};
@ref{ideal @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref



@c ---------------------------------------
@node quotient @value{PSUFFIX}, reduce @value{PSUFFIX}, preimage @value{PSUFFIX}, Functions @value{PSUFFIX}
@section quotient @value{PSUFFIX}
@cindex quotient @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{quotient (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quotient (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Syntax:}
@code{quotient (} module_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the ideal quotient, resp.@: module quotient. Let @code{R} be the
basering, @code{I,J} ideals and @code{M} a module in
@ifinfo
R^n.
@end ifinfo
@tex
${\tt R}^n$.
@end tex
Then
@itemize
@item
@code{quotient(I,J)}=
@ifinfo
@{a in R | aJ in I @}
@end ifinfo
@tex
$\{a \in R \mid aJ \subset I\}$,
@end tex
@item
@code{quotient(M,J)}=
@ifinfo
@{b in R | bJ in M @}.
@end ifinfo
@tex
$\{b \in R^n \mid bJ \subset M\}$.
@end tex
@end itemize
@item @strong{Note:}
It must used for two-sided ideals (bimodules) only, otherwise the
result may have no meaning.

@item @strong{Example:}
@c // from [BGV], Ex.3.17, p.150, modified by q
@smallexample
@c example
//------ a very easy example ------------
ring r=(0,q),(x,y),Dp;
ncalgebra(q,0); // this algebra is a quantum plane
option(returnSB);
poly f1  = x^3+2*x*y^2+2*x^2*y;
poly f2  = y;
poly f1' = x^2;
poly f2' = x+y;
ideal i = f1,f2;
ideal I = twostd(i);
ideal j = f1',f2';
ideal J = twostd(j);
quotient(I,J);
kill r;
//------- a bit more complicated example
LIB "ncalg.lib";
def Usl2 = sl2(); // this algebra is U(sl_2)
setring Usl2;
ideal i = e3,f3,h3-4*h;
ideal I = std(i);
poly  C = 4*e*f+h^2-2*h;
ideal H = twostd(C-8);
option(returnSB);
ideal Q = quotient(I,H);
print(matrix(Q)); // print a compact presentation of Q
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node reduce @value{PSUFFIX}, std @value{PSUFFIX}, quotient @value{PSUFFIX}, Functions @value{PSUFFIX}
@section reduce @value{PSUFFIX}
@cindex reduce @value{PSUFFIX}
@cindex NF
@table @code
@item @strong{Syntax:}

@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, ideal  or module to its @strong{left} normal form with
respect to an ideal or module represented by a left Groebner basis.
Returns 0 if and only if the polynomial (resp.@: vector, ideal, module)
is an element (resp.@: subideal, submodule) of the ideal (resp.@: module).
The result may have no meaning if the second argument is not a left Groebner basis.
@*The third (optional) argument 1 of type int forces a reduction which considers only the leading term and does no tail reduction.
@item @strong{Note:}
The commands @code{reduce} and @code{NF} are synonymous.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,a),(e,f,h),Dp;
matrix d[3][3];
d[1,2]=-h;  d[1,3]=2e;  d[2,3]=-2f;
ncalgebra(1,d);  // this algebra is a parametric U(sl_2)
ideal I=e2,f2,h2-1;
I=std(I);
print(matrix(I)); // print a compact presentation of I
ideal J=e,h-a;
J=std(J);
print(matrix(J)); // print a compact presentation of J
poly z=4*e*f+h^2-2*h;   // z is the central element of U(sl_2)
NF(z,I);  // the central character of I:
NF(z,J); // the central character of J:
poly nz = z - NF(z,J); // nz will belong to J
NF(nz,J);
@c example
@end smallexample
@end table

@c ref
See also
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node std @value{PSUFFIX}, subst  @value{PSUFFIX}, reduce @value{PSUFFIX}, Functions @value{PSUFFIX}
@section std @value{PSUFFIX}
@cindex std @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} poly_expression @code{)}
@*@code{std (} module_expression@code{,} vector_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis (see @ref{Groebner bases in G-algebras}) for a definition) 
of an ideal or module with respect to the
monomial ordering of the basering. 
@c is a set of generators such that
@c the leading terms generate the leading ideal, resp.@: module.

Use an optional second argument of type poly, resp.@: vector,
to construct the Groebner basis from an already computed one (given as the
first argument) and one additional generator (the second argument).
@item @strong{Note:}
To view the progress of long running computations, use
@code{option(prot)}. 
@ifset singularmanual 
(@pxref{option}(prot)).
@end ifset

@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def R = sl2(); // this algebra is U(sl_2)
setring R;
ideal I = e2, f2, h2-1;
I=std(I);
I;
kill R;
//------------------------------------------
def RQ = Qso3(3); // this algebra is U'_q(so_3) with Q at 6th root of unity
setring RQ;
RQ;
ideal J=x2, y2, z2;
J=std(J);
J;
@c example
@end smallexample
@end table
@c ref
See also
@ref{ideal @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref


@c -------------------------------------------------
@node subst  @value{PSUFFIX}, syz @value{PSUFFIX}, std @value{PSUFFIX}, Functions @value{PSUFFIX}
@section subst @value{PSUFFIX}
@cindex subst @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{subst (} poly_expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} vector _expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} ideal_expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} module _expression,ring_variable, poly_expression @code{)} 
 
@item @strong{Type:}
poly, vector, ideal or module (corresponding to the first argument)

@item @strong{Purpose:}
 substitutes a ring variable by a polynomial. 

@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def R = sl2(); // this algebra is U(sl_2)
setring R;
poly C  = e*f*h;
poly C1 = subst(C,e,h^3);
C1;
poly C2 = subst(C,f,e+f);
C2;
@c example
@end smallexample
@end table
@c ref
@c ref


@c -------------------------------------------------
@node syz @value{PSUFFIX}, twostd, subst  @value{PSUFFIX}, Functions @value{PSUFFIX}
@section syz @value{PSUFFIX}
@cindex syz @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e., the module of relations of the given
generators) of the ideal, resp.@: module.
@item @strong{Note:}
if @code{S} is a matrix of a left syzygy module of left submodule given by matrix @code{M}, then
@code{transpose(S)*transpose(M) = 0}.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def R = Qso3(3);
setring R;
option(redSB);
option(redTail); // we wish to have minimal bases
ideal tst;
ideal J = x3+x,x*y*z;
print(syz(J));
ideal K = x+y+z,y+z,z;
module S = syz(K);
print(S);
tst = ideal(transpose(S)*transpose(K));
std(tst); // check the property of a syzygy module
K = std(K); // now compute the Groebner basis of K ...
print(matrix(K)); // print a compact presentation of K
S = syz(K); // ... and its syzygy module
print(S);
tst = ideal(transpose(S)*transpose(K));
std(tst); // check the property of a syzygy module 
@c example
@end smallexample
@end table
@c ref
See also
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{mres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@c ref


@c ------------------------------
@node twostd, vdim @value{PSUFFIX}, syz @value{PSUFFIX}, Functions @value{PSUFFIX}
@section twostd
@cindex twostd

@table @code
@item @strong{Syntax:}
  @code{twostd(} ideal_expression@code{)}; 
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis of the two-sided ideal,
generated by the input, treated as a set of two-sided generators.
@ifset singularmanual
see @ref{std}
@end ifset
@item @strong{Remark:}
There are algebras with no two-sided ideals except 0 and the
whole algebra (like Weyl algebras).
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def U = sl2(); // this algebra is U(sl_2)
setring U; 
ideal i= e^3, f^3, h^3 - 4*h;
option(redSB);
option(redTail);
ideal I = std(i);
print(matrix(I)); // print a compact presentation of I
ideal J = twostd(i);
print(matrix(J)); // print a compact presentation of J
ideal K = NF(J,I); // elements present in J but not in I
K = K+0; // simplify K
print(matrix(K));
@c example
@end smallexample
@end table


@c -------------------------------------------------------------------------
@node vdim @value{PSUFFIX},Comparison between Singular and Plural functions , twostd, Functions @value{PSUFFIX}
@section vdim @value{PSUFFIX}
@cindex vdim @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{vdim (} ideal_expression @code{)}
@*@code{vdim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the vector space dimension of the 
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the leading terms of the given generators. 
@* If the factor-module is not of finite dimension, -1 is returned.
  
If the generators form a Groebner basis,
this is the same as the vector space dimension of the 
factor-module. 

@item @strong{Note:}
in the noncommutative case, a ring modulo an ideal has a ring stucture if and only if an ideal is two-sided.
@item @strong{Example:}
@smallexample
@c example
ring R=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;  d[1,3]=2x;  d[2,3]=-2y;
ncalgebra(1,d); //U(sl_2)
option(redSB); option(redTail);
ideal I=x3,y3,z3-z;
I=std(I);
I;
vdim(I);

@c example
@end smallexample
@end table
@c ref
See also
@ref{ideal @value{PSUFFIX} };
@ref{std @value{PSUFFIX} };
@ref{kbase @value{PSUFFIX}}.
@c ref

@node Comparison between Singular and Plural functions, ,vdim @value{PSUFFIX}, Functions @value{PSUFFIX}
@section Comparison between Singular and Plural functions
@cindex Singular vs Plural

@multitable @columnfractions .45 .45
@item @code{SINGULAR} @tab @code{PLURAL}
@item @ref{std}       @tab @ref{std  @value{PSUFFIX}}
@item @ref{deg}       @tab deg
@item @code{---}      @tab @ref{twostd}
@item @ref{det}       @tab @code{---} 
@end multitable


@c @c ---------------------------------------
@c @node Control structures @value{PSUFFIX}, System variables @value{PSUFFIX}, Functions @value{PSUFFIX}, Functions and system variables @value{PSUFFIX}
@c @section Control structures @value{PSUFFIX}
@c @cindex Control structures @value{PSUFFIX}

@c See SINGULAR Manual
@c @ifset singularmanual
@c @c ref
@c (@ref{Control structures})
@c @c ref
@c @end ifset

@c @c ---------------------------------------
@c @node System variables @value{PSUFFIX},  , Control structures @value{PSUFFIX}, Functions and system variables @value{PSUFFIX}
@c @section System variables @value{PSUFFIX}
@c @cindex System variables @value{PSUFFIX}

@c See SINGULAR Manual


@c @ifset singularmanual
@c (@pxref{System variables})
@c @end ifset


