  @comment -*-texinfo-*-
@comment $Id: plureference.doc,v 1.17 2004-05-27 20:04:03 levandov Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plureference.info
@settitele PLURAL
@node Top, Functions @value{PSUFFIX}, (dir), (dir)
@menu
* Functions @value{PSUFFIX}::
@end menu

@node Functions @value{PSUFFIX}, , Top, Top 
@chapter  Functions @value{PSUFFIX}
%**end
@end ignore



@cindex Functions @value{PSUFFIX}
This chapter gives a complete reference of all functions, commands and
special variables of the @sc{Plural} kernel (i.e., all built-in
commands).

The general syntax of a function is
@format
                   [target =] function_name (<arguments>);
@end format


@menu
* betti @value{PSUFFIX}::
* bracket::
* eliminate @value{PSUFFIX}::
* fetch@value{PSUFFIX}::
* imap@value{PSUFFIX}::
* intersect @value{PSUFFIX}::
* kbase @value{PSUFFIX}::
* memory @value{PSUFFIX}::
* minres @value{PSUFFIX}::
* mres @value{PSUFFIX}::
* ncalgebra::
* nres @value{PSUFFIX}::
* option @value{PSUFFIX}::
* preimage @value{PSUFFIX}::
* quotient @value{PSUFFIX}::
* reduce @value{PSUFFIX}::
* std @value{PSUFFIX}::
* subst @value{PSUFFIX}:: 
* syz @value{PSUFFIX}:: 
* twostd::
* vdim @value{PSUFFIX}::
@end menu



@c -----------------------------
@node betti @value{PSUFFIX}, bracket, Functions @value{PSUFFIX}, Functions @value{PSUFFIX}
@section betti @value{PSUFFIX}
@cindex betti @value{PSUFFIX}
@table @code
@table @code
@item @strong{Syntax:}
@code{betti (} list_expression @code{)}
@*@code{betti (} resolution_expression @code{)}
@*@code{betti (} list_expression @code{,} int_expression @code{)}
@*@code{betti (} resolution_expression @code{,} int_expression @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
with 1 argument: computes the graded Betti numbers of a minimal resolution of
@tex
$R^n/M$, if $R$ denotes the basering and
$M$ a homogeneous submodule of $R^n$ and the argument represents a
resolution of
$R^n/M$.
@end tex
@iftex
@*
@end iftex
@tex
The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of $R^n/M$ (the 0th (resp.\ 1st) syzygy module of $R^n/M$ is
$R^n$ (resp.\ $M$)).
@end tex
@ifinfo
R^n/M, if R denotes the basering and
M a homogeneous submodule of R^n and the argument represents a resolution of
R^n/M:
@*The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of R^n/M (the 0th (resp.@: 1st) syzygy module of R^n/M is R^n
(resp.@: M)).
@end ifinfo
The argument is considered to be the result of a res/sres/mres/nres/lres
command. This implies that a zero is only allowed (and counted) as a
generator in the first module.
@*For the computation betti uses only the initial monomials. This could lead
to confusing results for a non-homogeneous input.

The optional second argument is a switch for the minimization of the Betti
numbers. If it is 0 then the Betti numbers correspond exactly to the input -
otherwise the command is identical to the one-argument form.
@item @strong{Example:}
@smallexample
@c example
 // Uli Walther
int N=2;
int i;
ring r=0,(x(1..N),d(1..N),q(1..N)),Dp;
matrix D[3*N][3*N];
for (i=1;i<=N;i++)
{
  D[i,N+i]=q(i)^2;
}
ncalgebra(1,D); // a kind of homogenized Weyl algebra
r;
ideal I= maxideal(1);
I;
option(redSB);
option(redTail);
resolution R = mres(I,0); // the full length resolution
print(betti(R),"betti");
kill r;
// betti in qring
LIB "nctools.lib";
int N=1;
int i;
ring r=0,(x(1..N),d(1..N),q(1..N)),Dp;
matrix C = UpOneMatrix(3*N);
for (i=1;i<=N;i++)
{
  C[i,N+i]=-1;
  C[i,2*N+i]=-1;
  C[N+i,2*N+i]=-1;
}
ncalgebra(C,0);
ideal I=0;
for (i=1;i<=N;i++)
{
  I=I,x(i)^2,d(i)^2,x(i)*d(i)+q(i)^2;
}
option(redSB);
option(redTail);
I = twostd(I);
qring QR=I;
QR;
ideal M= maxideal(1);
resolution RM = mres(M,5); // only first 5 steps
print(betti(RM),"betti");

@c example
@end smallexample
@end table








@c -----------------------------
@node bracket, eliminate @value{PSUFFIX}, betti @value{PSUFFIX}, Functions @value{PSUFFIX}
@section bracket
@cindex bracket

@table @code
@item @strong{Syntax:}
@code{bracket (} poly_expression p, poly_expression q @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
Computes the Lie bracket @code{[p,q]=pq-qp} of the first polynomial with
the second in a special way.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
ncalgebra(C,D);
// it is Quantum deformation of U(so_3).
poly p=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z;
// it is the central element  
p=p^3;
p;
poly q=(x+Q*y+Q^2*z)^4;
// it is big noncentral element
q;
bracket(p,q); 
@c example
@end smallexample 
@end table

@c ---------------------------------------
@node eliminate @value{PSUFFIX}, fetch @value{PSUFFIX}, bracket, Functions @value{PSUFFIX}
@section eliminate @value{PSUFFIX}
@cindex eliminate @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
eliminates variables occurring as factors of the second argument from an
ideal, resp.@: module, by intersecting it with the subring not containing
these variables.
@*@code{eliminate} does not need a special ordering nor a Groebner basis as input.
@c @item @strong{Note:}
@c Since elimination is expensive, for homogeneous input it might be useful
@c first to compute the Hilbert function of the ideal (first
@c argument) with a fast ordering (e.g., @code{dp}). Then make use of it to speed
@c up the computation: a Hilbert-driven elimination uses the intvec
@c provided as the third argument.
@item @strong{Example:}
@smallexample
@c example error
ring r=0,(e,f,h,a),Dp;
matrix d[4][4];
d[1,2]=-h;
d[1,3]=2*e;
d[2,3]=-2*f;
ncalgebra(1,d);
// it is U(sl_2)+K[a]
option(redSB);
option(redTail);
poly p=4*e*f+h^2-2*h-a;
// this is central element with parameter
ideal I=e^3,f^3, h^3-4*h,p;
ideal J=eliminate(I,efh);
// this will give us the central character of I
J;
// now we try to eliminate h, that is to intersect with subalgebra [e,f]
// which is not is not admissible subalgebra!
eliminate(I,h); 
eliminate(I,a);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node fetch@value{PSUFFIX}, imap@value{PSUFFIX}, eliminate @value{PSUFFIX}, Functions @value{PSUFFIX}
@section fetch@value{PSUFFIX}
@cindex fetch@value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{fetch (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
maps objects between rings.
@code{fetch} is the identity map between rings and qrings,
the i-th variable of the source ring is mapped to the i-th
variable of the basering.  The coefficient fields must be compatible.
(See @ref{map} for a description of possible mapping between
different ground fields).
@*@code{fetch} offers a convenient way to change
variable names or orderings, or to map objects from a ring to a quotient
ring of that ring or vice versa.
@item @strong{Note:}
Compared with @code{imap}, @code{fetch} uses the position of the ring
variables, not their names.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def Usl2 = sl2();
setring Usl2;
poly  C  = 4*e*f+h^2-2*h; // the central element of U(sl2)
ideal I  = e^3,f^3,h^3-4*h;
ideal J  = twostd(I);
J;
ideal QC = twostd(C);
qring Q  = QC;
ideal QJ = fetch(Usl2,J);
QJ = std(QJ);
QJ; 
@c example
@end smallexample
@end table
@c ref
See
@ref{imap@value{PSUFFIX}};
@ref{map@value{PSUFFIX}};
@ref{qring@value{PSUFFIX}};
@ref{ring@value{PSUFFIX}}.
@c ref


@c ---------------------------------------
@node imap@value{PSUFFIX},intersect @value{PSUFFIX}, fetch@value{PSUFFIX}, Functions@value{PSUFFIX}
@section imap@value{PSUFFIX}
@cindex imap@value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{imap (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
identity map on common subrings.  @code{imap} is the map between rings
and qrings with compatible ground fields which is the identity on
variables and parameters of the same name and 0 otherwise.
(See @ref{map} for a description of possible mapping between
different ground fields).
Useful for mapping from a homogenized ring to the original ring or
for mappings from/to rings with/without parameters. Compared with
@code{fetch}, @code{imap} uses the names of variables and parameters.
Unlike @code{map} and @code{fetch} @code{imap} can map parameters to variables.
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
ring ABP=0,(p4,p5,a,b),dp;
def Usl3 = sl(3);
def BIG = Usl3+ABP;
setring BIG;
poly P4=3*x(1)*y(1)+3*x(2)*y(2)+3*x(3)*y(3)+h(1)^2+h(1)*h(2)+h(2)^2-3*h(1)-3*h(2);  // central element of U(sl_3) of degree 2
poly P5=3/2*x(3)*y(1)*y(2)+3/2*x(1)*x(2)*y(3)+1/2*x(1)*y(1)*h(1)-1*x(2)*y(2)*h(1)+1/2*x(3)*y(3)*h(1)+1/9*h(1)^3+x(1)*y(1)*h(2)-1/2*x(2)*y(2)*h(2)-1/2*x(3)*y(3)*h(2)+1/6*h(1)^2*h(2)-1/6*h(1)*h(2)^2-1/9*h(2)^3-2*x(1)*y(1)+x(2)*y(2)-1/2*x(3)*y(3)-2/3*h(1)^2-1/6*h(1)*h(2)+1/3*h(2)^2+h(1);
P5=18*P5; // central element of U(sl_3) of degree 3 with integer coefficients
ideal J = x(1),x(2),h(1)-a,h(2)-b; // we are interested in the module U(sl_3)/J, depending on parameters a,b
ideal I = p4-P4,p5-P5;
ideal K = I,J;
ideal E = eliminate(K,x(1)*x(2)*x(3)*y(1)*y(2)*y(3)*h(1)*h(2));
E; // this is the ideal of central characters
ring abP = (0,a,b),(p4,p5),dp; // what are the characters on nonzero a,b?
ideal abE = imap(BIG, E);
option(redSB);
option(redTail);
abE = std(abE);
abE; // here they are - we have only one character  
@c example
@end smallexample
@end table
@c ref
See
@ref{fetch @value{PSUFFIX}};
@ref{map @value{PSUFFIX}};
@ref{qring @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}}.
@c ref



@c ------------------------------------------------
@node intersect @value{PSUFFIX}, kbase @value{PSUFFIX}, imap @value{PSUFFIX}, Functions @value{PSUFFIX}
@section  intersect @value{PSUFFIX}
@cindex  intersect   @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{intersect (}expression_list of ideal_expression  @code{)}
@*@code{intersect (}expression_list of module_expression  @code{)}

@item @strong{Type:}
ideal, resp. module 

@item @strong{Purpose:}
computes the intersection of ideals, resp. modules. 


@item @strong{Example:}

@smallexample
@c example

// from [BGV], p.213, Ex.2.5
ring r2=0,(x,y),dp;
ncalgebra(-1,0);
module M=[x,x],[y,0];
module N=[0,y^2],[y,x];
option(redSB);
module Res;
Res=intersect(M,N);
print(Res);
kill r2;

// from [BGV], p.148, Ex.3.8
LIB "ncalg.lib";
ring r=0,(x,d),dp;
Weyl(); // supply r with the structure of the 1st Weyl algebra
ideal I = x+d^2;
ideal J = d-1;
ideal H = intersect(I,J);
H;
@c example
@c//answer: [0,xy^2],[y^2,-xy]
@end smallexample
@end table



@c ------------------------------------------------
@node kbase @value{PSUFFIX}, memory @value{PSUFFIX}, intersect @value{PSUFFIX}, Functions @value{PSUFFIX}
@section kbase @value{PSUFFIX}
@cindex kbase @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{kbase (} ideal_expression @code{)}
@*@code{kbase (} module_expression @code{)}
@*@code{kbase (} ideal_expression@code{,} int_expression@code{)}
@*@code{kbase (} module_expression@code{,} int_expression@code{)}
@item @strong{Type:}
the same as the input type of the first argument
@item @strong{Purpose:}

computes the vector space basis of the 
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the initial terms of the given generators. 
@* If the factor-module is not of finite dimension, -1 is returned.
  
If the generators form a Groebner basis,
this is the same as the vector space basis of the 
factor-module. 

@item @strong{Note:}
you have the ring structure on the ring modulo the ideal if and only
if the ideal is two-sided. 

@item @strong{Example:}
@smallexample
@c example
  ring r=0,(x,y,z),dp;
  matrix d[3][3];
  d[1,2]=-z;
  d[1,3]=2x;
  d[2,3]=-2y;
  ncalgebra(1,d);
  ideal i=x2,y2,z2-1;
  i=std(i);
  i;
  kbase(i);
  vdim(i);
  ideal j=x,z-1;
  j=std(j);
  kbase(j,3);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{vdim @value{PSUFFIX}}.
@c ref
@c ---------------------------------------
@node  memory @value{PSUFFIX}, minres @value{PSUFFIX}, kbase @value{PSUFFIX}, Functions @value{PSUFFIX}
@section memory @value{PSUFFIX}
@cindex memory @value{PSUFFIX}
@cindex memory managment
@table @code
@item @strong{Syntax:}
@code{memory (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns statistics concerning the memory management:
@itemize @bullet
@item @code{memory(0)} is the number of active (used) bytes,
@item @code{memory(1)} is the number of bytes allocated from the
operating system,
@item @code{memory(2)} is the maximal number of bytes ever allocated from the
operating system during the current @sc{Plural} session.
@end itemize
@item @strong{Note:}
To monitor the memory usage during ongoing computations the option
@code{mem} should be set (using the command @code{option(mem);} .
@ifset singularmanual
see also @ref{option}).
@end ifset
@item @strong{Example:}
@smallexample
@c example
ring r=0,(x(1..100)),dp;
ncalgebra(-1,0);
poly p=(x(1)+x(100))^50;
proc ReportMemoryUsage()
{  "Memory currently used by SINGULAR     :",memory(0),"Byte (",
   memory(0)/101023, "KByte)" +newline+
   "Memory currently allocated from system:",memory(1), "Byte (",
   memory(1)/1023, "KByte)";
   "Maximal memory allocated from system  :",memory(2), "Byte (",
   memory(2)/1023, "KByte)";
}
ReportMemoryUsage();
kill p;
ReportMemoryUsage(); // less memory used: p killed
kill r; 
@c example
@end smallexample
@end table
@c ref
@ref{option @value{PSUFFIX}};
@c ref


@c ---------------------------------------
@node  minres @value{PSUFFIX}, mres @value{PSUFFIX}, memory @value{PSUFFIX}, Functions @value{PSUFFIX}
@section minres @value{PSUFFIX}
@cindex minres @value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{minres (} list_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{minres (} resolution_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
minimizes a free resolution of an ideal or module
given by the list_expression, resp.@: resolution_expression.
@item @strong{Example:}

@smallexample
@c example
ring A=0,(x,y,z),Dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
ncalgebra(1,d);
ideal i=x,y,z;
i=std(i);
resolution F=nres(i,0);
F;
int a;
for (a=1;a<=size(list(F));a++)
{
printf("Module: %s",a);
print(matrix(F[a]));
}
resolution MF=minres(F);
MF;
for (a=1;a<=size(list(MF));a++)
{
printf("Module: %s",a);
print(matrix(MF[a]));
}
@c example
@end smallexample
@end table

@c ref
See
@ref{mres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}}.
@c ref




@c ---------------------------------------
@node  mres @value{PSUFFIX}, ncalgebra, minres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section mres @value{PSUFFIX}
@cindex mres @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression @code{)}
@*@code{mres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the
Groebner basis method. More precisely, let A=@code{matrix}(M), then @code{mres}
computes a free resolution of
@ifinfo
coker(A)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@end ifinfo
@tex
$coker(A)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M
\longrightarrow 0,$$
@end tex
where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are a (possibly) minimal set of generators
of M. 
If the int expression k is not zero then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1...k.
@end tex
@ifinfo
Mi=module(Ai), i=1...k.
@end ifinfo
@*@code{mres(M,0)} returns a resolution consisting of at most n+2 modules,
where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then @code{L[1]} consists of a minimal set of generators of the input, @code{L[2]}
consists of a minimal set of generators for the first syzygy module of
@code{L[1]}, etc., until @code{L[p+1]}, such that
@ifinfo
L[i]<>0 for i<=p,
@end ifinfo
@tex
${\tt L[i]}\neq 0$ for $i \le p$,
@end tex
 but @code{L[p+1]}, the first syzygy module of @code{L[p]},
is 0 (if the basering is not a qring).
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c example
ring A=0,(x,y,z),Dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
ncalgebra(1,d);
ideal i=x,y,z;
i=std(i);
resolution M=mres(i,0);
M;
for (int a=1;a<=size(list(M));a++)
{ 
printf("Module: %s",a);
print(matrix(M[a]));
}

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};

@c ref




@c -----------------------------
@node ncalgebra, nres @value{PSUFFIX}, mres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section ncalgebra
@cindex ncalgebra


@table @code
@item @strong{Syntax:}
@*@code{ncalgebra(} matrix_expression C, matrix_expression D @code{)} 
@*@code{ncalgebra(} number_expression n, matrix_expression D @code{)}
@*@code{ncalgebra(} matrix_expression C, poly_expression p @code{)}
@*@code{ncalgebra(} number_expression n, poly_expression p @code{)}
@item @strong{Type:} ring
@item @strong{Purpose:} 
Executed in the basering @code{r}, say, in k variables
@tex 
$ x_1, \ldots, x_k ,\;$
@end tex
@ifinfo
 x_1,... ,x_k, 
@end ifinfo
creates the
non-commutative extension of @code{r} subject to relations
@tex 
$ \{ x_j x_i=c_{ij} \cdot x_i x_j + d_{ij}, 1 \leq i <j \leq k \}, $
where $ c_{ij}$ and $d_{ij}$ should be organized into two strictly upper
@end tex
@ifinfo
@{x_j x_i=c_@{ij@} ..., x_i x_j + d_@{ij@} , 0< i <j < k+1 @}.
where c_@{ij@}  and d_@{ij@  should be organized into two strictly upper
@end ifinfo
 triangular matrices @code{C} with entries
@tex 
$ c_{ij}$ 
@end tex
@ifinfo
c_@{ij@} 
@end ifinfo
 from the ground field of @code{r} 
and @code{D}  with  polynomial entries
@tex 
$ d_{ij}$ 
@end tex
@ifinfo
d_@{ij@} 
@end ifinfo
 from @code{r}.



@item @strong{Remark:}
At present, we do not perform checks of leading monomial condition
and non-degeneracy conditions (@pxref{G-algebras}), while setting an algebra. 



@item @strong{Example:}
@smallexample
@c example
ring r1=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
ncalgebra(C,D);
// it is quantum deformation U'_q(so_3),
// with q=Q^2 specialized at the 3rd root of unity
r1;
kill r1;
ring r2=0,(Xa,Xb,Xc,Ya,Yb,Yc,Ha,Hb),dp;
matrix d[8][8];
d[1,2]=-Xc; d[1,4]=-Ha; d[1,6]=Yb;
d[1,7]=2*Xa; d[1,8]=-Xa; d[2,5]=-Hb;
d[2,6]=-Ya; d[2,7]=-Xb; d[2,8]=2*Xb;
d[3,4]=Xb; d[3,5]=-Xa; d[3,6]=-Ha-Hb;
d[3,7]=Xc; d[3,8]=Xc; d[4,5]=Yc;
d[4,7]=-2*Ya; d[4,8]=Ya; d[5,7]=Yb;
d[5,8]=-2*Yb; d[6,7]=-Yc; d[6,8]=-Yc;
ncalgebra(1,d);
// it is U(sl_3)
r2;
kill r2;
ring r3=0,(a,b,c,d),lp;
matrix c[4][4];
c[1,2]=1; c[1,3]=3; c[1,4]=-2;
c[2,3]=-1; c[2,4]=-3; c[3,4]=1;
ncalgebra(c,0);
// it is some quasi--commutative algebra
r3;
kill r3;
ring r4=0,(t,u,v,w),dp;
ncalgebra(-1,0);
// it is anticommutative algebra
r4;
kill r4;

@c example
@end smallexample
@end table


@c ---------------------------------------
@node  nres @value{PSUFFIX}, option @value{PSUFFIX}, ncalgebra, Functions @value{PSUFFIX}
@section nres @value{PSUFFIX}
@cindex nres @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{nres (} ideal_expression@code{,} int_expression @code{)}
@*@code{nres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module M which is minimized
from  the second module on (by the Groebner basis method).

@c More precisely, let
@c @tex
@c $A_1$=matrix(M),
@c @end tex
@c @ifinfo
@c A1=matrix(M),
@c @end ifinfo
@c then @code{nres} computes a free resolution of
@c @ifinfo
@c coker(A1)=F0/M
@c @format
@c                     A2       A1
@c       ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@c @end format
@c @end ifinfo
@c @tex
@c $coker(A_1)=F_0/M$
@c $$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M\longrightarrow 0,$$
@c @end tex
@c @*where the columns of the matrix
@c @tex
@c $A_1$
@c @end tex
@c @ifinfo
@c A1
@c @end ifinfo
@c are the given set of generators of M.
@c If the int expression k is not zero then the computation stops after k steps
@c and returns a list of modules
@c @tex
@c $M_i={\tt module}(A_i)$, i=1..k.
@c @end tex
@c @ifinfo
@c Mi=module(Ai), i=1..k.
@c @end ifinfo
@c @*@code{nres(M,0)} returns a list of n modules where n is the number of
@c variables of the basering.
@c Let @code{list L=nres(M,0);} then @code{L[1]=M} is identical to the input,
@c @code{L[2]} is a minimal set of generators for the first syzygy
@c module of  @code{L[1]}, etc.
@c @ifinfo
@c (L[i]=M_i
@c @end ifinfo
@c @tex
@c (${\tt L[i]}=M_i$
@c @end tex
@c in the notations from above).
@c @item @strong{Example:}
@smallexample
@c example
ring A=0,(x,y,z),Dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
ncalgebra(1,d);
ideal i=x,y,z;
i=std(i);
resolution F=nres(i,0);
F;
for (int a=1;a<=size(list(F));a++)
{ 
printf("Module: %s",a);
print(matrix(F[a]));
}

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@ref{mres @value{PSUFFIX}};
@c ref


@c ---------------------------------------
@node option @value{PSUFFIX},preimage@value{PSUFFIX}, nres @value{PSUFFIX}, Functions @value{PSUFFIX}
@section option @value{PSUFFIX}
@cindex option @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{option ()}
@item @strong{Type:}
string
@item @strong{Purpose:}
lists all defined options.
@*
@item @strong{Syntax:}
@code{option (} option_name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
sets an option.
@item @strong{Note:}
To disable an option, use the prefix @code{no}.
@*
@item @strong{Syntax:}
@code{option ( get )}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
dumps the state of all options to an intvec.
@*
@item @strong{Syntax:}
@code{option ( set,} intvec_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
restores the state of all options from an intvec (produced by
@code{option(get)}).
@sp 1
@item @strong{Values:}
The following options are used to manipulate the behavior of
computations and act like boolean switches. Use the prefix @code{no} to
disable an option. Notice that some options are ring dependent and reset
to their default values on a change of the current basering.

@table @asis
@c ---------
@item @code{prot}
@cindex prot, option
@cindex protocoll of computations
@cindex progress watch
shows protocol information indicating the
progress during the following computations:
@code{mres},
@code{minres},
@code{res},
@code{std},
@code{syz}.
@c ---------
@item @code{redSB}
@cindex redSB, option
@cindex reduced Groebner basis
computes a reduced Groebner basis in any related computation.
@c ---------
@item @code{redTail}
@cindex redTail, option
reduction of the tails of polynomials during Groebner basis
computations. This option is ring dependent. By default, it is set for
rings with global degree orderings and not set for all other rings.
@c ---------

@end table
@*
The following options, which also control computations, are special,
since they are not manipulated by the @code{option} command but by a
direct assignment of a value. Reset the option by assigning the value 0;
the command @code{option(none)} will not reset them! If there is a
non-zero value assigned, the command @code{option()} prints the option.
@*
The last set of options controls the output of @sc{Plural}:
@table @asis

@item  @code{mem}
@cindex mem, option
@ifset  singularmanual 
shows memory usage in square brackets (see @ref{memory}).
@end ifset
@ifclear singularmanual
shows memory usage in square brackets (see @ref{memory @value{PSUFFIX}}).
@end ifclear  

@c @smallexample
@c @c example
@c   option(prot);
@c   option();
@c   ring r=0,x,dp;
@c   degBound=22;
@c   option();
@c   intvec i=option(get);
@c   option(none);
@c   option(set,i);
@c   option();
@c @c example
@c @end smallexample
@end table

@*The output reported on @code{option(prot)} has the following meaning:
@multitable @columnfractions .01 .14 .11 .65

@item @tab @tab @tab
@item @tab @code{mres}
@tab @code{[}@math{d}@code{]}
@tab computations of the @math{d}-th syzygy module
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{minres}
@tab @code{[}@math{d}@code{]}
@tab minimizing of the @math{d}-th syzygy module
@item @tab @tab @tab
@item @tab @code{reduce}
@tab @code{r} @tab reduced a leading term
@item @tab @tab @tab
@item @tab @code{std}
@tab @code{[}@math{m}@code{:}@math{n}@code{]}
@tab internal ring change to poly representation with exponent bound
@math{m} and @math{n} words in exponent vector
@item @tab @tab @tab
@item @tab @code{syz} @tab @tab all characters: like the output of @code{std}
@end multitable

@end table

@c ref
See
@ref{std @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node preimage@value{PSUFFIX}, quotient @value{PSUFFIX}, 
option @value{PSUFFIX}, Functions @value{PSUFFIX}
@section preimage@value{PSUFFIX}
@cindex preimage@value{PSUFFIX}

@table @code
@item @strong{Syntax:}
@code{preimage (} ring_name@code{,} map_name@code{,} ideal_name @code{)}
@*@code{preimage (} ring_name@code{,} ideal_expression@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the preimage of an ideal under a given map.
@*
The second argument has to be a map from the basering to the given ring
(or an ideal defining such a map),
and the ideal has to be an ideal in the given ring.
@item @strong{Note:}
To compute the kernel of a map, the preimage of zero has to be determined.
Hence there is no special command for computing the kernel of a map in
@sc{Singular}.
@item @strong{Note:}
at the moment it could be computed 
only for maps A -> B, where A is commutative
@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
ring   R = 0,a,dp;
def Usl2 = sl2();
setring Usl2;
poly  C = 4*e*f+h^2-2*h; // the central element of U(sl2)
ideal I = e^3,f^3,h^3-4*h;
ideal J = twostd(I); // two-sided GB
ideal K = std(I);    // left GB
map Phi = R,C;
setring R;
ideal PreJ = preimage(Usl2,Phi,J); // central character of J
PreJ;
factorize(PreJ[1],1); // two characters
ideal PreK = preimage(Usl2,Phi,K); // central character of K
PreK;
factorize(PreK[1],1); // three characters
 
@c example
@end smallexample
@end table
@c ref
See
@ref{map@value{PSUFFIX}};
@ref{ideal@value{PSUFFIX}};
@ref{ring@value{PSUFFIX}}.
@c ref



@c ---------------------------------------
@node quotient@value{PSUFFIX},  reduce @value{PSUFFIX},preimage@value{PSUFFIX}, Functions@value{PSUFFIX}
@section quotient@value{PSUFFIX}
@cindex quotient@value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{quotient (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quotient (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Syntax:}
@code{quotient (} module_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the ideal quotient, resp.@: module quotient. Let @code{R} be the
basering, @code{I,J} ideals and @code{M} a module in
@ifinfo
R^n.
@end ifinfo
@tex
${\tt R}^n$.
@end tex
Then
@itemize
@item
@code{quotient(I,J)}=
@ifinfo
@{a in R | aJ in I @}
@end ifinfo
@tex
$\{a \in R \mid aJ \subset I\}$,
@end tex
@item
@code{quotient(M,J)}=
@ifinfo
@{b in R | bJ in M @}.
@end ifinfo
@tex
$\{b \in R^n \mid bJ \subset M\}$.
@end tex
@end itemize
@item @strong{Example:}
@smallexample
@c example
// from [BGV], Ex.3.17, p.150
ring r=0,(x,y),Dp;
ncalgebra(2,0);
option(returnSB);
poly f1  = x^3+2*x*y^2+2*x^2*y;
poly f2  = y;
poly f1' = x^2;
poly f2' = x+y;
ideal i = f1,f2;
ideal I = twostd(i);
ideal j = f1',f2';
ideal J = twostd(j);
quotient(I,J);
kill r;
// a bit more complicated example
LIB "ncalg.lib";
def Usl2 =sl2();
setring Usl2;
ideal i = e3,f3,h3-4*h;
ideal I = std(i);
poly  C = 4*e*f+h^2-2*h;
ideal H = C-8;
option(returnSB);
ideal Q = quotient(I,H);
Q;
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}}.
@c ref

@c ---------------------------------------
@node reduce @value{PSUFFIX}, std @value{PSUFFIX}, quotient @value{PSUFFIX}, Functions @value{PSUFFIX}
@section reduce @value{PSUFFIX}
@cindex reduce @value{PSUFFIX}
@cindex NF
@table @code
@item @strong{Syntax:}

@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, ideal  or module to its normal form with
respect to an ideal or module represented by a Groebner basis.
Returns 0 if and only if the polynomial (resp.@: vector, ideal, module)
is an element (resp.@: subideal, submodule) of the ideal (resp.@: module).
The result may have no meaning if the second argument is not a Groebner basis.
@*The third (optional) argument 1 of type int forces a reduction which considers only the leading term and does no tail reduction.
@item @strong{Note:}
The commands @code{reduce} and @code{NF} are synonymous.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,a),(e,f,h),Dp;
matrix d[3][3];
d[1,2]=-h;
d[1,3]=2e;
d[2,3]=-2f;
ncalgebra(1,d);
// it is parametric U(sl_2)
ideal I=e2,f2,h2-1;
I=std(I);
ideal J=e,h-a;
J=std(J);
poly z=4*e*f+h^2-2*h;
// z is the central element
// the central character of I:
NF(z,I);
// the central character of J:
NF(z,J);
@c example
@end smallexample
@end table

@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{std @value{PSUFFIX}}.
@c ref

@ifset singularmanual
@c ref
@ref{vector}.
@c ref
@end ifset 

@ifclear singularmanual
see also @code{vector} in @sc{Singular} manual.
@end ifclear   

@c ---------------------------------------
@node std @value{PSUFFIX}, subst @value{PSUFFIX}, reduce @value{PSUFFIX}, Functions @value{PSUFFIX}
@section std @value{PSUFFIX}
@cindex std @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} poly_expression @code{)}
@*@code{std (} module_expression@code{,} vector_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a Groebner basis of an ideal or module with respect to the
monomial ordering of the basering.
A Groebner basis is a set of generators such that
the leading terms generate the leading ideal, resp.@: module.

Use an optional second argument of type poly, resp.@: vector,
to construct the Groebner basis from an already computed one (given as the
first argument) and one additional generator (the second argument).
@item @strong{Note:}
To view the progress of long running computations, use
@code{option(prot)} 
@ifset singularmanual 
(@pxref{option}(prot)).
@end ifset

@item @strong{Example:}
@smallexample
@c example
ring R=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
ncalgebra(1,d); //U(sl_2)
ideal I=x3,y3,z3-z;
I=std(I);
I;
kill R;
ring Rq3=(0,Q),(x,y,z),dp; //U'_q(so_3)
minpoly=Q^2-Q+1; // at the 3rd root of unity
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
ncalgebra(C,D);
ideal J=x3,y3,z3-z;
J=std(J);
J;

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{ring @value{PSUFFIX}};
@ref{option @value{PSUFFIX}};
@c ref


@c -------------------------------------------------
@node subst  @value{PSUFFIX}, syz, std @value{PSUFFIX}, Functions @value{PSUFFIX}
@section subst @value{PSUFFIX}
@cindex subst @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{subst (} poly_expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} vector _expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} ideal_expression,ring_variable, poly_expression  @code{)}
@*@code{subst (} module _expression,ring_variable, poly_expression @code{)} 
 
@item @strong{Type:}
poly, vector, ideal or module (corresponding to the first argument)

@item @strong{Purpose:}
 substitutes a ring variable by a polynomial. 

@item @strong{Example:}
@smallexample
@c example
LIB "ncalg.lib";
def a=sl2();
setring a;
poly C=e*f*h;
poly C1=subst(C,e,h^3);
C1;
poly C2=subst(C,f,e+f);
C2;
@c example
@end smallexample
@end table
@c ref
@c ref


@c -------------------------------------------------
@node syz @value{PSUFFIX}, twostd, subst  @value{PSUFFIX}, Functions @value{PSUFFIX}
@section syz @value{PSUFFIX}
@cindex syz @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e., the module of relations of the given
generators) of the ideal, resp.@: module.
@item @strong{Example:}
@smallexample
@c example
ring Rq=(0,Q),(x,y,z),dp; //U_q(so_3)
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
ncalgebra(C,D);
poly Cq=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z;
poly C1=x^3+x;
poly C2=y^3+y;
poly C3=z^3+z;
ideal I=Cq,C1,C2,C3;
I=std(I);
module a=syz(I);
print(a);
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX}};
@ref{module @value{PSUFFIX}};
@ref{mres @value{PSUFFIX}};
@ref{nres @value{PSUFFIX}};
@ref{minres @value{PSUFFIX}};
@c ref




@c ------------------------------
@node twostd, vdim @value{PSUFFIX}, syz @value{PSUFFIX}, Functions @value{PSUFFIX}
@section twostd
@cindex twostd

@table @code
@item @strong{Syntax:}
  @code{twostd(} ideal_expression@code{)}; 
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis of the two-sided ideal,
generated by the input, treated as a set of two-sided generators.
@ifset singularmanual
see @ref{std}
@end ifset

@item @strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
ncalgebra(1,d); 
// it is algebra U(sl_2)
int N=3;
poly f=1;
for(int n=0;n<=N;n++)
{ 
  f=f*(z+N-2*n);
}
f;
ideal i=x^(N+1),y^(N+1),f;
option(redSB);
option(redTail);
ideal I=std(i);
I;
ideal J=twostd(i);
J;

@c example
@end smallexample
@item @strong{Remark:}
There are algebras with no two-sided ideals (like Weyl algebras).
@end table


@c -------------------------------------------------------------------------
@node vdim @value{PSUFFIX},  , twostd, Functions @value{PSUFFIX}
@section vdim @value{PSUFFIX}
@cindex vdim @value{PSUFFIX}
@table @code
@item @strong{Syntax:}
@code{vdim (} ideal_expression @code{)}
@*@code{vdim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the vector space dimension of the 
factor-module that equals
ring (resp. free module) modulo the ideal (resp. submodule),
generated by the leading terms of the given generators. 
@* If the factor-module is not of finite dimension, -1 is returned.
  
If the generators form a Groebner basis,
this is the same as the vector space dimension of the 
factor-module. 

@item @strong{Note:}
you have the ring structure on the ring modulo the ideal if and only
if the ideal is two-sided. 

@item @strong{Example:}
@smallexample
@c example
ring R=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
ncalgebra(1,d); //U(sl_2)
ideal I=x3,y3,z3-z;
I=std(I);
I;
vdim(I);

@c example
@end smallexample
@end table
@c ref
See
@ref{ideal @value{PSUFFIX} };
@ref{std @value{PSUFFIX} };
@ref{kbase @value{PSUFFIX}}.
@c ref

@ifset singularmanual
@c ref
@ref{dim};
@ref{degree};
@ref{mult};
@c ref
@end ifset

@ifclear singularmanual
see also @sc{Singular} manual sections dim, degree, mult, kbase.
@end ifclear



@c @c ---------------------------------------
@c @node Control structures @value{PSUFFIX}, System variables @value{PSUFFIX}, Functions @value{PSUFFIX}, Functions and system variables @value{PSUFFIX}
@c @section Control structures @value{PSUFFIX}
@c @cindex Control structures @value{PSUFFIX}

@c See SINGULAR Manual
@c @ifset singularmanual
@c @c ref
@c (@ref{Control structures})
@c @c ref
@c @end ifset

@c @c ---------------------------------------
@c @node System variables @value{PSUFFIX},  , Control structures @value{PSUFFIX}, Functions and system variables @value{PSUFFIX}
@c @section System variables @value{PSUFFIX}
@c @cindex System variables @value{PSUFFIX}

@c See SINGULAR Manual


@c @ifset singularmanual
@c (@pxref{System variables})
@c @end ifset


