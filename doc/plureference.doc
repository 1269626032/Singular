@comment -*-texinfo-*-
@comment $Id: plureference.doc,v 1.1 2002-12-20 14:11:58 levandov Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@ignore
%**start
\input texinfo.tex
@setfilename plureference.info
@settitele PLURAL


@node Top, Functions and system variables

%**end
@end ignore


@menu
* bracket::
* plural::
* twostd::
@end menu



@c-----------------------------
@node bracket,plural,Top,Functions and system variables
@section bracket

@table @code
@item @strong{Syntax:}
@code{system (}"bracket", poly_expression p, poly_expression q @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
Computes the Lie bracket @code{[p,q]=pq-qp} of the first polynomial with
the second in a special way.
@item @strong{Example:}
@smallexample
@c example
ring r=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
// it is Quantum deformation of U(so_3).
poly p=Q^4*x2+y2+Q^4*z2+Q*(1-Q^4)*x*y*z;
// it is the central element  
p=p^3;
p;
poly q=(x+Q*y+Q^2*z)^4;
q;
system("bracket",p,q);
@c example
@end smallexample 
@end table




@c-----------------------------
@node plural,twostd,bracket,Functions and system variables
@section plural

@table @code
@item @strong{Syntax:}
@*@code{system(}"PLURAL", matrix_expression C, matrix_expression D @code{)} 
@*@code{system(}"PLURAL", number_expression n, matrix_expression D @code{)}
@*@code{system(}"PLURAL", matrix_expression C, poly_expression p @code{)}
@*@code{system(}"PLURAL", number_expression n, poly_expression p @code{)}
@item @strong{Type:}
@item @strong{Purpose:} 
Based on the given ring @code{r}, say, with "k" variables, strictly upper
triangular matrices with numbers @code{(C)} from the field of @code{r}
and polynomials from @code{r(D)}     

@item @strong{Example:}
@smallexample
@c example
ring r1=(0,Q),(x,y,z),Dp;
minpoly=Q^4+Q^2+1;
matrix C[3][3];
matrix D[3][3];
C[1,2]=Q2;
C[1,3]=1/Q2;
C[2,3]=Q2;
D[1,2]=-Q*z;
D[1,3]=1/Q*y;
D[2,3]=-Q*x; 
system("PLURAL",C,D);
// it is Quantum deformation of U(so_3).
r1;
kill r1;
ring r2=0,(Xa,Xb,Xc,Ya,Yb,Yc,Ha,Hb),dp;
matrix d[8][8];
d[1,2]=-Xc; d[1,4]=-Ha; d[1,6]=Yb;
d[1,7]=2*Xa; d[1,8]=-Xa; d[2,5]=-Hb;
d[2,6]=-Ya; d[2,7]=-Xb; d[2,8]=2*Xb;
d[3,4]=Xb; d[3,5]=-Xa; d[3,6]=-Ha-Hb;
d[3,7]=Xc; d[3,8]=Xc; d[4,5]=Yc;
d[4,7]=-2*Ya; d[4,8]=Ya; d[5,7]=Yb;
d[5,8]=-2*Yb; d[6,7]=-Yc; d[6,8]=-Yc;
system("PLURAL",1,d);
// it is U(sl_3)
r2;
kill r2;
ring r3=0,(a,b,c,d),lp;
matrix c[4][4];
c[1,2]=1; c[1,3]=3; c[1,4]=-2;
c[2,3]=-1; c[2,4]=-3; c[3,4]=1;
system("PLURAL",c,0);
// it  is some quasi--commutative algebra
r3;
kill r3;
ring r4=0,(t,u,v,w),dp;
system("PLURAL",-1,0);
// it is anticommutative algebra
r4;
kill r4;
@c example
@end smallexample


@c------------------------------
@node twostd,,plural ,Functions and system variables
@section twostd
@cindex twostd

@table @code
@item @strong{Syntax:}
@code{system (}"twostd", ideal_expression@code{)}; 
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a left Groebner basis of the two-sided ideal ,
generated by the input, treated as a set of two-sided generators.
@item @strong{Example:}
@smallexample
@c example
ring r=0,(x,y,z),dp;
matrix d[3][3];
d[1,2]=-z;
d[1,3]=2x;
d[2,3]=-2y;
system("PLURAL",1,d); 
// it is algebra U(sl_2)
int N=3;
poly f=1;
for(int n=0;n<=N;n++)
{ 
  f=f*(z+N-2*n);
}
f;
ideal i=x^(N+1),y^(N+1),f;
option(redSB);
option(redTail);
ideal I=std(i);
I;
ideal J=system("twostd",i);
J;
@c example
@end smallexample
@item @strong{Remark:}
There are algebras with no two-sided ideals (like Weyl algebras)
@end table
@c@bye
