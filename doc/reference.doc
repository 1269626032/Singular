@comment -*-texinfo-*-
@comment $Id: reference.doc,v 1.119 1999-07-07 14:11:46 Singular Exp $
@comment this file contains the reference part of the manual

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ifset' and `@end' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).
@ignore
%**start
\input texinfo.tex
@setfilename reference.info
@node Top, Functions and system variables
@menu
* Functions and system variables::
@end menu
@node Functions and system variables, Tricks and pitfalls, Data types, Top
@chapter Functions and system variables
%**end
@end ignore

@c ---------------------------------------
@menu
* Functions::
* Control structures::
* System variables::
@end menu

@c ---------------------------------------
@node Functions, Control structures, Functions and system variables, Functions and system variables
@section Functions
@cindex Functions

This section gives a complete reference of all functions, commands and
special variables of the @sc{Singular} kernel (i.e., all built-in
commands). @xref{standard_lib}, for those
functions from the @code{standard.lib} (this library is automatically
loaded at start-up time) which extend the functionality of the kernel
and are written
in the  @sc{Singular} programming language.

The general syntax of a function is
@* [target =] function_name (<arguments>);
@* If no target is specified, the result is printed.

In some cases (e.g., @code{execute, export, keepring, kill, setring,
type}) the brackets are optional. For the commands
@code{help}, @code{break}, @code{quit}, @code{exit} and @code{LIB} no
brackets are allowed.

@ifinfo
@*List of all supported kernel functions.
@end ifinfo
@menu
* attrib::
* bareiss::
* betti::
* char::
* char_series::
* charstr::
* cleardenom::
* close::
* coef::
* coeffs::
* contract::
* dbprint::
* defined::
* deg::
* degree::
* delete::
* det::
* diff::
* dim::
* dump::
* eliminate::
* eval::
* execute::
* exit::
* extgcd::
* facstd::
* factorize::
* fetch::
* fglm::
* filecmd::
* find::
* finduni::
* fprintf::
* freemodule::
* gcd::
* gen::
* getdump::
* groebner::
* help::
* highcorner::
* hilb::
* homog::
* imap::
* indepSet::
* insert::
* interred::
* intersect::
* jacob::
* jet::
* kbase::
* kill::
* killattrib::
* koszul::
* lead::
* leadcoef::
* leadexp::
* leadmonom::
* LIB::
* lift::
* liftstd::
* listvar::
* lres::
* maxideal::
* memory::
* minbase::
* minor::
* minres::
* modulo::
* monitor::
* mres::
* mstd::
* mult::
* nameof::
* names::
* ncols::
* npars::
* nres::
* nrows::
* nvars::
* open::
* option::
* ord::
* ordstr::
* par::
* pardeg::
* parstr::
* pause::
* preimage::
* prime::
* print::
* printf::
* prune::
* qhweight::
* quot::
* quote::
* quotient::
* random::
* read::
* reduce::
* regularity::
* res::
* reservedName::
* resultant::
* rvar::
* setring::
* simplify::
* size::
* sortvec::
* sprintf::
* sres::
* status::
* std::
* stdfglm::
* stdhilb::
* subst::
* system::
* syz::
* trace::
* transpose::
* type::
* typeof::
* var::
* varstr::
* vdim::
* wedge::
* weight::
* write::
@end menu
@c ---------------------------------------
@node attrib, bareiss, Functions, Functions
@subsection attrib
@cindex attrib
@table @code
@item @strong{Syntax:}
@code{attrib (} name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
displays the attribute list of the object called @emph{name}.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=std(maxideal(2));
  attrib(I);
@c example
@end example
@item @strong{Syntax:}
@code{attrib (} name @code{,} string_expression @code{)}
@item @strong{Type:}
any
@item @strong{Purpose:}
returns the value of the attribute @emph{string_expression} of the @emph{name}.
If the attribute is not defined for this variable, attrib returns the empty string.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=std(maxideal(2));
  attrib(I,"isSB");
  // although maxideal(2) is a standard basis,
  // SINGULAR does not know it:
  attrib(maxideal(2), "isSB");
@c example
@end example
@item @strong{Syntax:}
@code{attrib (} name@code{,} string_expression@code{,} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
sets the attribute @emph{string_expression} of the @emph{name}
to the value @emph{expression}.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=maxideal(2); // the attribute "isSB" is not set
  vdim(I);
  attrib(I,"isSB",1);  // the standard basis attribute is set here
  vdim(I);
@c example
@end example
@item @strong{Remark:}
An attribute may be described by any string_expression, but some are reserved.
Only the reserved attributes are used by the kernel of @sc{Singular}.
Non-reserved attributes may be used, however, in procedures and can
considerably speed up computations.
@sp 1
@item @strong{Reserved attributes:}
(not all are used at the moment)
@table @code
@item isSB
standard basis - set by all commands computing a standard basis like
@code{groebner}, @code{std}, @code{stdhilb} etc.; used by @code{lift}, @code{dim},
@code{degree}, @code{mult}, @code{hilb}, @code{vdim}, @code{kbase}
@item isHomog
the weight vector for homogeneous or quasihomogeneous ideals/modules
@item isCI
complete intersection property
@item isCM
Cohen-Macaulay property
@item rank
set the rank of a module (see @ref{nrows})
@item withSB
value of type ideal resp. module is std
@item withHilb
value of type intvec is hilb(_,1) (see @ref{hilb})
@item withRes
value of type list is a free resolution
@item withDim
value of type int is the dimension (see @ref{dim})
@item withMult
value of type int is the multiplicity (see @ref{mult})
@c @item @code{D}
@c object is an differential operator, if set to 1;
@c @*object is in a module, if set to 0
@c @*only valid in a dring (see @ref{dring}).
@end table
@end table
@c @menu
@c * Expressions::
@c @end menu
@c @iftex
@c See @ref{Expressions}; @ref{killattrib}.
@c @end iftex
@c ---------------------------------------
@node bareiss, betti, attrib, Functions
@subsection bareiss
@cindex bareiss

@table @code
@item @strong{Syntax:}
@code{bareiss (} module_expression @code{)}
@*@code{bareiss (} matrix_expression @code{)}
@*@code{bareiss (} module_expression@code{,} int_expression@code{,} int_expression @code{)}
@*@code{bareiss (} matrix_expression@code{,} int_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list of matrix and intvec
@item @strong{Purpose:}
applies sparse Gauss-Bareiss algorithm (see @ref{References}, Lee and Saunders)
to a module (or with type conversion to a matrix) with an 'optimal' pivotstrategy.
The vectors of the module are the columns of the matrix, hence the rows are eliminated.
With only one parameter a complete elimination is done.
Result is a list: the first entry is a module with a minimal independent set of vectors
(as a matrix lower triangular),
the second entry an intvec with the permutations of the rows
w.r.t. the original matrix.
The further parameters control the algorithm:
the second is the number of last rows out of the elimination and the third is
as follows, if the vectors to reduce in the algorithm
are smaller or equal this number the method stops.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),(c,dp);
  module mm;
  int d=7;
  int b=2;
  int db=d-b;
  int i;
  for(i=d;i>0;i--)
  {
    mm[i]=3*x*gen(i);
  }
  for(i=db;i;i--)
  {
    mm[i]=mm[i]+7*y*gen(i+b);
  }
  for(i=d;i>db;i--)
  {
    mm[i]=mm[i]+7*y*gen(i-db);
  }
  for(i=d;i>b;i--)
  {
    mm[i]=mm[i]+11*z*gen(i-b);
  }
  for(i=b;i;i--)
  {
    mm[i]=mm[i]+11*z*gen(i+db);
  }
  print(mm);
  // complete elimination
  list ss=bareiss(mm);
  print(ss[1]);
  ss[2];
  // elimination up to 3 vectors
  ss=bareiss(mm,0,3);
  print(ss[1]);
  ss[2];
  // elimination without the last 3 rows
  ss=bareiss(mm,3,0);
  print(ss[1]);
  ss[2];
@c example
@end example
@end table
@c ref
See
@ref{det};
@ref{matrix}.
@c ref
@c ---------------------------------------
@node betti, char, bareiss, Functions
@subsection betti
@cindex betti
@table @code
@item @strong{Syntax:}
@code{betti (} list_expression @code{)}
@*@code{betti (} resolution @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
computes the graded Betti numbers of
@tex
$R^n/M$, if $R$ denotes the basering and
$M$ a homogeneous submodule of $R^n$ and the argument represents a
resolution of
$R^n/M$:
@end tex
@iftex
@*
@end iftex
@tex
The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of $R^n/M$ (the 0-th (resp.1-st) syzygy module of $R^n/M$ is
$R^n$ (resp. $M$)).
@end tex
@ifinfo
R^n/M, if R denotes the basering and
M a homogeneous submodule of R^n and the argument represents a resolution of
R^n/M:
@*The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of R^n/M (the 0-th (resp.1-st) syzygy module of R^n/M is R^n
(resp. M)).
@end ifinfo
The argument is considered to be the result of a res/sres/mres/lres command.
(Only the initial monomials are considered for the computation
of the graded Betti numbers.)
@item @strong{Example:}
@example
@c example
  ring r=32003,(a,b,c,d),dp;
  ideal j=bc-ad,b3-a2c,c3-bd2,ac2-b2d;
  list T=mres(j,0); // 0 forces a full resolution
  // a minimal set of generators for j:
  print(T[1]);
  // second syzygy module of r/j which is the first
  // syzygy module of j (minimal generating set):
  print(T[2]);
  // the second syzygy module (minimal generating set):
  print(T[3]);
  print(T[4]);
  betti(T);
  // most useful for reading off the graded Betti numbers:
  print(betti(T),"betti");
@c example
@end example
@end table

Hence
@itemize @bullet
@item the 0th syzygy module of r/j (which is r) has 1 generator in
degree 0 (which is 1)

@item the 1st syzygy module @code{T[1]} (which is j) has 4
generators (one in degree 2 and three in degree 3)

@item the 2nd syzygy
module @code{T[2]} has 4 generators (all in degree 4)

@item the 3rd syzygy module @code{T[3]} has
1 generator in degree 5
@end itemize

where the generators are the columns of the
shown matrix and degrees are assigned such that the corresponding maps
have degree 0 as is shown in the resolution below:
@tex
$$
0 \longleftarrow r/j \longleftarrow r(1)
\buildrel{T[1]}\over{\longleftarrow} r(2) \oplus r^3(3)
\buildrel{T[2]}\over{\longleftarrow} r^4(4)
\buildrel{T[3]}\over{\longleftarrow} r(5)
\longleftarrow 0 \quad .
$$
@end tex
@ifinfo
@*                     T[1]                T[2]           T[3]
@*0 <-- r/j <-- r(1) <------ r(2)+r^3(3) <------ r^4(4) <------ r(5) <-- 0 .
@end ifinfo

@c ref
See
@ref{lres};
@ref{mres};
@ref{print};
@ref{res};
@ref{sres};
@ref{Syzygies and resolutions};
@ref{resolution}.
@c ref
@c ---------------------------------------
@node char, char_series, betti, Functions
@subsection char
@cindex char

@table @code
@item @strong{Syntax:}
@code{char (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the characteristic of the coefficient field of a ring.
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),dp;
  char(r);
  ring s= 0,(x,y),dp;
  char(s);
  ring ra=(7,a),(x,y),dp;
  minpoly=a^3+a+1;
  char(ra);
  ring rp=(49,a),(x,y),dp;
  char(rp);
  ring rr=real,x,dp;
  char(rr);
@c example
@end example
@end table
@c ref
See
@ref{ring};
@ref{charstr}.
@c ref
@c ---------------------------------------
@node char_series, charstr, char, Functions
@subsection char_series
@cindex char_series

@table @code
@item @strong{Syntax:}
@code{char_series (} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
the rows of the matrix represent the irreducible characteristic series of the
ideal with respect to the current variable ordering.
@*One applicatation is the decomposition of the zero-set.
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y,z),dp;
  print(char_series(ideal(xyz,xz,y)));
@c example
@end example
@c @item @strong{Background:}
@c @tex
@c Let $>$ be the lexicographical ordering $x_1 < ... < x_n$ on $R=K[x_1,...,x_n]$.
@c For $f \in R$ let lvar(f) (the leading variable of f) be the largest
@c variable in lead(f) (the leading term of f with respect to $>$),
@c i.e., if $f=a_k(x_1,...,x_{k-1})x_k^s+...+a_0(x_1,...,x_{k-1})$ for some
@c $k \leq n$ then $lvar(f)=x_k$, moreover let $ini(f):=a_k(x_1,...,x_{k-1})$.
@c
@c A set $T=\{f_1,...,f_r\} \subset R$ is called triangular if $lvar(f_1)<...<lvar(f_r)$.
@c The pseudoremainder $r=prem(g,f)$ of $g$ with respect to $f$ is defined by
@c $ini(f)^a*g=q*f+r$ with the property $deg_{lvar(f)}(r)<deg_{lvar(f)}(f)$,
@c a minimal.
@c
@c (T,U) is called a triangular system, if T is a triangular set such that ini(T)
@c does not vanish on $Zero(T) \setminus Zero(U)
@c ( =:Zero(T\setminus U))$.
@c
@c T is called irreducible if for every i there are no $d_i$,$f_i'$,$f_i''$ with
@c the property:
@c $$   lvar(d_i)<lvar(f_i) $$
@c $$   lvar(f_i')=lvar(f_i'')=lvar(f_i)$$
@c $$   0 \not\in prem(\{ d_i, ini(f_i'), ini(f_i'')\},\{ f_1,...,f_(i-1)\})$$
@c such that $prem(d_i*f_i-f_i'*f_i'',\{f_1,...,f_(i-1)\})=0$.
@c
@c (T,U) is irreducible if T is irreducible.
@c
@c Let $G=\{g_1,...,g_s\}$ then there are irreducible triangular sets $T_1,...,T_l$
@c such that $Zero(G)=\bigcup(i=1..l: Zero(T_i\setminus I_i))$
@c where $I_i=\{ini(f), f \in T_i \}$.
@c @end tex
@c @ifinfo
@c Let > be the lexicographical ordering x_1 < ... < x_n on R=K[x_1,...,x_n].
@c For f in R let lvar(f) (the leading variable of f) be the largest
@c variable in lead(f) (the leading term of f with respect to >),
@c i.e., if f=a_k(x_1,...,x_(k-1))x_k^s+...+a_0(x_1,...,x_(k-1)) for some
@c k<=n then lvar(f)=x_k, moreover let ini(f):=a_k(x_1,...,x_(k-1)).
@c
@c A set T=@{f_1,...,f_r@} in R is called triangular if lvar(f_1)<...<lvar(f_r).
@c The pseudoremainder r=prem(g,f) of g with respect to f is defined by
@c ini(f)^a*g=q*f+r with the property deg_(lvar(f))(r)<deg_(lvar(f))(f),s
@c a minimal.
@c
@c (T,U) is called a triangular system, if T is a triangular set such that ini(T)
@c does not vanish on the zero-set of T \ zero-set of U
@c ( =:Zero(T\U)).
@c
@c T is called irreducible if for every i there are no d_i,f_i',f_i'' with
@c the property:
@c @*   lvar(d_i)<lvar(f_i)
@c @*   lvar(f_i')=lvar(f_i'')=lvar(f_i)
@c @*   0 not in prem(@{ d_i, ini(f_i'), ini(f_i'')@},@{ f_1,...,f_(i-1)@})
@c @*such that prem(d_i*f_i-f_i'*f_i'',@{f_1,...,f_(i-1)@})=0.
@c
@c (T,U) is irreducible if T is irreducible.
@c
@c Let G=@{g_1,...,g_s@} then there are irreducible triangular sets T_1,...,T_l
@c such that Zero(G)=Union(i=1..l: Zero(T_i\I_i))
@c where I_i=@{ini(f), f in T_i @}.
@c @end ifinfo
@c @item @strong{Example:}
@c @example
@c @c example
@c   ring R= 0,(x,y,z,u),dp;
@c   ideal i=-3zu+y2-2x+2,
@c           -3x2u-4yz-6xz+2y2+3xy,
@c           -3z2u-xu+y2z+y;
@c   print(char_series(i));
@c @c example
@c @end example
@end table

@c ref
See
@ref{Characteristic sets}.
@c ref
@c ---------------------------------------
@node charstr, cleardenom, char_series, Functions
@subsection charstr
@cindex charstr

@table @code
@item @strong{Syntax:}
@code{charstr (} ring_name @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the description of the coefficient field of a ring.
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),dp;
  charstr(r);
  ring s= 0,(x,y),dp;
  charstr(s);
  ring ra=(7,a),(x,y),dp;
  minpoly=a^3+a+1;
  charstr(ra);
  ring rp=(49,a),(x,y),dp;
  charstr(rp);
  ring rr=real,x,dp;
  charstr(rr);
@c example
@end example
@end table
@c ref
See
@ref{char};
@ref{ring};
@ref{ordstr};
@ref{varstr}.
@c ref
@c ---------------------------------------
@node cleardenom, close, charstr, Functions
@subsection cleardenom
@cindex cleardenom

@table @code
@item @strong{Syntax:}
@code{cleardenom (} poly_expression @code{)}
@*@code{cleardenom (} vector_expression @code{)}
@item @strong{Type:}
same as the input type
@item @strong{Purpose:}
multiplies a polynomial resp. vector by a suitable constant to cancel
all denominators from its coefficients and then divide it by its content.
@item @strong{Note:}

@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  poly f=(3x+6y)^5;
  f;
  cleardenom(f);
@c example
@end example
@end table
@c @menu
@c * poly::
@c @end menu
@c @iftex
@c See @ref{poly}.
@c @end iftex
@c ---------------------------------------
@node close, coef, cleardenom, Functions
@subsection close
@cindex close
@table @code
@item @strong{Syntax:}
@code{close (} link_expression @code{);}
@item @strong{Type:}
none
@item @strong{Purpose:}
closes a link.
@item @strong{Example:}
@example
link l="MPtcp:launch";
open(l); // start SINGULAR "server" on localhost in batchmode
close(l); // shut down SINGULAR server
@end example
@end table
@c ref
See
@ref{link};
@ref{open}.
@c ref
@c ---------------------------------------
@node coef, coeffs, close, Functions
@subsection coef
@cindex coef

@table @code
@item @strong{Syntax:}
@code{coef (} poly_expression@code{,} product_of_ringvars @code{)}
@item @strong{Type:}
matrix
@item @strong{Syntax:}
@code{coef (} vector_expression@code{,} product_of_ringvars@code{,} matrix_name@code{,} matrix_name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
determines the monomials in f divisible by one of the ring variables of m
(where f is the first argument and m the second argument) and the coefficients
of these monomials as polynomials in the remaining variables.

First case:  returns a 2 x n matrix M, n being the number
of the determined monomials.
The first row consists of these monomials, the second row
of the corresponding coefficients of the monomials in f.
Thus f = M[1,1]*M[2,1]+..+M[1,n]*M[2,n].

Second case: the first matrix (i.e., the 3rd argument) contains the
monomials, the second matrix (i.e., the 4th argument) the corresponding
coefficients of the monomials in the vector.

@item @strong{Note:}
coef considers only monomials which really occur in f (i.e., are not 0),
while coeffs returns the coefficient 0 at the appropriate place if a
monomial is not present (see @ref{coeffs}).

@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  poly f=x5+5x4y+10x2y3+y5;
  matrix m=coef(f,y);
  print(m);
  f=x^20+xyz+xy+x2y+z3;
  print(coef(f,xy));
  vector v=[f,zy+77+xy];
  print(v);
  matrix mc; matrix mm;
  coef(v,y,mc,mm);
  print(mc);
  print(mm);
@c example
@end example
@end table
@c ref
See
@ref{coeffs}.
@c ref
@c ---------------------------------------
@node coeffs, contract, coef, Functions
@subsection coeffs
@cindex coeffs

@table @code
@item @strong{Syntax:}
@code{coeffs (} poly_expression @code{,} ring_variable @code{)}
@*@code{coeffs (} ideal_expression@code{,} ring_variable @code{)}
@*@code{coeffs (} vector_expression@code{,} ring_variable @code{)}
@*@code{coeffs (} module_expression@code{,} ring_variable @code{)}
@*@code{coeffs (} poly_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (} ideal_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (} vector_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (} module_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
develops each polynomial from the first argument, say @code{J},
(poly_expression/ .. /module_expression) as a univariate polynomial
in the given ring_variable,
say @code{z}, and returns the coefficients as a @code{k} x @code{d}
matrix @code{M},
where:
@* @code{d-1} = maximum @code{z}-degree of all occurring polynomials
@* @code{k}   = 1 in case J is a polynomial resp. number of generators
in case J is an ideal;
in case of a vector or a module this procedure is repeated for each
component and the resulting matrices are appended.
@*If a third argument is present, say @code{T},
it contains the coefficients such that
@*  @code{matrix(J) = T*M}.
@*Thus if
@tex
$M=(m_{ij})$
@end tex
@ifinfo
M=(M[i,j])
@end ifinfo
the j-th generator of an ideal @code{J} is equal to
@*
@*
@tex
$J_j = z^0 \cdot m_{1j} + z^1 \cdot m_{2j} + ... + z^{d-1} \cdot m_{dj}$,
@end tex
@ifinfo
J[j] = z^0*M[1,j] + z^1*M[2,j] + ... + z^(d-1)*M[d,j],
@end ifinfo
@*
@*while for a module @code{J} the i-th component of the j-th generator is equal to the
entry [i,j] of matrix(@code{J}) and we get
@*
@tex
$[i,j] = z^0 \cdot m_{(i-1)d+1,j} + z^1 \cdot m_{(i-1)d+2,j} + ... + z^{d-1} \cdot m_{id,j}$
@end tex
@ifinfo
 [i,j] = z^0*M[(i-1)*d+1,j] + z^1*M[(i-1)*d+2,j] + ... + z^(d-1)*M[i*d,j]
@end ifinfo

@item @strong{Note:}
coeffs returns the coefficient 0 at the appropriate place if a monomial is
not present, while coef considers only monomials which really occur in the
given expression.

@item @strong{Example:}
@example
@c example
  ring r;
  poly f=(x+y)^5;
  matrix M=coeffs(f,y);
  print(M);
  ideal i=f,xyz+z^10*y^7;
  print(coeffs(i,y));
@c example
@end example
@item @strong{Syntax:}
@code{coeffs (} ideal_expression@code{,} ideal_expression@code{,} product_of_ringvars @code{)}
@*@code{coeffs (} module_expression@code{,} module_expression@code{,} product_of_ringvars @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
let the first argument be M,
the second argument  be K (a set of monomials in P),
the third argument be the product P of variables to consider.
M is supposed to be consisting of elements of (resp. have entries in)
a finitely generated module
over a ring in the variables not appearing in P. K should contain the
generators of the module over this smaller ring.
Then @code{coeffs(M,K,P)} returns a matrix A of coefficients with K*A=M
such that the entries of A do not contain any variable from P.
@*If K does not contain all generators that are necessary to express
M, then K*A=M' where M' is the part of M that can be expressed.

@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal M=x2z+y3,xy;
  print(coeffs(M,ideal(x2,xy,y2),xy));
@c example
@end example
@end table
@c ref
See
@ref{coef}; @ref{kbase}.
@c ref
@c ---------------------------------------
@node contract, dbprint, coeffs, Functions
@subsection contract
@cindex contract

@table @code
@item @strong{Syntax:}
@code{contract (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
contracts each of the n elements of the second ideal J
by each of the m elements of the first ideal I,
producing a m x n matrix.
@*Contraction is defined on monomials by:
@*
@ifinfo
contract( x^A , x^B) := x^(B-A) (if B>=A elementwise), 0 otherwise
@end ifinfo
@tex
$${\rm contract}(x^A ,  x^B) := \cases{ x^{(B-A)}, &if $B\ge A$ elementwise\cr 0,&otherwise.\cr}$$
@end tex
where A and B are the multiexponents of the ring variables represented by x.
@code{contract} is extended bilinearly to all polynomials.
@item @strong{Example:}
@example
@c example
  ring r=0,(a,b,c,d),dp;
  ideal I=a2,a2+bc,abc;
  ideal J=a2-bc,abcd;
  print(contract(I,J));
@c example
@end example
@end table
@c ref
See
@ref{diff}.
@c ref
@c ---------------------------------------
@node dbprint, defined, contract, Functions
@subsection dbprint
@cindex dbprint
@table @code
@item @strong{Syntax:}
@code{dbprint (} int_expression@code{,} expression_list @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
applies the print command to each expression in the expression_list, if
int_expression is positive.
@code{dbprint} may also be used in procedures
in order to print results subject to certain
conditions.
@item @strong{Syntax:}
@code{dbprint (} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
The print command is applied to the expression,
if @code{printlevel=>voice}.
@item @strong{Note:}
@xref{Guidelines for writing a library}, for an example how this is used
for the display of comments while procedures are executed.
@item @strong{Example:}
@example
@c example
  int debug=0;
  intvec i=1,2,3;
  dbprint(debug,i);
  debug=1;
  dbprint(debug,i);
  voice;
  printlevel;
  dbprint(i);
@c example
@end example
@end table
@c ref
See
@ref{print};
@ref{voice};
@ref{printlevel};
@ref{Debugging tools}.
@c ref
@c ---------------------------------------
@node defined, deg, dbprint, Functions
@subsection defined
@cindex defined

@table @code
@item @strong{Syntax:}
@code{defined (} name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns a value !=0 (TRUE) if there is a userdefined object with this name,
and 0 (FALSE) otherwise.
@*A non-zero return value is the level where the object is defined (level
1 denotes the top level, level 2 the level of a first procedure, level 3
the level of a procedure called by a first procedure, etc.).
A local object @code{m} may be identified by @code{if (defined(m)==voice)}.
@item @strong{Example:}
@example
@c example
  ring r= (0,t),(x,y),dp;
  matrix m[5][6]= x,y,1,2,0,x+y;
  defined(mm);
  defined(r) and defined(m);
  defined(m)==voice;             // m is defined in the current level
  defined(x);
  defined(z);
  defined(t);
  defined(42);
@c example
@end example
@end table
@c ref
See
@ref{rvar};
@ref{voice}.
@c ref
@c ---------------------------------------
@node deg, degree, defined, Functions
@subsection deg
@cindex deg

@table @code
@item @strong{Syntax:}
@code{deg (} poly_expression @code{)}
@*@code{deg (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the maximal (weighted) degree of
the terms of a polynomial or a vector;
@*deg(0) is -1.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),lp;
  deg(0);
  deg(x3+y4+xyz3);
  ring rr=7,(x,y),wp(2,3);
  poly f=x2+y3;
  deg(f);
  ring R=7,(x,y),ws(2,3);
  poly f=x2+y3;
  deg(f);
  vector v=[x2,y];
  deg(v);
@c example
@end example
@end table
@c ref
See
@ref{jet};
@ref{ord};
@ref{poly};
@ref{vector}.
@c ref
@c ---------------------------------------
@node degree, delete, deg, Functions
@subsection degree
@cindex degree
@table @code
@item @strong{Syntax:}
@code{degree (} ideal_expression @code{)}
@*@code{degree (} module_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
computes the (Krull) dimension, codimension and the multiplicity
of the ideal resp. module generated by the leading monomials of the input and
prints it.   This is equal to the dimension, codimension and multiplicity
of the ideal resp. module if the input is a standard basis with respect to a
degree ordering.
@item @strong{Example:}
@example
ring r3=32003,(x,y,z),ds;
int a,b,c,t =11,10,3,1;
poly f =x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
  +x^(c-2)*y^c*(y2+t*x)^2;
ideal i= jacob(f);
ideal i0=std(i);
degree(i0);
@expansion{} //codimension 3
@expansion{} //dimension 0
@expansion{} //multiplicity 314
@end example
@end table
@c ref
See
@ref{ideal};
@ref{std};
@ref{dim};
@ref{vdim};
@ref{mult}.
@c ref
@c ---------------------------------------
@node delete, det, degree, Functions
@subsection delete
@cindex delete

@table @code
@item @strong{Syntax:}
@code{delete (} list_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
deletes the element with the given index from a list (the input is not changed).
@item @strong{Example:}
@example
@c example
  list l="a","b","c";
  list l1=delete(l,2);l1;
  l;
@c example
@end example
@end table
@c ref
See
@ref{list};
@ref{insert}.
@c ref
@c ---------------------------------------
@node det, diff, delete, Functions
@subsection det
@cindex det

@table @code
@item @strong{Syntax:}
@code{det (} intmat_expression @code{)}
@*@code{det (} matrix_expression @code{)}
@*@code{det (} module_expression @code{)}
@item @strong{Type:}
int resp. poly
@item @strong{Purpose:}
returns the determinant of a square matrix. A module is considered
as a matrix. The applied algorithms depend on type of input.
If the input is a module or matrix with symbolic entries the
Bareiss algorithm is used. In the other cases the chinese remainder
algorithm is used. For large sparse problems the input as a module
has advantages.
@item @strong{Example:}
@example
@c example
  ring r=7,(x,y),wp(2,3);
  matrix m[3][3]=1,2,3,4,5,6,7,8,x;
  det(m);
@c example
@end example
@end table
@c ref
See
@ref{intmat};
@ref{matrix};
@ref{minor}.
@c ref
@c ---------------------------------------
@node diff, dim, det, Functions
@subsection diff
@cindex diff

@table @code
@item @strong{Syntax:}
@code{diff (} poly_expression@code{,} ring_variable @code{)}
@*@code{diff (} vector_expression@code{,} ring_variable @code{)}
@*@code{diff (} ideal_expression@code{,} ring_variable @code{)}
@*@code{diff (} module_expression@code{,} ring_variable @code{)}
@*@code{diff (} matrix_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Syntax:}
@code{diff (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the partial derivative of a polynomial object by a ring variable
(first forms)
@*respectively differentiates each polynomial (1..n) of the second ideal
by the differential operator corresponding to each polynomial (1..m) in the first
ideal, producing a m x n matrix.
@item @strong{Example:}
@example
@c example
  ring r= 0,(x,y,z),dp;
  poly f=2*x^3*y+3*z^5;
  diff(f,x);
  diff(f,z);
  vector v=[f,y2+z];
  diff(v,z);
  // corresponds to differential operators
  // d2/dx2, d2/dx2+d2/dxdy, d3/dx/dy/dz:
  ideal i=x2,x2+yz,xyz;
  ideal j=x2-yz,xyz;
  print(diff(i,j));
@c example
@end example
@end table
@c ref
See
@ref{poly};
@ref{vector};
@ref{ideal};
@ref{module};
@ref{matrix};
@ref{contract};
@ref{jacob};
@ref{var};
@c ref
@c ---------------------------------------
@node dim, dump, diff, Functions
@subsection dim
@cindex dim

@table @code
@item @strong{Syntax:}
@code{dim (} ideal_expression @code{)}
@*@code{dim (} modul_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the dimension of the ideal resp. module generated by
the leading monomials of the generators representing the given
ideal resp. module. This is also the dimension of the ideal if it is represented by
a standard basis. Note that the dimension of an ideal I means
the Krull dimension of the basering modulo I.
@*The dimension of a
module is the dimension of its annihilator ideal.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal I=std(ideal(x2,xy,y5));
  dim(I);
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{std};
@ref{degree};
@ref{vdim};
@ref{mult}.
@c ref
@c ---------------------------------------
@node dump, eliminate, dim, Functions
@subsection dump
@cindex dump
@table @code
@item @strong{Syntax:}
@code{dump (} link_expression @code{);}
@item @strong{Type:}
none
@item @strong{Purpose:}
dumps (i.e. writes in one "message" or "block") the state of the @sc{Singular}
session (i.e., all defined variables and their values) to the specified
link (which must be either an ASCII or MP link) such that a
@code{getdump} can later retrieve it.
@item @strong{Example:}
@example
@c example
  ring r;
  // write the whole session to the file dump.ascii
  // in ASCII format
  dump(":w dump.ascii");
  kill r;                  // kill the basering
  // reread the session from the file
  // redefining everything which was not explicitly killed before
  getdump("dump.ascii");
  r;
@c example
@end example
@item @strong{Restrictions:}
For ASCII links, integer matrices contained in lists are  dumped as
integer list elements (and not as integer matrices), and lists of list
are dumped as one flatted list. Furthermore, links
themselves are not dumped.
@end table
@c ref
See
@ref{getdump};
@ref{link};
@ref{write}.
@c ref
@c ---------------------------------------
@node eliminate, eval, dump, Functions
@subsection eliminate
@cindex eliminate

@table @code
@item @strong{Syntax:}
@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
eliminates variables occurring as factors of the second argument from an
ideal resp. module by intersection with the subring not containing these variables.
@*@code{eliminate} does not need a special ordering nor a standard basis as input.

@*Since elimination is expensive, it might be useful if the input is
homogeneous, first to compute the Hilbert function of the ideal (first
argument) with a fast ordering (e.g., @code{dp}). Then make use of it to speed
up the computation: a Hilbert-driven elimination uses the intvec
provided as the third argument.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal i=x2,xy,y5;
  eliminate(i,x);
  ring R=0,(x,y,t,s,z),dp;
  ideal i=x-t,y-t2,z-t3,s-x+y3;
  eliminate(i,ts);
  intvec v=hilb(std(i),1);
  eliminate(i,ts,v);
@c example
@end example
@end table
@c ref
See
@ref{hilb};
@ref{ideal};
@ref{module};
@ref{std}.
@c ref
@c ---------------------------------------
@node eval, execute, eliminate, Functions
@subsection eval
@cindex eval
@table @code
@item @strong{Syntax:}
@code{eval (} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
evaluates (quoted) expressions. Within a quoted expression, the
quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
effect of exactly one quote). Used only when receiving a quoted expression
from a MPfile link.
with @code{quote} and @code{write} to
prevent local evaluations  when writing to an MPtcp link.
@item @strong{Example:}
@example
@c @c example
  link l="MPfile:w example.mp";
  ring r=0,(x,y,z),ds;
  ideal i=maxideal(3);
  ideal j=x7,x2,z;
  // compute i+j before writing, but not std
  // this writes 'std(ideal(x3,...,z))'
  write (l, quote(std(eval(i+j))));
  option(prot);
  close(l);
  // now read it in again and evaluate
  // read(l) forces to compute 'std(ideal(x3,...,z))'
  read(l);
  close(l);
@c @c example
@end example
@end table
@c ref
See
@ref{MPfile links};
@ref{quote};
@ref{write}.
@c ref
@c ---------------------------------------
@node execute, exit, eval, Functions
@subsection execute
@cindex execute
@table @code
@item @strong{Syntax:}
@code{execute}(string_expression);
@item @strong{Type:}
none
@item @strong{Purpose:}
executes a string containing a sequence of @sc{Singular} commands.

@item @strong{Note:}
The string is inserted into the input stream at the next line break,
@emph{NOT} after the @code{;} !  Hence, @code{execute} should be the
only command on a line. @code{execute} should be avoided in procedures
whenever possible since it may give rise to name conflicts.  Moreover,
such procedures cannot be precompiled (something @sc{Singular} will
provide in the future).
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal i=x+y,z3+22y;
  write(">save_i",i);
  ring r0=0,(x,y,z),Dp;
  string s="ideal k="+read("save_i")+";";
  s;
  execute(s); // define the ideal k
  k;
@c example
@end example
@end table
@c ---------------------------------------
@node exit, extgcd, execute, Functions
@subsection exit
@cindex exit
@table @code
@item @strong{Syntax:}
@code{exit;}
@item @strong{Purpose:}
exits (quits) @sc{Singular},
works also from inside a procedure or from an interrupt.
@end table
@c ---------------------------------------
@node extgcd, facstd, exit, Functions
@subsection extgcd
@cindex extgcd

@table @code
@item @strong{Syntax:}
@code{extgcd (} int_expression@code{,} int_expression @code{)}
@*@code{extgcd (} poly_expression@code{,} poly_expression @code{)}
@item @strong{Type:}
list of 3 objects of the same type as the type of the arguments
@item @strong{Purpose:}
computes extended gcd: the first element is the greatest common divisor
of the two arguments,
the second and third are factors such that if @code{list L=extgcd(a,b);}
then L[1]=a*L[2]+b*L[3].
@item @strong{Note:}
polynomials must be univariate to apply @code{extgcd}
@item @strong{Example:}
@example
@c example
  extgcd(24,10);
  ring r=0,(x,y),lp;
  extgcd(x4-x6,(x2+x5)*(x2+x3));
@c example
@end example
@end table
@c ref
See
@ref{gcd};
@ref{int};
@ref{poly}
@c ref
@c ---------------------------------------
@node facstd, factorize, extgcd, Functions
@subsection facstd
@cindex facstd

@table @code
@item @strong{Syntax:}
@code{facstd (} ideal_expression @code{)}
@*@code{facstd (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
list of ideals
@item @strong{Purpose:}
returns a list of ideals computed by the factorizing Groebner basis algorithm.
@*The intersection of these ideals has the same zero-set as the input,
i.e., the radical of the intersection coincides with the radical of the input
ideal.
In many cases (but not all!) this is already a decomposition of the radical
of the ideal. (Note however, that, in general, no inclusion between the
input and output ideals holds.)
@*The second, optional argument gives a list of polynomials which define
non-zero constraints. Hence, the intersection of the output ideals
has a zero-set which is the (closure of the) complement of the zero-set
of the second argument in the zero-set of the first argument.
@item @strong{Note:}
Not implemented for basering over real ground fields, galois fields and
over algebraic extensions over the rational numbers (that is, only
implemented for ground fields for which @ref{factorize} is implemented).
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y,z),(c,dp);
  ideal I=xyz,x2z;
  facstd(I);
  facstd(I,x);
@c example
@end example
@end table
@c ref
See
@ref{std};
@ref{ring};
@ref{ideal}.
@c ref
@c ---------------------------------------
@node factorize, fetch, facstd, Functions
@subsection factorize
@cindex factorize

@table @code
@item @strong{Syntax:}
@code{factorize (} poly_expression @code{)}
@*@code{factorize (} poly_expression@code{, 0 )}
@*@code{factorize (} poly_expression@code{, 2 )}
@item @strong{Type:}
list of ideal and intvec
@*
@item @strong{Syntax:}
@code{factorize (} poly_expression@code{, 1 )}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
computes the irreducible factors (as an ideal) of the polynomial
together with or without
the multiplicities (as an intvec) depending on the second argument:
@*0: returns factors and multiplicities, first factor is a constant.
May also be written with only one argument
@*1: returns non-constant factors (no multiplicities)
@*2: returns non-constant factors and multiplicities
@item @strong{Note:}
Not implemented for the coefficient fields real, finite fields of the
type @code{(p^n, a)}, and algebraic extensions over the rational
numbers.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  factorize(9*(x-1)^2*(y+z));
  factorize(9*(x-1)^2*(y+z),1);
  factorize(9*(x-1)^2*(y+z),2);
@c example
@end example
@end table
@c ref
See
@ref{poly}.
@c ref
@c ---------------------------------------
@node fetch, fglm, factorize, Functions
@subsection fetch
@cindex fetch

@table @code
@item @strong{Syntax:}
@code{fetch (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
maps objects between "almost identical" rings.  @code{fetch} is the
identity map between rings and qrings with the same coefficient field
and the same number of variables (but possibly with different
orderings), the i-th variable of the source ring is mapped to the i-th
variable of the basering.  This offers a convenient way to change
variable names or orderings, or to map objects from a ring to a quotient
ring of that ring or vice versa. Compared with @code{imap},
@code{fetch} is much more efficient, but less general.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal i=maxideal(3);
  ideal j=std(i);
  poly f=x+y2+z3;
  vector v=[f,1];
  qring q=j;
  poly f=fetch(r,f);
  f;
  vector v=fetch(r,v);
  v;
  ideal i=fetch(r,i);
  i;
  ring rr=0,(a,b,c),lp;
  poly f=fetch(q,f);
  f;
  vector v=fetch(r,v);
  v;
  ideal k=fetch(q,i);
  k;
@c example
@end example
@end table
@c ref
See
@ref{imap};
@ref{map};
@ref{ring};
@ref{qring}.
@c ref
@c ---------------------------------------
@node fglm, filecmd, fetch, Functions
@subsection fglm
@cindex fglm

@table @code
@item @strong{Syntax:}
@code{fglm (} ring_name@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
calculates for the given ideal in the given ring
a Groebner basis in the current ring. Implements the so-called FGLM
(Faugere, Gianni, Lazard, Mora)  algorithm.
@*The ideal must be zero-dimensional and given as a reduced Groebner
basis in the given ring.
The result is a reduced Groebner basis.
@*The only permissible difference between the given ring and the current ring
may be the monomial ordering and a permutation of the variables
resp. parameters.
@*The main application is to compute a lexicographical Groebner basis
from a reduced Groebner basis with respect to a degree ordering. This
can be much faster than computing a lexicographical Groebner basis
directly.
@c @item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal i=y3+x2, x2y+x2, x3-x2, z4-x2-y;
  option(redSB);   // force the computation of a reduced SB
  i=std(i);
  vdim(i);
  ring s=0,(z,x,y),lp;
  ideal j=fglm(r,i);
  j;
@c example
@end example
@end table
@c ref
See
@ref{ring};
@ref{qring};
@ref{std};
@ref{option};
@ref{vdim}.
@c ref
@c ---------------------------------------
@node filecmd, find, fglm, Functions
@subsection input from files
@cindex filecmd
@cindex <
@table @code
@item @strong{Syntax:}
@code{< "}@file{filename}@code{";}
@item @strong{Type:}
none
@item @strong{Purpose:}
input comes from new file @file{filename}. This is shorthand
@code{execute read(filename)}.
@item @strong{Example:}
@example
< "example"; //read in the file example and execute it
@end example
@end table
@c ref
See
@ref{execute};
@ref{read}.
@c ref
@c ---------------------------------------
@node find, finduni, filecmd, Functions
@subsection find
@cindex find
@table @code
@item @strong{Syntax:}
@code{find (} string_expression@code{,} substring_expression @code{)}
@*@code{find (} string_expression@code{,} substring_expression@code{,} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the first position of the substring
in the string or 0 (if not found),
@*start the search at the position given in the 3rd argument.
@item @strong{Example:}
@example
@c example
  find("Aac","a");
  find("abab","a"+"b");
  find("abab","a"+"b",2);
  find("abab","ab",3);
  find("0123","abcd");
@c example
@end example
@end table
@c ref
See
@ref{string}.
@c ref
@c ---------------------------------------
@node finduni, fprintf, find, Functions
@subsection finduni
@cindex finduni
@table @code
@item @strong{Syntax:}
@code{finduni (} ideal_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns an ideal such that the i-th generator is an univariate polynomial
in the i-th ring variable belonging to ideal_expression.
@* The polynomials have minimal degree w.r.t.@: this property.  The
ideal must be zero-dimensional and given as a reduced Groebner basis in
the current ring.
@item @strong{Example:}
@example
@c example
  ring  r= 0,(x,y,z), dp;
  ideal i= y3+x2, x2y+x2, z4-x2-y;
  option(redSB);  // force computation of reduced basis
  i= std(i);
  ideal k= finduni(i);
  print(k);
@c example
@end example
@end table
@c ref
See
@ref{ring};
@ref{std};
@ref{option};
@ref{vdim}.
@c ref

@c ---------------------------------------
@node fprintf, freemodule, finduni, Functions
@subsection fprintf
@cindex fprintf
@c lib standard.lib:fprintf lib_fun lib_ex

@c ---------------------------------------
@node freemodule, gcd, fprintf, Functions
@subsection freemodule
@cindex freemodule

@table @code
@item @strong{Syntax:}
@code{freemodule (} int_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
creates the free module of rank n generated by
@code{gen(1)}, @dots{}, @code{gen(n)}.
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),(c,dp);
  freemodule(3);
  matrix m = freemodule(3); // generates the 3x3 unit matrix
  print(m);
@c example
@end example
@end table
@c ref
See
@ref{gen};
@ref{module}.
@c ref
@c ---------------------------------------
@node gcd, gen, freemodule, Functions
@subsection gcd
@cindex gcd

@table @code
@item @strong{Syntax:}
@code{gcd (} int_expression@code{,} int_expression @code{)}
@*@code{gcd (} poly_expression@code{,} poly_expression @code{)}
@item @strong{Type:}
the same as the type of the arguments
@item @strong{Purpose:}
computes the greatest common divisor.
@item @strong{Note:}
Not implemented for the coefficient fields real, finite fields of the
type @code{(p^n, a)}, and algebraic extensions over the rational
numbers.
@item @strong{Example:}
@example
@c example
  gcd(2,3);
  ring r=0,(x,y,z),lp;
  gcd(3x2*(x+y),9x*(y2-x2));
@c example
@end example
@end table
@c ref
See
@ref{extgcd};
@ref{int};
@ref{poly}
@c ref
@c ----------------------------------------
@node gen, getdump, gcd, Functions
@subsection gen
@cindex gen

@table @code
@item @strong{Syntax:}
@code{gen (} int_expression @code{)}
@item @strong{Type:}
vector
@item @strong{Purpose:}
returns the i-th free generator of a free module.
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y,z),(c,dp);
  gen(3);
  vector v=gen(5);
  poly f= xyz;
  v=v+f*gen(4); v;
  ring rr= 32003,(x,y,z),dp;
  fetch(r,v);
@c example
@end example
@end table
@c ref
See @ref{freemodule}; @ref{int}; @ref{vector}.
@c ref
@c ---------------------------------------
@node getdump, groebner, gen, Functions
@subsection getdump
@cindex getdump
@table @code
@item @strong{Syntax:}
@code{getdump (} link_expression @code{) ;}
@item @strong{Type:}
none
@item @strong{Purpose:}
reads the contents of the entire file resp.@: link and restores all variables
from it. For ASCII links, @code{getdump} is equivalent to a
@code{execute read (} link @code{);} command. For MP links,
@code{getdump} should only be used on data which was previously
@code{dump}'ed.
@item @strong{Example:}
@example
@c example
  int i=3;
  dump(":w example.txt");
  kill i;
  option(noredefine);
  getdump("example.txt");
  i;
@c example
@end example
@item @strong{Restrictions:}
@code{getdump} is not supported for DBM links, or for a link connecting
to @code{stdin} (standard input).
@end table
@c ref
See
@ref{link};
@ref{dump};
@ref{read}.
@c ref
@c ---------------------------------------
@node groebner, help, getdump, Functions
@subsection groebner
@cindex groebner
@c lib standard.lib:groebner lib_fun lib_ex

@c @table @code
@c @item @strong{Syntax:}
@c @code{groebner (} ideal_expression @code{)}
@c @*@code{groebner (} module_expression @code{)}
@c @item @strong{Type:}
@c ideal or module
@c @item @strong{Purpose:}
@c returns a standard basis of an ideal or module with respect to the
@c monomial ordering of the basering using a heuristically chosen method.
@c @item @strong{Example:}
@c @example
@c @c example
@c   ring r = 0, (a,b,c,d), lp;
@c   ideal i = a+b+c+d, ab+ad+bc+cd, abc+abd+acd+bcd, abcd-1;
@c   groebner(i);
@c @c example
@c @end example
@c @end table
@c @c ref
@c See
@c @ref{std};
@c @ref{stdfglm};
@c @ref{stdhilb}.
@c @c ref
@c ---------------------------------------
@node help, highcorner, groebner, Functions
@subsection help
@cindex help
@table @code
@item @strong{Syntax:}
@code{help;}
@*@code{help} command_name @code{;}
@*@code{help} section_title @code{;}
@*@code{help} lib_name @code{;}
@*@code{help} procedure_name @code{;}
@item @strong{Type:}
none
@item @strong{Purpose:}
provides help information.
@* The online version of the manual is used for the first three forms of
the @code{help} command.  @code{help} lib_name @code{;} and @code{help}
procedure_name @code{;} directly display the help sections from libraries and
procedures, resp., if those are present.  The latter forms do not enter
the online help system.
@cindex ?
@item @strong{Note:}
@code{?} may be used instead of @code{help}.
@item @strong{Example:}
@example
help;
help ring;
help Rings and orderings;
help all.lib;
@end example
@end table
@c ref
See
@ref{Format of a library};
@ref{Procedure definition};
@ref{The online help system}.
@c ref
@c ---------------------------------------
@node highcorner, hilb, help, Functions
@subsection highcorner
@cindex highcorner
@table @code
@item @strong{Syntax:}
@code{highcorner(} ideal_expression @code{);}
@*@code{highcorner(} module_expression @code{);}
@item @strong{Type:}
poly resp.@: vector
@item @strong{Purpose:}
returns the smallest monomial not contained in
the ideal resp.@: module generated by the initial terms of the given generators.
If the generators are a standard basis,
this is also the smallest monomial not contained in the ideal resp.@: module.
@*If the ideal  resp.@: module is not zero-dimensional, 0 is returned.
@item @strong{Remark:}
Let the ideal I given by a standard basis and x(i) the variables of
the basering.
highcorner(I) returns 0 iff dim(I)>0 or dim(I)=-1. Otherwise it returns
the smallest monomial m not in I which has the following properties:
@itemize @bullet
@item
if x(i) > 1 then x(i) does not divide m (e.g. m=1 if the ordering is global)
@item
given any set of generators of f_1,...f_k of I and let f_i' be obtained from
f_i by deleting all terms divisible by x(i)*m for all i with x(i) < 1.
Then f_1',...,f_k' generate I.
@end itemize
@item @strong{Example:}
@example
@c example
ring r=0,(x,y),ds;
ideal i=x3,x2y,y3;
highcorner(std(i));
highcorner(std(ideal(1)));
@c example
@end example
@end table
@c ref
See
@ref{dim};
@ref{std};
@ref{vdim}.
@c ref
@c ---------------------------------------
@node hilb, homog, highcorner, Functions
@subsection hilb
@cindex hilb
@table @code
@item @strong{Syntax:}
@code{hilb (} ideal_expression @code{)}
@*@code{hilb (} module_expression @code{)}
@*@code{hilb (} ideal_expression@code{,} int_expression @code{)}
@*@code{hilb (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
none (if called with one argument)
@*intvec (if called with two arguments)
@item @strong{Purpose:}
computes the Hilbert series of the ideal resp.@: module
defined by the leading terms of the generators
of the given ideal resp.@: module. If the ringorder is a weighted
degree order, the Hilbert series is computed w.r.t to this weights.
In the other cases all weights are one. If the input is
homogeneous w.r.t. to the weights and a standard basis,
this is the (weighted) Hilbert series of the original
ideal resp.@: module.

Prints first and second Hilbert series with one argument,
returns the n-th (n=1, 2) Hilbert series as intvec with two arguments.
The leading number of the intvec is not part of the Hilbert series and
is used in the Hilbert driven standard basis computation.
@item @strong{Example:}
@example
@c example
  ring R=32003,(x,y,z),dp;
  ideal i=x2,y2,z2;
  ideal s=std(i);
  hilb(s);
  hilb(s,1);
  hilb(s,2);
@c example
@end example
@end table
@c ref
See
@ref{Hilbert function};
@ref{ideal};
@ref{intvec};
@ref{module};
@ref{stdhilb};
@ref{std}.
@c ref
@c ---------------------------------------
@node homog, imap, hilb, Functions
@subsection homog
@cindex homog

@table @code
@item @strong{Syntax:}
@code{homog (} ideal_expression @code{)}
@*@code{homog (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
tests for homogeneity: return 1 for homogeneous input, 0 otherwise.
@item @strong{Syntax:}
@*@code{homog (} polynomial_expression@code{,} ring_variable @code{)}
@*@code{homog (} vector_expression@code{,} ring_variable @code{)}
@*@code{homog (} ideal_expression@code{,} ring_variable @code{)}
@*@code{homog (} module_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
same as first argument
@item @strong{Purpose:}
homogenizes polynomials, vectors, ideals or modules by multiplying
each monomial with a suitable power of the given ring variable (which must have
weight 1).
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),ds;
  poly s1=x3y2+x5y+3y9;
  poly s2=x2y2z2+3z8;
  poly s3=5x4y2+4xy5+2x2y2z3+y7+11x10;
  ideal i=s1,s2,s3;
  homog(s2,z);
  homog(i,z);
  homog(i);
  homog(homog(i,z));
@c example
@end example
@end table
@c ref
See
@ref{poly};
@ref{vector};
@ref{ideal};
@ref{module}.
@c ref
@c ---------------------------------------
@node imap, indepSet, homog, Functions
@subsection imap
@cindex imap

@table @code
@item @strong{Syntax:}
@code{imap (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
identity map on common subrings.  @code{imap} is the map between rings,
and qrings with the compatible ground coefficient field which is the identity on
variables and parameters of the same name and 0 otherwise.
(See @ref{map} for a description of possible mapping between
different ground fields).
Useful for mapping from a homogenizing ring to the original ring or
for mappings from/to rings with/without parameters. Compared with
@code{fetch}, @code{imap} is more general, but less efficient.
@item @strong{Example:}
@example
@c example
  ring r = 0,(x,y,z,a,b,c),dp;
  ideal i = xy2z3a4b5 + 1, homog(xy2z3a4b5 + 1, c); i;
  ring r1 = 0,(a,b,x,y,z),lp;
  ideal j = imap(r, i); j;
  ring r2 = (0, a, b), (x,y,z), ls;
  ideal j = imap(r, i); j;
@c example
@end example
@end table
@c ref
See
@ref{fetch};
@ref{homog};
@ref{map};
@ref{qring};
@ref{ring}.
@c ref
@c ---------------------------------------
@node indepSet, insert, imap, Functions
@subsection indepSet
@cindex indepSet

@table @code
@item @strong{Syntax:}
@code{indepSet (} ideal_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
computes a maximal set U of independent variables of the ideal given by
a standard basis.  If v is the result then v[i] is 1 if and only if the
i-th variable of the ring is an independent variable.  Hence the set U
consisting of the variables x(i) s.t. v[i]=1 is a maximal independent
set.

@c Indeed we compute a maximal strongly independent set U,
@c where no power of a variable from U occurs as a leading term ofs
@c a standard basis of the ideal.


U is a set of independent variables if and only if
@tex
$I \cap K[U]=(0)$ is,
@end tex
@ifinfo
I intersect K[U]=(0),
@end ifinfo
i.e., eliminating the remaining variables gives (0).
@item @strong{Syntax:}
@code{indepSet (} ideal_expression, int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
computes a list of all maximal sets (if the flag is 0), or of all sets of independent variables of the ideal given by the first argument
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z,u,v,w),dp;
  ideal I=xyzw,yzvw,uzw,xyv;
  attrib(I,"isSB",1);
  indepSet(I);
  eliminate(I,vw);
  indepSet(I,0);
  indepSet(I,1);
  eliminate(I,xuv);
@c example
@end example
@end table
@c ref
See
@ref{std};
@ref{ideal}.
@c ref
@c ---------------------------------------
@node insert, interred, indepSet, Functions
@subsection insert
@cindex insert

@table @code
@item @strong{Syntax:}
@code{insert (} list_expression@code{,} expression @code{)}
@*@code{insert (} list_expression@code{,} expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
inserts a new element into a list at the beginning or (if called with 3
arguments) after the given position (the input is not changed).
@item @strong{Example:}
@example
@c example
  list L=1,2;
  insert(L,4,2);
  insert(L,4);
@c example
@end example
@end table
@c ref
See
@ref{list};
@ref{delete}.
@c ref
@c ---------------------------------------
@node interred, intersect, insert, Functions
@subsection interred
@cindex interred
@table @code
@item @strong{Syntax:}
@code{interred (} ideal_expression @code{)}
@*@code{interred (} module_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
interreduces a set of polynomials/vectors.
@*
@ifinfo
input: f_1,@dots{},f_n
@end ifinfo
@tex
input: $f_1,...,f_n$
@end tex
@*
@ifinfo
output: g1,@dots{},gs with s<=n and the properties
@end ifinfo
@tex
output: $g_1,...,g_s$ with $s<=n$ and the properties
@end tex
@itemize @bullet
@item
@ifinfo
(f1,@dots{},fn) = (g1,@dots{},gs)
@end ifinfo
@tex
$(f_1,...,f_n) = (g_1,...,g_s)$
@end tex
@item
@ifinfo
L(g_i)<>L(g_j) for all i<>j
@end ifinfo
@tex
L($g_i)\neq $L($g_j$) for all $i\neq j$
@end tex
@item
in the case of a global ordering (polynomial ring):
@*
@ifinfo
L(gi)
@end ifinfo
@tex
$L(g_i)$
@end tex
 does not divide m for all monomials m of
@ifinfo
@{g1,@dots{},g(i-1),g(i+1),@dots{},gs@}
@end ifinfo
@tex
$\{g_1,...,g_{i-1},g_{i+1},...,g_s\}$
@end tex
@item
in the case of a local or mixed ordering (localization of polynomial ring):
@*if, for any i<>j,
@ifinfo
L(gi) | L(gj)
@end ifinfo
@tex
$L(g_i) | L(g_j)$
@end tex
then
@ifinfo
ecart(gi) > ecart(gj)
@end ifinfo
@tex
$ecart(g_i) > ecart(g_j)$
@end tex
@end itemize
@tex
Remark: $L(g)$ denotes the leading term of $g$ and $ecart(g)=deg(g)-deg(L(g))$.
@end tex
@ifinfo
Remark: L(g) denotes the leading term of g and ecart(g)=deg(g)-deg(L(g)).
@end ifinfo
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal i=x2+z,z,2z;
  interred(i);
  ring R=0,(x,y,z),ds;
  ideal i=zx+y3,z+y3,z+xy;
  interred(i);
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{module};
@ref{std}.
@c ref
@c ---------------------------------------
@node intersect, jacob, interred, Functions
@subsection intersect
@cindex intersect
@table @code
@item @strong{Syntax:}
@code{intersect (} expression_list of ideal_expression @code{)}
@*@code{intersect (} expression_list of module_expression @code{)}
@item @strong{Type:}
ideal resp. module
@item @strong{Purpose:}
ideal resp. module intersection.
@item @strong{Note:}
If the option @code{returnSB} is enabled then the result is a standard basis.
@item @strong{Example:}
@example
@c example
  ring R=0,(x,y),dp;
  ideal i=x;
  ideal j=y;
  intersect(i,j);
  ring r=181,(x,y,z),(c,ls);
  ideal id1=maxideal(3);
  ideal id2=x2+xyz,y2-z3y,z3+y5xz;
  ideal id3=intersect(id1,id2,ideal(x,y));
  id3;
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{module};
@ref{option}.
@c ref
@c ---------------------------------------
@node jacob, jet, intersect, Functions
@subsection jacob
@cindex jacob
@table @code
@item @strong{Syntax:}
@code{jacob (} poly_expression @code{)}
@*@code{jacob (} ideal_expression @code{)}
@item @strong{Type:}
ideal, if the input is a polynomial
@* matrix, if the input is an ideal
@item @strong{Purpose:}
computes the Jacobi ideal resp.@: Jacobi matrix generated by all
partial derivatives of the input.
@item @strong{Example:}
@example
@c example
  ring R;
  poly f=x^2+y^3+z^5;
  jacob(f);
  ideal i=jacob(f);
  print(jacob(i));
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{module};
@ref{diff};
@ref{nvars}.
@c ref
@c ---------------------------------------
@node jet, kbase, jacob, Functions
@subsection jet
@cindex jet
@table @code
@item @strong{Syntax:}
@code{jet (} poly_expression@code{,} int_expression @code{)}
@*@code{jet (} vector_expression@code{,} int_expression @code{)}
@*@code{jet (} ideal_expression@code{,} int_expression @code{)}
@*@code{jet (} module_expression@code{,} int_expression @code{)}
@*@code{jet (} poly_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} vector_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} ideal_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} module_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
deletes from the first argument all terms of degree (resp. weighted degree where
the weights are given by the third argument) bigger than the second
argument.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,dp);
  jet(1+x+x2+x3+x4,3);
  poly f=1+x+y+z+x2+xy+xz+y2+x3+y3+x2y2+z4;
  jet(f,3);
  intvec iv=2,1,1;
  jet(f,3,iv);
  // the part of f with (total) degree >3:
  f-jet(f,3);
  // the homogeneous part of f of degree 2:
  jet(f,2)-jet(f,1);
  // the part of maximal degree:
  jet(f,deg(f))-jet(f,deg(f)-1);
  // the absolute term of f:
  jet(f,0);
  // now for other types:
  ideal i=f,x,f*f;
  jet(i,2);
  vector v=[f,1,x];
  jet(v,1);
  jet(v,0);
  v=[f,1,0];
  module m=v,v,[1,x2,z3,0,1];
  jet(m,2);
@c example
@end example
@end table
@c ref
See
@ref{deg};
@ref{int};
@ref{intvec};
@ref{ideal};
@ref{module};
@ref{poly};
@ref{vector}.
@c ref
@c ---------------------------------------
@node kbase, kill, jet, Functions
@subsection kbase
@cindex kbase
@table @code
@item @strong{Syntax:}
@code{kbase (} ideal_expression @code{)}
@*@code{kbase (} module_expression @code{)}
@*@code{kbase (} ideal_expression@code{,} int_expression@code{)}
@*@code{kbase (} module_expression@code{,} int_expression@code{)}
@item @strong{Type:}
the same as the input type of the first argument
@item @strong{Purpose:}
@*with one argument:
computes a vector space basis (consisting of monomials)
of the quotient ring by the ideal
resp. of a free module by the module in case this is finite dimensional
and if the input is a standard basis with respect to the ring ordering.
If the input is no standard basis, the leading terms of the input are
used and the result may have no meaning.
@*with two arguments:
a part of the same result with degree of the monomials equal to the
second argument, the quotient need not be finite dimensional.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),ds;
  ideal i=x2,y2,z;
  kbase(std(i));
  i=x2,y3,xyz;
  kbase(std(i),2);
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{module};
@ref{vdim}.
@c ref
@c ---------------------------------------
@node kill, killattrib, kbase, Functions
@subsection kill
@cindex kill
@table @code
@item @strong{Syntax:}
@code{kill}(name)@code{;}
@*@code{kill}(list_of_names)@code{;}
@item @strong{Type:}
none
@item @strong{Purpose:}
deletes objects.
@item @strong{Example:}
@example
@c example error
  int i=3;
  ring r= 0,x,dp;
  poly p;
  listvar();
  kill(i,r);
  // the variable `i` does not exist any more
  i;
  listvar();
@c example
@end example
@end table
@c ref
See
@ref{defined};
@ref{general_lib};
@ref{names}
@c ref
@c ---------------------------------------
@node killattrib, koszul, kill, Functions
@subsection killattrib
@cindex killattrib
@table @code
@item @strong{Syntax:}
@code{killattrib (} name@code{,} string_expression @code{) ;}
@item @strong{Type:}
none
@item @strong{Purpose:}
deletes the attribute given as the second argument.
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),lp;
  ideal i=maxideal(1);
  attrib(i,"isSB",1);
  attrib(i);
  killattrib(i,"isSB");
  attrib(i);
@c example
@end example
@end table
@c ref
See
@ref{attrib};
@ref{option}.
@c ref
@c ---------------------------------------
@node koszul, lead, killattrib, Functions
@subsection koszul
@cindex koszul
@table @code
@item @strong{Syntax:}
@code{koszul (} int_expression@code{,} int_expression @code{)}
@*@code{koszul (} int_expression@code{,} ideal_expression @code{)}
@*@code{koszul (} int_expression@code{,} int_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
@code{koszul(d,n)} computes a matrix of the Koszul relations of degree d of
the first n ring variables.

@code{koszul(d,id)} computes a matrix of the Koszul relations of degree d of
the generators of the ideal @code{id}.

@code{koszul(d,n,id)} computes a matrix of the Koszul relations of degree d of
the first n generators of the ideal @code{id}.

koszul(1,id),koszul(2,id),... form a complex, that is, the product
of @code{koszul(i,id)} and @code{koszul(i+1,id)} equals zero.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  print(koszul(3,2));
  ideal I=xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z;
  print(koszul(1,I));
  print(koszul(2,I));
  print(koszul(2,I)*koszul(3,I));
@c example
@end example
@end table
@c ref
See
@ref{int};
@ref{matrix}.
@c ref
@c -------------------------------------------------
@node lead, leadcoef, koszul, Functions
@subsection lead
@cindex lead
@table @code
@item @strong{Syntax:}
@code{lead (} poly_expression @code{)}
@*@code{lead (} vector_expression @code{)}
@*@code{lead (} ideal_expression @code{)}
@*@code{lead (} module_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
returns the leading (or initial) term(s) of a polynomial, a vector,
or of the generators of an ideal or module with respect
to the monomial ordering.
@cindex IN
@item @strong{Note:}
@code{IN} may be used instead of @code{lead}.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,ds);
  poly f=2x2+3y+4z3;
  vector v=[2*x^10,f];
  ideal i=f,z;
  module m=v,[0,0,2+x];
  lead(f);
  lead(v);
  lead(i);
  lead(m);
  lead(0);
@c example
@end example
@end table
@c ref
See
@ref{leadcoef};
@ref{leadexp};
@ref{leadmonom};
@ref{poly};
@ref{vector};
@ref{ideal};
@ref{module}.
@c ref
@c -------------------------------------------------
@node leadcoef, leadexp, lead, Functions
@subsection leadcoef
@cindex leadcoef
@table @code
@item @strong{Syntax:}
@code{leadcoef (} poly_expression @code{)}
@*@code{leadcoef (} vector_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
returns the leading (or initial) coefficient of a polynomial or a vector
with respect to the monomial ordering.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,ds);
  poly f=x2+y+z3;
  vector v=[2*x^10,f];
  leadcoef(f);
  leadcoef(v);
  leadcoef(0);
@c example
@end example
@end table
@c ref
See
@ref{lead};
@ref{leadexp};
@ref{leadmonom};
@ref{number}
@ref{poly};
@ref{vector}.
@c ref
@c -------------------------------------------------
@node leadexp, leadmonom, leadcoef, Functions
@subsection leadexp
@cindex leadexp
@table @code
@item @strong{Syntax:}
@code{leadexp (} poly_expression @code{)}
@*@code{leadexp (} vector_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
returns the exponent vector of the leading monomial of a polynomial or a vector.
In the case of a vector the last component is the index in the vector.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,ds);
  poly f=x2+y+z3;
  vector v=[2*x^10,f];
  leadexp(f);
  leadexp(v);
  leadexp(0);
@c example
@end example
@end table
@c ref
See
@ref{lead};
@ref{leadcoef};
@ref{leadmonom};
@ref{intvec};
@ref{poly};
@ref{vector}.
@c ref
@c -------------------------------------------------
@node leadmonom, LIB, leadexp, Functions
@subsection leadmonom
@cindex leadmonom
@table @code
@item @strong{Syntax:}
@code{leadmonom (} poly_expression @code{)}
@*@code{leadmonom (} vector_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
returns the leading monomial of a polynomial or a vector as a polynomial
or vector whose coefficient is one.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),(c,ds);
  poly f=2x2+3y+4z3;
  vector v=[2*x^10,f];
  leadmonom(f);
  leadmonom(v);
  leadmonom(0);
@c example
@end example
@end table

@c ref
See
@ref{lead};
@ref{leadcoef};
@ref{leadexp};
@ref{intvec};
@ref{poly};
@ref{vector}.
@c ref
@c ---------------------------------------
@node LIB, lift, leadmonom, Functions
@subsection LIB
@cindex LIB
@table @code
@item @strong{Syntax:}
@code{LIB} string_expression@code{;}
@item @strong{Type:}
none
@item @strong{Notes:}
This command is obsoleted by
@code{load(}string_expression@code{,"with");}

@item @strong{Syntax:}
@code{LIB;}
@item @strong{Type:}
string
@item @strong{Purpose:}
shows all loaded libraries written in Singular.
@item @strong{Example:}
@example
@c example
  option(loadLib); // show loading of libraried
  LIB;             // standard.lib is loaded

                   // the names of the procedures of inout.lib
  LIB "inout.lib"; // are now known to Singular
  LIB;
@c example
@end example
@end table
@ifset namespaces
@c ref
See
@ref{Command line options};
@ref{Procedures and libraries};
@ref{SINGULAR libraries};
@ref{Namespaces};
@ref{proc};
@ref{standard_lib};
@ref{string};
@ref{load};
@ref{package};
@ref{system}.
@c ref
@end ifset
@ifclear namespaces
@c ref
See
@ref{Command line options};
@ref{Procedures and libraries};
@ref{SINGULAR libraries};
@ref{proc};
@ref{standard_lib};
@ref{string};
@ref{system}.
@c ref
@end ifclear
@c -------------------------------------------------
@node lift, liftstd, LIB, Functions
@subsection lift
@cindex lift
@table @code
@item @strong{Syntax:}
@code{lift (} ideal_expression@code{,} subideal_expression @code{)}
@*@code{lift (} module_expression@code{,} submodule_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the transformation matrix which expresses the generators of a
submodule in terms of the generators of a module.  Uses different
algorithms for modules which are resp.@: are not represented by a
standard basis.
@* Hence, if @code{sm} is the submodule (or ideal), @code{m} the
module (or ideal) and @code{T} the transformation matrix returned by
lift then @code{matrix(sm)=matrix(m)*T}
and @code{sm=module(matrix(m)*T)} (or @code{sm=ideal(matrix(m)*T)}).
Gives a warning if @code{sm} is not a submodule.
@item @strong{Note:}
For local or mixed orderings this holds only up to units in the associated
localized ring.
@item @strong{Example:}
@example
@c example
  ring r;
  ideal m=3x2+yz,7y6+2x2y+5xz;
  poly f=y7+x3+xyz+z2;
  ideal i=jacob(f);
  matrix T=lift(i,m);
  matrix(m)-matrix(i)*T;
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{module}.
@c ref
@c -----------------------------------------
@node liftstd, listvar, lift, Functions
@subsection liftstd
@cindex liftstd
@table @code
@item @strong{Syntax:}
@code{liftstd (} ideal_expression@code{,} matrix_name @code{)}
@*@code{liftstd (} module_expression@code{,} matrix_name @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a standard basis of an ideal or module and the transformation
matrix from the given ideal resp. module to the standard basis.
@*Hence, if @code{m} is the ideal or module, @code{sm} the standard
basis returned by @code{liftstd}, and @code{T} the transformation matrix
then @code{matrix(sm)=matrix(m)*T} and @code{sm=ideal(matrix(m)*T)}
respectively @code{sm=module(matrix(m)*T)}.
@item @strong{Example:}
@example
@c example
  ring R=0,(x,y,z),dp;
  poly f=x3+y7+z2+xyz;
  ideal i=jacob(f);
  matrix T;
  ideal sm=liftstd(i,T);
  sm;
  print(T);
  matrix(sm)-matrix(i)*T;
@c example
@end example
@end table
@menu
* ideal::
* ring::
* option::        Sets certain strategies.
* std::
* matrix::
@end menu
@iftex
See @ref{ideal}; @ref{ring}; @ref{option}; @ref{std}; @ref{matrix}.
@end iftex
@c ---------------------------------------
@node listvar, lres, liftstd, Functions
@subsection listvar
@cindex listvar
@table @code
@item @strong{Syntax:}
@ifset namespaces
@code{listvar(}[package]@code{);}
@*@code{listvar(}[package @code{,}] type @code{);}
@*@code{listvar(}[package @code{,}] ring_name @code{);}
@*@code{listvar(}[package @code{,}] name @code{);}
@*@code{listvar(}[package @code{,}] @code{all );}
@end ifset
@ifclear namespaces
@code{listvar(}[package]@code{);}
@*@code{listvar(}[package @code{,}] type @code{);}
@*@code{listvar(}[package @code{,}] ring_name @code{);}
@*@code{listvar(}[package @code{,}] name @code{);}
@*@code{listvar(}[package @code{,}] @code{all );}
@end ifclear
@item @strong{Type:}
none
@item @strong{Purpose:}
lists all (user-)defined names in the current namespace:
@*@code{listvar()}: all currently visible names except procedures
@*@code{listvar(}type@code{)}: all currently visible names of the given type
@*@code{listvar(}ring_name@code{)}: all names which belong to the given ring
@*@code{listvar(}name@code{)}: the object with the given name
@*@code{listvar(all)}: all names except procedures
@*The current basering is marked with a @code{*}.  The nesting level of
variables in procedures is shown in square brackets.

@ifset namespaces
package can be @code{Current}, @code{Up}, @code{Top} or any other
identifier of type package.
@item @strong{Example:}
@example
@c example error
  proc t1 { }
  proc t2 { }
  ring s;
  poly ss;
  ring r;
  poly f=x+y+z;
  int i=7;
  ideal I=f,x,y;
  listvar(all);
  listvar();
  listvar(r);
  listvar(t1);
  listvar(proc);
  listvar(Standard, proc);
@c example
@end example
@end ifset
@ifclear namespaces
@item @strong{Example:}
@example
@c example
  proc t1 { }
  proc t2 { }
  ring s;
  poly ss;
  ring r;
  poly f=x+y+z;
  int i=7;
  ideal I=f,x,y;
  listvar(all);
  listvar();
  listvar(r);
  listvar(t1);
  listvar(proc);
@c example
@end example
@end ifclear
@end table
@ifset namespaces
@c ref
See
@ref{Names in procedures};
@ref{Names};
@ref{defined};
@ref{names};
@ref{Namespaces};
@ref{package};
@ref{type}.
@c ref
@end ifset
@ifclear namespaces
@c ref
See
@ref{Names in procedures};
@ref{Names};
@ref{defined};
@ref{names};
@ref{type}.
@c ref
@end ifclear
@c ---------------------------------------
@node lres, maxideal, listvar, Functions
@subsection lres
@cindex lres
@table @code
@item @strong{Syntax:}
@code{lres (} ideal_expression@code{,} int_expression @code{)}
@*@code{lres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module with LaScala's
method.

The ideal_expression resp.@: module_expression has to be homogeneous.

More precisely, let M be given by a a generating set and
@tex
$A_1=matrix(M)$.
@end tex
@ifinfo
A1=matrix(M).
@end ifinfo
Then @code{lres}
computes a minimal free resolution of
@ifinfo
M1=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
The computation stops after k steps, if the int expression k
is not zero, and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo

If k=0, @code{lres(M,0)} returns a list of n modules where n is the
number of variables of the basering.

Let @code{list l=lres(M,0);} then L[1] generates M,
L[2] generates
the first syzygy
module of L[1], etc.
( L[i]
@ifinfo
=M_i
@end ifinfo
@tex
$=M_i$
@end tex
 in the notations from above).
@item @strong{Note:}
To access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal i=xz,yz,x^3-y^3;
  def l=lres(i,0);
  print(betti(l),"betti");// input to betti may be of type resolution
  list ll=l;
  l[2];                   // elements can only be accessed in the list
@c example
@end example
@end table
@c ref
See
@ref{betti};
@ref{ideal};
@ref{int};
@ref{minres};
@ref{module};
@ref{mres};
@ref{res};
@ref{sres}.
@c ref
@c ---------------------------------------
@node maxideal, memory, lres, Functions
@subsection maxideal
@cindex maxideal
@table @code
@item @strong{Syntax:}
@code{maxideal (} int_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the power given by int_expression of the maximal ideal
generated by all variables (maxideal(i)=(1) for i<=0).
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  maxideal(2);
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{ring}.
@c ref
@c ---------------------------------------
@node  memory, minbase, maxideal, Functions
@subsection memory
@cindex memory
@table @code
@item @strong{Syntax:}
@code{memory (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns statistics concerning the memory management:
@*@code{memory(0)} is the number of active (used) bytes
@*@code{memory(1)} is the number of allocated bytes
@item @strong{Note:}
To monitor the memory usage during ongoing computations the option
@code{mem} should be set (using the command @code{option(mem);}, see
also @ref{option}).
@item @strong{Example:}
@example
@c example
  "Objects of SINGULAR use (at the moment) ",memory(0)," bytes,"
   +newline+
  "allocated from system (at the moment):", memory(1), "bytes";
@c example
@end example
@end table
@c ref
See
@ref{option}.
@c ref
@c ---------------------------------------
@node minbase, minor, memory, Functions
@subsection minbase
@cindex minbase
@table @code
@item @strong{Syntax:}
@code{minbase (} ideal_expression @code{)}
@*@code{minbase (} module_expression @code{)}
@item @strong{Type:}
the same as the type of the argument
@item @strong{Purpose:}
returns a minimal set of generators of an ideal resp. module if the input is
either homogeneous or if the ordering is local.
@item @strong{Example:}
@example
@c example
  ring r=181,(x,y,z),(c,ls);
  ideal id2=x2+xyz,y2-z3y,z3+y5xz;
  ideal id4=maxideal(3)+id2;
  size(id4);
  minbase(id4);
@c example
@end example
@end table
@c ref
See
@ref{mstd}.
@c ref
@c ---------------------------------------
@node minor, minres, minbase, Functions
@subsection minor
@cindex minor
@table @code
@item @strong{Syntax:}
@code{minor (} matrix_expression@code{,} int_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the set of all minors (=subdeterminants) of the given size of a matrix.
@item @strong{Example:}
@example
@c example
  ring r = 0, (x(1..5)), ds;
  matrix m[2][4]= x(1..4), x(2..5);
  print(m);
  ideal j = minor(m, 2);
  j;
@c example
@end example
@end table
@c ref
See
@ref{det}.
@c ref
@c ---------------------------------------
@node  minres, modulo, minor, Functions
@subsection minres
@cindex minres
@table @code
@item @strong{Syntax:}
@code{minres (} list @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{minres (} resolution @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
minimizes a free resolution of an ideal or module
given by the list resp. resolution argument.
@item @strong{Example:}
@example
@c example
  ring r1=32003,(x,y),dp;
  ideal i=x5+xy4,x3+x2y+xy2+y3;
  resolution rs=lres(i,0);
  rs;
  list(rs);
  minres(rs);
  list(rs);
@c example
@end example
@end table
@c ref
See
@ref{res};
@ref{mres};
@ref{sres}.
@c ref
@c --------------------------------------
@node modulo, monitor, minres, Functions
@subsection modulo
@cindex modulo
@table @code
@item @strong{Syntax:}
@code{modulo (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{modulo (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
@code{modulo(h1,h2)}
@ifinfo
represents h1/(h1 intersect h2) (isomorphic to (h1+h2)/h2)
@end ifinfo
@tex
represents $h_1/(h_1 \cap h_2) \cong (h_1+h_2)/h_2)$
@end tex
where
@tex
$h_1$ and $h_2$
@end tex
@ifinfo
h1 and h2
@end ifinfo
are considered as submodules of the same free module
@tex
$R^l$
@end tex
@ifinfo
R^l
@end ifinfo
(l=1 for ideals). Let
@tex
$H_1$ resp. $H_2$
@end tex
@ifinfo
H1 and H2
@end ifinfo
be the matrices of size l x k resp. l x m having the columns of
@tex
$h_1$ resp. $h_2$
@end tex
@ifinfo
h1 resp. h2
@end ifinfo
as generators:
@*
@tex
$R^k \buildrel{H_1}\over{\rightarrow} R^l
\buildrel{H_2}\over{\leftarrow} R^m$
@end tex
@ifinfo
@example
     H1         H2
R^k ----> R^l <---- R^m
@end example
@end ifinfo
Then
@tex
$h_1/(h_1 \cap h_2) \cong R^k / ker(\overline{H_1})$
@end tex
@ifinfo
@example
                                              __
h1/(h1 intersect h2) is isomorphic to R^k/ker(H1)
@end example
@end ifinfo
where
@tex
$\overline{H_1}: R^k \rightarrow R^l/Im(H_2)=R^l/h_2$
@end tex
@ifinfo
__
H1:R^k ----> R^l/Im(H2)=R^l/h2
@end ifinfo
is the induced map.
@*@code{modulo(h1,h2)} returns generators of
the kernel of this induced map.
@item @strong{Example:}
@example
@c example
  ring r;
  ideal h1 = x,y,z;
  ideal h2 = x;
  module m=modulo(h1,h2);
  print(m);
@c example
@end example
@end table
@c ref
See
@ref{syz}.
@c ref
@c ---------------------------------------
@node monitor, mres, modulo, Functions
@subsection monitor
@cindex monitor
@table @code
@item @strong{Syntax:}
@code{monitor (} string_expression @code{)}
@*@code{monitor (} string_expression@code{,} string_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
controls recording all user input and/or program output into a file.
The second argument describes what to log: @code{"i"} means input,
@code{"o"} means output, @code{"io"} for both.
@*The default for the second argument is @code{"i"}.
@*Each @code{monitor} command closes a previous monitor file
and opens the file given by the first string expression.
@*@code{monitor ("")} turns off recording.
@item @strong{Example:}
@example
@c example
  monitor("doe.tmp","io"); // log input and output to doe.tmp
  ring r;
  poly f=x+y+z;
  int i=7;
  ideal I=f,x,y;
  monitor("");             // stop logging
@c example
@end example
@end table
@c ---------------------------------------
@node  mres, mstd, monitor, Functions
@subsection mres
@cindex mres
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression @code{)}
@*@code{mres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the
standard basis method. More precisely, let A=matrix(M), then @code{mres}
computes a free resolution of
@ifinfo
M1=coker(A)=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A)=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
@*where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are a minimal set of generators
of M if the basering is local or if M is homogeneous.
The computation stops after k steps, if the int expression k
is not zero, and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*If k=0 then @code{mres(M,0)}
returns a resolution consisting of not more than n modules
where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then L[1] consists of a minimal set of generators of the input, L[2]
consists of a minimal set of generators of the first syzygy module of
L[1], etc., until L[p+1], such that L[i]
@ifinfo
!=0 for i<=p
@end ifinfo
@tex
$\ne 0$ for i$\le$p
@end tex
 but L[p+1], the
first syzygy module of L[p], is 0 (if the basering is not a qring).
@item @strong{Note:}
To access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time.
@item @strong{Example:}
@example
@c example
  ring r  = 31991,(t,x,y,z,w),ls;
  ideal M = t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
            t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  resolution L = mres(M,0);
  L;
  // projective dimension of M is 5
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{lres};
@ref{module};
@ref{res};
@ref{sres}.
@c ref
@c ---------------------------------------
@node  mstd, mult, mres, Functions
@subsection mstd
@cindex mstd
@table @code
@item @strong{Syntax:}
@code{mstd (} ideal_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
returns a list whose first entry is a standard basis and whose second
entry is a set of generators of size smaller or equal to the input set,
which is a minimal subset of the standard basis for homogenous
input  (w.r.t. any monomial ordering).
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z,t),dp;
  poly f=x3+y4+z6+xyz;
  ideal j=jacob(f),f;
  j=homog(j,t);j;
  mstd(j);
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{std};
@ref{minbase}.
@c ref
@c ---------------------------------------
@node mult, nameof, mstd, Functions
@subsection mult
@cindex mult
@table @code
@item @strong{Syntax:}
@code{mult (} ideal_expression @code{)}
@*@code{mult (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the degree of the monomial ideal resp. module generated by
the leading monomials of the input.
@*If the input is a standard basis of a homogeneous ideal
then it returns the degree of this ideal.
@*If the input is a standard basis of an ideal in a (local)
ring with respect to a local degree ordering
then it returns the multiplicity of the ideal (in the sense of Samuel,
with respect to the maximal ideal).
@item @strong{Example:}
@example
@c example
  ring r= 32003,(x,y),ds;
  poly f = (x^3+y^5)^2+x^2*y^7;
  ideal i = std(jacob(f));
  mult(i);
  mult(std(f));
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{std};
@ref{degree};
@ref{vdim};
@ref{dim}.
@c ref
@c ---------------------------------------
@node nameof, names, mult, Functions
@subsection nameof
@cindex nameof
@table @code
@item @strong{Syntax:}
@code{nameof (} expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the name of an expression as string.
@item @strong{Example:}
@example
@c example error
  int i = 9;
  string s = nameof(i);
  s;
  nameof(s);
  nameof(i+1); //returns the empty string:
  nameof(basering);
  basering;
  ring r;
  nameof(basering);
@c example
@end example
@end table
@c ref
See
@ref{typeof};
@ref{names};
@ref{reservedName}.
@c ref
@c ---------------------------------------
@node names, ncols, nameof, Functions
@subsection names
@cindex names
@table @code
@item @strong{Syntax:}
@code{names ( )}
@*@code{names (} ring_name @code{)}
@ifset namespaces
@*@code{names (} package_name @code{)}
@end ifset
@item @strong{Type:}
list of strings
@item @strong{Purpose:}
returns the names of all user defined variables which are ring independent
(this includes the names of  procedures) or, in the second case, belong to
the given ring.

@ifset namespaces
package_name can be @code{Current}, @code{Up}, @code{Top} or any other
identifier of type package.
@item @strong{Example:}
@example
@c example error
  int i = 9;
  ring r;
  poly f;
  package p;
  int p::j;
  ring p::q;
  poly g;
  setring r;
  names();
  names(r);
  names(p);
  names(p::q);
@c example
@end example
@end ifset
@ifclear namespaces
@item @strong{Example:}
@example
@c example
  int i = 9;
  ring r;
  poly f;
  poly g;
  setring r;
  names();
  names(r);
@c example
@end example
@end ifclear
@end table
@c ref
See
@ref{nameof};
@ref{reservedName}.
@c ref
@c ---------------------------------------
@node ncols, npars, names, Functions
@subsection ncols
@cindex ncols
@table @code
@item @strong{Syntax:}
@code{ncols (} matrix_expression @code{)}
@*@code{ncols (} intmat_expression @code{)}
@*@code{ncols (} ideal_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of columns of a matrix or an intmat @*or the number of
given generators of the ideal, including zeros.
@*Note that @code{size(}ideal@code{)} counts the number of generators
which are different from zero. (Use @code{nrows} to get the number of rows of a given
matrix or intmat.)
@item @strong{Example:}
@example
@c example
  ring r;
  matrix m[5][6];
  ncols(m);
  ideal i=x,0,y;
  ncols(i);
  size(i);
@c example
@end example
@end table
@c ref
See
@ref{matrix};
@ref{nrows};
@ref{size}.
@c ref
@c ---------------------------------------
@node npars, nres, ncols, Functions
@subsection npars
@cindex npars
@table @code
@item @strong{Syntax:}
@code{npars (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of parameters of a ring.
@item @strong{Example:}
@example
@c example
  ring r=(23,t,v),(x,a(1..7)),lp;
  // the parameters are t,v
  npars(r);
@c example
@end example
@end table
@c ref
See
@ref{par};
@ref{parstr};
@ref{ring}.
@c ref
@c ---------------------------------------
@node  nres, nrows, npars, Functions
@subsection nres
@cindex nres
@table @code
@item @strong{Syntax:}
@code{nres (} ideal_expression@code{,} int_expression @code{)}
@*@code{nres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the standard basis method.
More precisely, let
@tex
$A_1$=matrix(M),
@end tex
@ifinfo
A1=matrix(M),
@end ifinfo
then @code{nres}
computes a free resolution of
@ifinfo
M1=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
@*where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are the given set of generators of M.
The computation stops after k steps, if the int expression k
is not zero, and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*If k=0, @code{nres(M,0)}
returns a list of n modules where n is the number of variables of the basering.
Let @code{list l=nres(M,0);}
then L[1]=M is identical to the input, L[2] is a minimal set of generators
of the first syzygy
module of L[1], etc.
( L[i]
@ifinfo
=M_i
@end ifinfo
@tex
$=M_i$
@end tex
 in the notations from above).
@item @strong{Example:}
@example
@c example
  ring r  = 31991,(t,x,y,z,w),ls;
  ideal M = t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
            t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  resolution L = nres(M,0);
  L;
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{lres};
@ref{module};
@ref{mres};
@ref{res};
@ref{sres}.
@c ref
@c ---------------------------------------
@node nrows, nvars, nres, Functions
@subsection nrows
@cindex nrows
@table @code
@item @strong{Syntax:}
@code{nrows (} matrix_expression @code{)}
@*@code{nrows (} intmat_expression @code{)}
@*@code{nrows (} intvec_expression @code{)}
@*@code{nrows (} module_expression @code{)}
@*@code{nrows (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of rows of a matrix, an intmat or an intvec, resp.@*
the minimal rank of a free module in which the given module or
vector lives (the index of the last non-zero component). (Use @code{ncols}
to get the number of columns of a given matrix or intmat.)
@item @strong{Example:}
@example
@c example
  ring R;
  matrix M[2][3];
  nrows(M);
  nrows(freemodule(4));
  module m=[0,0,1];
  nrows(m);
  nrows([0,x,0]);
@c example
@end example
@end table
@c ref
See
@ref{gen};
@ref{matrix};
@ref{module};
@ref{vector};
@ref{ncols}.
@c ref
@c ---------------------------------------
@node nvars, open, nrows, Functions
@subsection nvars
@cindex nvars
@table @code
@item @strong{Syntax:}
@code{nvars (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of variables of a ring.
@item @strong{Example:}
@example
@c example
  ring r=23,(x,a(1..7)),ls;
  nvars(r);
@c example
@end example
@end table
@c ref
See
@ref{ring};
@ref{var}.
@c ref
@c ---------------------------------------
@node open, option, nvars, Functions
@subsection open
@cindex open
@table @code
@item @strong{Syntax:}
@code{open (} link_expression @code{);}
@item @strong{Type:}
none
@item @strong{Purpose:}
opens a link.
@item @strong{Example:}
@example
link l="MPtcp:launch";
open(l); // start SINGULAR "server" on localhost in batchmode
close(l); // shut down SINGULAR server
@end example
@end table
@c ref
See
@ref{link};
@ref{close}.
@c ref
@c ---------------------------------------
@node option, ord, open, Functions
@subsection option
@cindex option
@table @code
@item @strong{Syntax:}
@code{option ();}
@item @strong{Type:}
string
@item @strong{Purpose:}
lists all defined options.
@*
@item @strong{Syntax:}
@code{option (} option_name @code{);}
@item @strong{Type:}
none
@item @strong{Purpose:}
sets an option.
@item @strong{Note:}
To disable an option, use the prefix @code{no}.
@*
@item @strong{Syntax:}
@code{option ( get );}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
dumps the state of all options to an intvec.
@*
@item @strong{Syntax:}
@code{option ( set,} intvec_expression @code{);}
@item @strong{Type:}
none
@item @strong{Purpose:}
restores the state of all options from an intvec (produced by @code{option(get)}).
@sp 1
@item @strong{Values:}
The following options are used to manipulate the behavior of
computations:
@table @asis
@item @code{none}
resets all options to the default
@item @code{returnSB}
the functions @code{syz},@code{intersect},@code{quotient},@code{modulo} return a standard base instead
of a generating set if @code{returnSB} is set. This option should not be used for @code{lift}.
@item @code{fastHC}
tries to find HC (highest corner of the staircase) as fast as possible
during a standard basis computation (only used for local orderings)
@c @item @code{interrupt}
@c allows fast interruption of standard basis computation
@item @code{intStrategy}
avoids divisions of coefficients during standard basis computations
@item @code{minRes}
special (additional) minimizing during computations (res,mres),
@*assumes homogeneous case and degree-compatible ordering
@item @code{morePairs}
creates additional (useless) pairs to speed up computation in some cases
@item @code{notRegularity}
disables the regularity bound for res/mres (see @ref{regularity})
@item @code{notSugar}
disables the sugar strategy
@item @code{prot}
shows protocol information indicating the
progress during the following computations:
@code{facstd},
@code{fglm},
@code{groebner},
@code{lres},
@code{mres},
@code{minres},
@code{mstd},
@code{res},
@code{sres},
@code{std},
@code{stdfglm},
@code{stdhilb},
@code{syz}.
See below for more details.
@item @code{redSB}
computes a reduced standard basis in any standard basis computation
@item @code{redTail}
reduction of the tails of polynomials during standard basis computations
@item @code{sugarCrit}
uses criteria similar to the homogeneous case to keep more useless pairs
@item @code{weightM}
automatically computes suitable weights for the weighted ecart and the
weighted sugar method
@end table
@*
There are further options that control the behavior of the computations,
but these options are not manipulated using the @code{option} command:
@table @asis
@item @code{multBound}
a multiplicity bound is set (see @ref{multBound})
@item @code{degBound}
a degree bound is set (see @ref{degBound})
@end table
@*
The last set of options controls the output of @sc{Singular}:
@table @asis
@item @code{Imap}
shows the mapping of variables with the imap command
@item @code{loadLib}
shows loading of libraries (default)
@item @code{debugLib}
warns about syntax errors during loading of libraries
@item @code{loadProc}
shows loading of procedures from libraries
@item @code{mem}
shows memory usage in square brackets (see @ref{memory})
@item @code{prompt}
shows prompt (@code{>} resp. @code{.}) if ready for input (default)
@item @code{reading}
shows the number of characters read from a file
@item @code{redefine}
warns about variable redefinitions (default)
@item @code{usage}
shows correct usage in error messages (default)
@end table
@item @strong{Example:}
@example
@c example
  option(prot);
  option();
  option(notSugar);
  option();
  option(noprot);
  option();
  option(none);
  option();
  ring r=0,x,dp;
  degBound=22;
  option();
  intvec i=option(get);
  option(none);
  option(set,i);
  option();
@c example
@end example
@end table

@*The output reported on @code{option(prot)} has the following meaning:
@multitable @columnfractions .01 .14 .11 .65

@item @tab @code{facstd}
@tab @code{F} @tab found a new factor
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{fglm}
@tab @code{.} @tab basis monomial found
@item @tab @tab @code{+} @tab edge monomial found
@item @tab @tab @code{-} @tab border monomial found
@item @tab @tab @tab
@item @tab @code{groebner} @tab @tab all characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{lres}
@tab @code{.} @tab minimal syzygy found
@item @tab @tab @math{n} @tab slanted degree, i.e., row of Betti matrix
@item @tab @tab @code{(m}@math{n}@code{)} @tab calculate in module @math{n}
@item @tab @tab @code{g} @tab pair found giving reductum and syzygy
@item @tab @tab @tab
@item @tab @code{mres}
@tab @code{[}@math{d}@code{]}
@tab computations of the @math{d}-th syzygy module
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{minres}
@tab @code{[}@math{d}@code{]}
@tab minimizing of the @math{d}-th syzygy module
@item @tab @tab @tab
@item @tab @code{mstd} @tab @tab all characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{res}
@tab @code{[}@math{d}@code{]}
@tab computations of the @math{d}-th syzygy module
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{sres}
@tab @code{.} @tab syzygy found
@item @tab @tab @code{(}@math{n}@code{)} @tab @math{n} elements remaining
@item @tab @tab @code{[}@math{n}@code{]} @tab finished module @math{n}
@item @tab @tab @tab
@item @tab @code{std}
@tab @code{s} @tab found a new element of the standard basis
@item @tab @tab @code{-} @tab reduced a pair/S-polynomial to 0
@item @tab @tab @code{.} @tab postponed a reduction of a pair/S-polynomial
@item @tab @tab @code{h} @tab used Hilbert series criterion
@item @tab @tab @code{H(}@math{d}@code{)} @tab found a 'highest corner' of degree @math{d}, no need to consider higher degrees
@item @tab @tab @code{(}@math{n}@code{)} @tab @math{n} critical pairs are still to be reduced
@item @tab @tab @code{(S:}@math{n}@code{)} @tab doing complete reduction of @math{n} elements
@item @tab @tab @math{d} @tab the degree of the leading terms is currently @math{d}
@item @tab @tab @tab
@item @tab @code{stdfglm} @tab @tab all characters in first part: like the output of @code{std}
@item @tab @tab @tab all characters in second part: like the output of @code{fglm}
@item @tab @tab @tab
@item @tab @code{stdhilb} @tab @tab all characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{syz} @tab @tab all characters: like the output of @code{std}
@end multitable


@c ref
See
@ref{degBound};
@ref{multBound};
@ref{std}.
@c ref
@c ---------------------------------------
@node ord, ordstr, option, Functions
@subsection ord
@cindex ord
@table @code
@item @strong{Syntax:}
@code{ord (} poly_expression @code{)}
@*@code{ord (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the (weighted) degree of
the initial term of a polynomial or a vector;
the weights are the weights used for the first block of the ring ordering.
@*@code{ord(0)} is @code{-1}.
@item @strong{Example:}
@example
@c example
  ring r=7,(x,y),wp(2,3);
  ord(0);
  poly f=x2+y3;
  ord(f);
  ring R=7,(x,y),ws(2,3);
  poly f=x2+y3;
  ord(f);
  vector v=[x2,y];
  ord(v);
@c example
@end example
@end table
@menu
* deg::
* poly::
* vector::
@end menu
@iftex
See @ref{deg}; @ref{poly}; @ref{vector}.
@end iftex
@c ---------------------------------------
@node ordstr, par, ord, Functions
@subsection ordstr
@cindex ordstr
@table @code
@item @strong{Syntax:}
@code{ordstr (} ring_name @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the description of the monomial ordering of the ring.
@item @strong{Example:}
@example
@c example
  ring r=7,(x,y),wp(2,3);
  ordstr(r);
@c example
@end example
@end table
@menu
* ring::
* varstr::
* parstr::
* charstr::
@end menu
@iftex
See @ref{ring}; @ref{varstr}; @ref{parstr}; @ref{charstr}.
@end iftex

@c ---------------------------------------
@node par, pardeg, ordstr, Functions
@subsection par
@cindex par
@table @code
@item @strong{Syntax:}
@code{par (} int_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
returns the n-th parameter of the basering. This command should only be used if the basering
has at least one parameter.
@item @strong{Example:}
@example
@c example
  ring r=(0,a,b,c),(x,y,z),dp;
  par(2);
@c example
@end example
@end table
@menu
* npars::
* parstr::
* ring::
* var::
@end menu
@iftex
See @ref{npars}; @ref{parstr}; @ref{ring}; @ref{var}.
@end iftex
@c ---------------------------------------
@node pardeg, parstr, par, Functions
@subsection pardeg
@cindex pardeg
@table @code
@item @strong{Syntax:}
@code{pardeg(} number_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the degree of a number considered as a polynomial in the ring parameters.
@item @strong{Example:}
@example
@c example
  ring r=(0,a,b,c),(x,y,z),dp;
  pardeg(a^2*b);
@c example
@end example
@end table
@menu
* number::
* ring::
* var::
@end menu
@iftex
See @ref{number}; @ref{ring}; @ref{var}.
@end iftex
@c ---------------------------------------
@node parstr, pause, pardeg, Functions
@subsection parstr
@cindex parstr
@table @code
@item @strong{Syntax:}
@code{parstr (} ring_name @code{)}
@*@code{parstr (} int_expression @code{)}
@*@code{parstr (} ring_name@code{,} int_expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the list of parameters of the ring as a string
@*or the name of the n-th parameter for an integer n.
@*@code{parstr(n)} is equivalent to @code{parstr(basering,n)}.
@item @strong{Example:}
@example
@c example
  ring r=(7,a,b,c),(x,y),wp(2,3);
  parstr(r);
  parstr(2);
  parstr(r,3);
@c example
@end example
@end table
@menu
* charstr::
* npars::
* ordstr::
* par::
* ring::
* varstr::
@end menu
@iftex
See @ref{charstr}; @ref{npars}; @ref{ordstr}; @ref{par}
@ref{ring};
@ref{varstr}.
@end iftex
@c ---------------------------------------
@node pause, preimage, parstr, Functions
@subsection pause
@cindex pause
@c lib standard.lib:pause lib_fun lib_ex
@c @table @code
@c @item @strong{Syntax:}
@c @code{pause;}
@c @item @strong{Type:}
@c none
@c @item @strong{Purpose:}
@c pauses the execution of a procedure until the return key is pressed.
@c @item @strong{Example:}
@c @example
@c // the procedure will continue if return is pressed:
@c "press the return key to continue"; pause;
@c @expansion{} press the return key to continue
@c @expansion{} pause>
@c 
@c @end example
@c @end table
@c ---------------------------------------
@node preimage, prime, pause, Functions
@subsection preimage
@cindex preimage
@cindex kernel

@table @code
@item @strong{Syntax:}
@code{preimage (} ring_name@code{,} map_name@code{,} ideal_name @code{)}
@*@code{preimage (} ring_name@code{,} ideal_expression@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the preimage of an ideal under a given map.
@*
The second argument has to be a map from the basering to the given ring
(or an ideal defining such a map),
and the ideal has to be an ideal in the given ring.
@item @strong{Note:}
To compute the kernel of a map, the preimage of zero has to be determined. Hence there is no
special command for computing the kernel of a map in @sc{Singular}.
@item @strong{Example:}
@example
@c example
  ring r1=32003,(x,y,z,w),lp;
  ring r=32003,(x,y,z),dp;
  ideal i=x,y,z;
  ideal i1=x,y;
  ideal i0=0;
  map f=r1,i;
  setring r1;
  ideal i1=preimage(r,f,i1);
  i1;
  // the kernel of f
  preimage(r,f,i0);
@c example
@end example
@end table
@menu
* map::
* ring::
@end menu
@iftex
See @ref{map}; @ref{ring}.
@end iftex
@c ---------------------------------------
@node prime, print, preimage, Functions
@subsection prime
@cindex prime
@table @code
@item @strong{Syntax:}
@code{prime (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the largest prime less then 32004 smaller or equal to the argument;
@*returns 2 for all arguments smaller than 3.
@item @strong{Example:}
@example
@c example
  prime(32004);
  prime(0);
  prime(-1);
@c example
@end example
@end table
@menu
* int::
* general_lib::
@end menu
@iftex
See @ref{int}; @ref{general_lib}.
@end iftex
@c ---------------------------------------
@node print, printf, prime, Functions
@subsection print
@cindex print
@table @code
@item @strong{Syntax:}
@code{print (} expression @code{);}
@*@code{print (} expression@code{, "betti" );}
@*@code{print (} expression@code{,} format_string @code{);}
@item @strong{Type:}
none (for the first two calling sequences)
@*string (for the last calling sequence)
@item @strong{Purpose:}
prints expressions in a nice format, especially useful for matrices, modules
and vectors.
@*The second form uses a string to determine the format.
@*The following format strings are supported:
@table @code
@item "betti"
displays the graded Betti numbers of
@tex
$R^n/M$, if $R$ denotes the basering and if $M$ is a homogeneous submodule of $R^n$:
@end tex
@ifinfo
R^n/M, if R denotes the basering and if M is a homogeneous submodule of R^n:
@end ifinfo
@*The entry d at (i,j) is the minimal number of generators in degree i+j of
the j-th syzygy module of
@tex
$R^n/M$ (the 0-th (resp.1-st) syzygy module of $R^n/M$ is $R^n$ (resp. $M$))
@end tex
@ifinfo
R^n/M (the 0-th (resp.1-st) syzygy module of R^n/M is R^n (resp. M))
@end ifinfo
@item "%s"
returns @code{string(} expression @code{)}
@item "%2s"
similar to @code{"%s"}, except that newlines are inserted after every
comma and at the end
@item "%l"
similar to @code{"%s"}, except that embracing explicite type casts are
inserted as much as possible (this is mostly useful for "cutting and
pasting")
@item "%2l"
similar to @code{"%l"}, except that newlines are inserted after every
comma and at the end
@item "%;"
returns the string equivalent to typing @code{expression;}
@item "%t"
returns the string equivalent to typing @code{type expression;}
@item "%p"
returns the string equivalent to typing @code{print(expressions);}
@item "%b"
returns the string equivalent to typing @code{print(expressions, "betti");}
@end table
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  module m=[1,y],[0,x+z];
  m;
  print(m);  // the columns generate m
  intmat M=betti(mres(m,0));
  print(M,"betti");
  string s = print(m, "%;"); s;
  s = print(m, "%p"); s;
  s = print(M, "%b"); s;
  s = print(M, "%t"); s;
  list l = r, m, M;
  s = print(l, "%s"); s;
  s = print(l, "%2s"); s;
  s = print(l, "%l"); s;
  s = print("", "%2s"); size(s); s; // a simple newline
@c example
@end example
@end table
@c ref
See
@ref{dbprint}
@ref{short}
@ref{type}
@ref{betti}
@ref{string type cast}
@ref{Type conversion and casting}.
@c ref

@c ---------------------------------------
@node printf, prune, print, Functions
@subsection printf
@cindex printf
@c lib standard.lib:printf lib_fun lib_ex

@c ---------------------------------------
@node prune, qhweight, printf, Functions
@subsection prune
@cindex prune
@table @code
@item @strong{Syntax:}
@code{prune (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
returns the module minimally embedded in a free module such that the
corresponding factor modules are isomorphic.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  module m=gen(1),gen(3),[x,y,0,z],[x+y,0,0,0,1];
  print(m);
  print(prune(m));
@c example
@end example
@end table
@menu
* module::
@end menu
@iftex
See @ref{module}.
@end iftex
@c ---------------------------------------
@node qhweight, quot, prune, Functions
@subsection qhweight
@cindex qhweight
@table @code
@item @strong{Syntax:}
@code{qhweight (} ideal_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
computes the weight vector of the variables for a quasihomogeneous ideal.
If the input is not weighted homogeneous, an intvec of zeros is returned.
@item @strong{Example:}
@example
@c example
  ring h1=32003,(t,x,y,z),dp;
  ideal i=x4+y3+z2;
  qhweight(i);
@c example
@end example
@end table
@menu
* ideal::
* intvec::
* weight::
@end menu
@iftex
See @ref{ideal}; @ref{intvec}; @ref{weight}.
@end iftex

@c ---------------------------------------
@node quot, quote, qhweight, Functions
@subsection quot
@cindex quot
@c lib standard.lib:quot lib_fun lib_ex


@c ---------------------------------------
@node quote, quotient, quot, Functions
@subsection quote
@cindex quote
@table @code
@item @strong{Syntax:}
@code{quote (} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
prevents expressions from evaluation. Used only in connections with write in
MPfile links, prevents evaluation of an expression before sending to an other
@sc{Singular}process.
Within a quoted expression, the
quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
effect of exactly one @code{quote}).
@item @strong{Example:}
@example
@c example
  link l="MPfile:w example.mp";
  ring r=0,(x,y,z),ds;
  ideal i=maxideal(3);
  ideal j=x7,x2,z;
  option(prot);
  // compute i+j before writing, but not std
  write (l, quote(std(eval(i+j))));
  close(l);
  // now read it in again and evaluate:
  read(l);
  close(l);
@c example
@end example
@end table
@menu
* eval::
* write::
* MPfile links::
@end menu
@iftex
See @ref{eval}; @ref{write}; @ref{MPfile links}.
@end iftex
@c ---------------------------------------
@node quotient, random, quote, Functions
@subsection quotient
@cindex quotient
@table @code
@item @strong{Syntax:}
@code{quotient (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quotient (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Syntax:}
@code{quotient (} module_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the ideal quotient resp. module quotient.
@*@code{quotient(i,j)}=
@ifinfo
@{a in basering | a j in  i @}
@end ifinfo
@tex
$\{a \in {\rm basering } \mid a \cdot j \subset i\}$
@end tex
in the first case and
@*@code{quotient(m,j)}=
@ifinfo
@{b in basering | b j in m @}, where m in basering^n,
@end ifinfo
@tex
$\{b \in {\rm basering}^n \mid b j \subset m\}$,
where $m\subset {\rm basering}^n$,
@end tex
in the second case.
@item @strong{Example:}
@example
@c example
ring r=181,(x,y,z),(c,ls);
ideal id1=maxideal(3);
ideal id2=x2+xyz,y2-z3y,z3+y5xz;
ideal id6=quotient(id1,id2);
id6;
quotient(id2,id1);
module m=x*freemodule(3),y*freemodule(2);
ideal id3=x,y;
quotient(m,id3);
@c example
@end example
@end table
@menu
* ideal::
* module::
@end menu
@iftex
See @ref{ideal};
@ref{module}.
@end iftex
@c ---------------------------------------
@node random, read, quotient, Functions
@subsection random
@cindex random
@table @code
@item @strong{Syntax:}
@code{random (} min_integer@code{,} max_integer @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns random integer between min_integer and max_integer.
@*
@item @strong{Syntax:}
@code{random (} max_integer@code{,} rows@code{,} cols @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
returns a random intmat of size rows x cols with entries between
-max_integer and +max_integer (inclusively).
@item @strong{Note:} The random generator can be set to a startvalue with
the function @code{system} by a commandline option.
@item @strong{Example:}
@example
@c example
  random(1,1000);
  random(1,2,3);
  // start the random generator with 210
  system("random",210);
  random(-1000,1000);
  random(-1000,1000);
  system("random",210);
  random(-1000,1000);    // the same random values again
@c example
@end example
@end table
@menu
* Command line options::
* int::
* intmat::
* system::
@end menu
@iftex
See @ref{Command line options}; @ref{int}; @ref{intmat}; @ref{system}.
@end iftex
@c ---------------------------------------
@node read, reduce, random, Functions
@subsection read
@cindex read
@table @code
@item @strong{Syntax:}
@code{read (} link_expression @code{)}
@*for DBM links:
@*@code{read (} link_expression @code{)}
@*@code{read (} link_expression@code{,} string_expression @code{)}
@item @strong{Type:}
any
@item @strong{Purpose:}
reads data from a link.
@*For ASCII links, the content of the entire
file is returned as one string. If the ASCII link is the empty string,
@code{read} reads from standard input the keyboard.
@*For MP links, one expression is read
from the link, and returned after an evaluation.
As long as there is no data to read from an MPtcp
link the @code{read} command blocks (i.e., does not return).
The @code{status} command can be used to check whether or not
there is data to read.
@*For DBM links, a
@code{read} with one argument returns the value of the next entry in the
data base, and a @code{read} with two arguments returns the value to the
key given as the second argument from the data base.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  ideal i=x+y,z3+22y;
  // write the ideal i to the file save_i
  write(":w save_i",i);
  ring r0=0,(x,y,z),Dp;
  // create an ideal k equal to the content
  // of the file save_i
  string s="ideal k="+read("save_i")+";";
  execute s;
  k;
@c example
@end example
@end table
@menu
* execute::
* getdump::
* link::
* status::
* write::
@end menu
@iftex
See @ref{execute}; @ref{getdump}; @ref{link}; @ref{status}; @ref{write}.
@end iftex
@c ---------------------------------------
@node reduce, regularity, read, Functions
@subsection reduce
@cindex reduce
@cindex NF
@table @code
@item @strong{Syntax:}
@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, ideal  or module
to its normal form with respect to an ideal or module represented
by a standard basis.
Return 0 if and only if the polynomial (resp. vector, ideal, module)
is an element (resp. subideal, submodule) of the ideal (resp. module).
The result may have no meaning if the second argument is not a standard basis.
@*The third (optional) argument 1 forces a reduction which considers
only the leading term and does no tail reduction.
@item @strong{Note:}
@code{NF} may be used instead of @code{reduce}.
@item @strong{Example:}
@example
@c example
  ring r1 = 0,(z,y,x),ds;
  poly s1=2x5y+7x2y4+3x2yz3;
  poly s2=1x2y2z2+3z8;
  poly s3=4xy5+2x2y2z3+11x10;
  ideal i=s1,s2,s3;
  ideal j=std(i);
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j);
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j,1);
@c example
@end example
@end table
@menu
* ideal::
* vector::
* std::
@end menu
@iftex
See @ref{ideal}; @ref{vector}; @ref{std}.
@end iftex
@c ---------------------------------------
@node regularity, res, reduce, Functions
@subsection regularity
@cindex regularity
@table @code
@item @strong{Syntax:}
@code{regularity (} list_expression @code{)}
@code{regularity (} resolution_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the regularity of a homogeneous ideal resp. module from a
minimal resolution given by the list expression.
@*
@ifinfo
Let (+) K[X]e(a,n) -> @dots{} -> (+) K[X]e(a,0) -> I -> 0
@* be a minimal resolution with homogeneous maps of degree 0.
The regularity is the smallest number s with the property deg( e(a,i)) <= s+i
for all i.
@end ifinfo
@tex
\noindent
Let $0 \rightarrow\ \bigoplus_a K[x]e_{a,n}\ \rightarrow\ \dots
  \rightarrow\ \bigoplus_a K[x]e_{a,0}\ \rightarrow\
  I\ \rightarrow\ 0$
be a minimal resolution of I considered with homogeneous maps of degree 0.
The regularity is the smallest number $s$ with the property deg($e_{a,i})
 \leq s+i$ for all $i$.
@end tex
@*If the input to the commands @code{res} and @code{mres} is homogeneous
the regularity is computed and used as a degree bound during
the computation unless @code{option(notRegularity);} is given.
@item @strong{Example:}
@example
@c example
  ring rh3=32003,(w,x,y,z),(dp,C);
  poly f= x11+y10+z9+x5*y2+x2*y2*z3+x*y^3*(y2+x)^2;
  ideal j= homog(jacob(f),w);
  def jr=res(j,0);
  regularity(jr);
  list jj=jr;
  regularity(jj);
@c example
@end example
@end table
@menu
* res::
* mres::
* sres::
* minres::
* option::
@end menu
@iftex
See @ref{res}; @ref{mres}; @ref{sres}; @ref{minres}; @ref{option}.
@end iftex
@c ---------------------------------------
@node  res, reservedName, regularity, Functions
@subsection res
@cindex res
@table @code
@item @strong{Syntax:}
@code{res (} ideal_expression@code{,} int_expression @code{)}
@*@code{res (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M
using a heuristically chosen method.
More precisely, let
@tex
$A_1$=matrix(M),
@end tex
@ifinfo
A1=matrix(M),
@end ifinfo
then @code{res}
computes a free resolution of
@ifinfo
M1=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
@*where the columns of the matrix
@tex
$A_1$
@end tex
@ifinfo
A1
@end ifinfo
are the given set of generators of M.
The computation stops after k steps, if the int expression k
is not zero, and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*If k=0, @code{res(M,0)}
returns a list of n modules where n is the number of variables of the basering.
Let @code{list l=res(M,0);}
then L[1]=M is identical to the input, L[2] is a minimal set of generators
of the first syzygy
module of L[1], etc.
( L[i]
@ifinfo
=M_i
@end ifinfo
@tex
$=M_i$
@end tex
 in the notations from above).
@item @strong{Note:}
To access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time.
@item @strong{Example:}
@example
@c example
  ring r  = 31991,(t,x,y,z,w),ls;
  ideal M = t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
            t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  resolution L = res(M,0);
  L;
  betti(L);
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{lres};
@ref{module};
@ref{mres};
@ref{nres};
@ref{sres};
@ref{syz}.
@c ref
@c ---------------------------------------
@node reservedName, resultant, res, Functions
@subsection reservedName
@cindex reservedName
@table @code
@item @strong{Syntax:}
@code{reservedName ()}
@item @strong{Type:}
none
@item @strong{Syntax:}
@code{reservedName (} string_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
prints a list of all reserved identifiers (first form) or tests
whether the string is a reserved identifier.
@item @strong{Example:}
@example
reservedName();
@expansion{} ... // output skipped
@c example
  reservedName("ring");
  reservedName("xyz");
@c example
@end example
@end table
@c ref
See
@ref{names}.
@c ref
@c ---------------------------------------
@node  resultant, rvar, reservedName, Functions
@subsection resultant
@cindex resultant
@table @code
@item @strong{Syntax:}
@code{resultant (} poly_expression@code{,} poly_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
computes the resultant of the first and second argument with respect
to the variable given as the third argument.
@item @strong{Example:}
@example
@c example
  ring r=32003,(x,y,z),dp;
  poly f=3*(x+2)^3+y;
  poly g=x+y+z;
  resultant(f,g,x);
@c example
@end example
@end table
@menu
* poly::
* ring::
@end menu
@iftex
See @ref{poly}; @ref{ring}.
@end iftex
@c ---------------------------------------
@node rvar, setring, resultant, Functions
@subsection rvar
@cindex rvar
@table @code
@item @strong{Syntax:}
@code{rvar (} name @code{)}
@*@code{rvar (} poly_expression @code{)}
@*@code{rvar (} string_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of the variable (hence its boolean value is TRUE) if the name is a ring variable
or if the string is the name of a ring variable of the basering.
@item @strong{Example:}
@example
@c example
  ring r=29,(x,y,z),lp;
  rvar(x);
  rvar(r);
  rvar(y);
  rvar(var(3));
  rvar("x");
@c example
@end example
@end table
@menu
* defined::
* ring::
* var::
* varstr::
@end menu
@iftex
See @ref{defined}; @ref{ring}; @ref{var}; @ref{varstr}.
@end iftex
@c ---------------------------------------
@node setring, simplify, rvar, Functions
@subsection setring
@cindex setring
@table @code
@item @strong{Syntax:}
@code{setring} ring_name@code{;}
@item @strong{Type:}
none
@item @strong{Purpose:}
changes the basering to another (already defined) ring.
@item @strong{Example:}
@example
@c @c example
  ring r1=0,(x,y),lp;
  // the basering is r1
  ring r2=32003,(a(1..8)),ds;
  // the basering is r2
  setring r1;
  // the basering is again r1
  nameof(basering);
  listvar();
@c @c example
@end example
@item @strong{Use in procedures:}
All changes of the basering by a definition
of a new ring or a setring command in a procedure are local to this procedure.
Use keepring to move a ring which is local to a procedure up by one nesting
level.

@end table
@menu
* ring::
* qring::
* keepring::
@end menu
@iftex
See @ref{qring}; @ref{ring}; @ref{keepring}.
@end iftex
@c ---------------------------------------
@node simplify, size, setring, Functions
@subsection simplify
@cindex simplify
@table @code
@item @strong{Syntax:}
@code{simplify (} poly_expression@code{,} int_expression @code{)}
@*@code{simplify (} vector_expression@code{,} int_expression @code{)}
@*@code{simplify (} ideal_expression@code{,} int_expression @code{)}
@*@code{simplify (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
returns the "simplified" first argument depending on the simplification rule
given as the second argument.
@*The simplifications rules are the sum of the following
functions:
@table @code
@item 1
normalize (make leading coefficients 1)
@item 2
erase zero generators/columns
@item 4
keep only the first from identical generators/columns
@item 8
keep only the first from generators/columns which differ by a factor
from the ground field
@item 16
keep only those generators/columns whose leading monomials
differ.
@item 32
keep only those generators/columns whose leading monomials are
not divisible.
@end table
@item @strong{Example:}
@example
@c example
ring r = 0, (x,y,z), (c, dp);
ideal i = 0, 2x, 2x, 4x, 3x + y, 5x2;
simplify(i, 1);
simplify(i, 2);
simplify(i, 4);
simplify(i, 8);
simplify(i, 16);
simplify(i, 32);
simplify(i, 32 + 2 + 1);

matrix A[2][3]=x,0,2x,y,0,2y;
simplify(A,2+8); // by automatic conversion to module
@c example
@end example
@end table
@menu
* poly::
* vector::
* ideal::
* module::
@end menu
@iftex
See @ref{poly}; @ref{vector};
@ref{ideal}; @ref{module}.
@end iftex
@c ---------------------------------------
@node size, sortvec, simplify, Functions
@subsection size
@cindex size
@table @code
@item @strong{Syntax:}
@code{size (} string_expression @code{)}
@*@code{size (} intvec_expression @code{)}
@*@code{size (} intmat_expression @code{)}
@*@code{size (} poly_expression @code{)}
@*@code{size (} vector_expression @code{)}
@*@code{size (} ideal_expression @code{)}
@*@code{size (} module_expression @code{)}
@*@code{size (} matrix_expression @code{)}
@*@code{size (} list_expression @code{)}
@*@code{size (} resolution @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
@table @asis
@item ideal or module
returns the number of (non-zero) generators.
@item string, intvec, list or resolution
returns the length, i.e., the number of characters, entries or elements.
@item poly or vector
returns the number of monomials.
@item matrix or intmat
returns the number of entries (rows*columns).
@end table
@item @strong{Example:}
@example
@c example
  string s="hello";
  size(s);
  intvec iv=1,2;
  size(iv);
  ring r=0,(x,y,z),lp;
  poly f=x+y+z;
  size(f);
  vector v=[x+y,0,1];
  size(v);
  ideal i=f,y;
  size(i);
  module m=v,[0,1],[0,0,1],2*v;
  size(m);
  matrix mm[2][2];
  size(mm);
@c example
@end example
@end table
@menu
* ncols::
* nrows::
* string::
* intvec::
* intmat::
* poly::
* vector::
* ideal::
* module::
@end menu
@iftex
See @ref{string};
@ref{intvec};
@ref{intmat};
@ref{poly};
@ref{vector};
@ref{ideal};
@ref{module};
@ref{ncols}; @ref{nrows}.
@end iftex
@c ---------------------------------------
@node sortvec, sprintf, size, Functions
@subsection sortvec
@cindex sortvec
@table @code
@item @strong{Syntax:}
@code{sortvec (} ideal_expression @code{)}
@*@code{sortvec (} module_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
computes the permutation v: I[i] -> I[v[i]]
which orders the ideal resp. module by their initial term,
starting with the smallest.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  ideal I=x,y,z,x3,xz;
  sortvec(I);
@c example
@end example
@end table
@menu
general_lib::
@end menu
@iftex
@c See @ref{string expressions}; @ref{intvec expressions}; @ref{poly expressions};
See @ref{general_lib}.
@end iftex
@c ---------------------------------------
@node sprintf, sres, sortvec, Functions
@subsection sprintf
@cindex sprintf
@c lib standard.lib:sprintf lib_fun lib_ex

@c ---------------------------------------
@node sres, status, sprintf, Functions
@subsection sres
@cindex sres
@table @code
@item @strong{Syntax:}
@code{sres (} ideal_expression@code{,} int_expression @code{)}
@*@code{sres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module with Schreyer's
method. The ideal resp. module has to be a standard basis.
More precisely, let M be given by a standard basis and
@tex
$A_1=matrix(M)$.
@end tex
@ifinfo
A1=matrix(M).
@end ifinfo
Then @code{sres}
computes a free resolution of
@ifinfo
M1=coker(A1)
@*...--> F2 --A2-> F1 --A1-> F0-->M1-->0,
@end ifinfo
@tex
$M_1=coker(A_1)$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M_1\longrightarrow 0,$$
@end tex
The computation stops after k steps, if the int expression k
is not zero, and returns a list of modules (given by standard bases)
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
@ifinfo
Mi=module(Ai), i=1..k.
@end ifinfo
@*If k=0, @code{sres(M,0)}
returns a list of n modules where n is the number of variables of the basering.

Even if @code{sres} does not compute a minimal resolution, the @code{betti}
command gives the true betti numbers! In many cases of interest
@code{sres} is much faster than any other known method.
Let @code{list l=sres(M,0);} then L[1]=M is identical to the input,
L[2] is a standard basis with respect to the Schreyer ordering of
the first syzygy
module of L[1], etc.
( L[i]
@ifinfo
=M_i
@end ifinfo
@tex
$=M_i$
@end tex
 in the notations from above).
@item @strong{Note:}
To access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time.
@item @strong{Example:}
@example
@c example
  ring r  = 31991,(t,x,y,z,w),ls;
  ideal M = t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
            t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  M       = std(M);
  resolution L  = sres(M,0);
  L;
  print(betti(L),"betti");
@c example
@end example
@end table
@menu
* betti::
* ideal::
* int::
* lres::
* minres::
* module::
* mres::
* res::
* syz::
@end menu
@iftex
See @ref{betti}; @ref{ideal}; @ref{int};
@ref{lres}; @ref{minres}; @ref{module}; @ref{mres}; @ref{res}; @ref{syz}.
@end iftex
@c ---------------------------------------
@node status, std, sres, Functions
@subsection status
@cindex status
@cindex sleep
@cindex suspend
@table @code
@item @strong{Syntax:}
@code{status (} link_expression@code{,} string_expression @code{)}
@item @strong{Type:}
string
@item @strong{Syntax:}
@code{status (} link_expression@code{,} string_expression@code{,} string_expression @code{)}
@*@code{status (} link_expression@code{,} string_expression@code{,} string_expression@code{,} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the status of the link as asked for by the second argument.  If
a third argument is given, the result of the comparison to the status
string is returned: @code{(status(l,s1)==s2)} is equivalent to
@code{status(l,s1,s2)}.  If a fourth integer argument (say, @code{i}) is
given and if @code{status(l,s1,s2)} yields @code{0}, then the execution
of the current process is suspended (the process is put to ``sleep'')
for approximately@: @code{i} microseconds, and afterwards the result of another
call to @code{status(l,s1,s2)} is returned. The latter is useful for
``polling'' the @code{read} status of @code{MPtcp} links such that busy
loops are avoided (see @ref{Parallelization with MPtcp links} for an
example).  Note that on some systems, the minimum time for a process to
be put to sleep is one second.
@*The following string expressions are allowed:
@table @code
@item @code{"name"}
the name string given by the definition of the link (usually the filename)
@item @code{"type"}
returns @code{"ASCII"}, @code{"MPfile"}, @code{"MPtcp"} or @code{"DBM"}
@item @code{"open"}
returns @code{"yes"} or @code{"no"}
@item @code{"openread"}
returns @code{"yes"} or @code{"no"}
@item @code{"openwrite"}
returns @code{"yes"} or @code{"no"}
@item @code{"read"}
returns @code{"ready"} or @code{"not ready"}
@item @code{"write"}
returns @code{"ready"} or @code{"not ready"}
@item @code{"mode"}
returns (depending on the type of the link and its status)
@code{"","w","a","r"} or @code{"rw"}
@end table
@item @strong{Example:}
@example
@c example
  link l=":w example.txt";
  status(l,"write");
  open(l);
  status(l,"write","ready");
  close(l);
@c example
@end example
@end table
@menu
* link::
* open::
* read::
* write::
@end menu
@iftex
See @ref{link}; @ref{open}; @ref{read}; @ref{write}.
@end iftex
@c ---------------------------------------
@node std, stdfglm, status, Functions
@subsection std
@cindex std
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} intvec_expression @code{)}
@*@code{std (} module_expression@code{,} intvec_expression @code{)}
@*@code{std (} ideal_expression@code{,} intvec_expression@code{,} intvec_expression @code{)}
@*@code{std (} module_expression@code{,} intvec_expression@code{,} intvec_expression @code{)}
@*@code{std (} ideal_expression@code{,} poly_expression @code{)}
@*@code{std (} module_expression@code{,} vector_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a standard basis of an ideal or module with respect to the
monomial ordering of the basering.
A standard basis is a set of generators such that
the leading terms generate the leading ideal resp. module.
@*Use an optional
second argument of type @code{intvec} as Hilbert series
(result of @code{hilb(i,1)}, see @ref{hilb}),
if the ideal resp. module is homogeneous,
(Hilbert driven standard basis computation, @ref{stdhilb}).
If the ideal is quasihomogeneous with some weights w and if the Hilbert series
is computed w.r.t. to this weights, then use w as third argument if the ordering
is not weighted degree with w.
@item @strong{Note:}
The
standard basis is computed with a (more or less) brute-force
implementation of the classical
Buchberger (resp. Mora) algorithm. For global orderings, use the
@code{groebner} (@pxref{groebner}) command, instead, which heuristically
chooses the "best" algorithm to compute a Groebner basis.
@*Use an optional second argument of type @code{poly} resp.@ @code{vector}
to construct the standard basis from an already computed one (givenn as the
first argument) and one additional generator (the second argument).
@item @strong{Example:}
@example
@c example
  // local computation 
  ring r = 32003, (x,y,z), ds;
  poly s1  = 1x2y + 151xyz10 + 169y21;
  poly s2  = 1xz14 + 6x2y4 + 3z24;
  poly s3  = 5y10z10x + 2y20z10 + y10z20 + 11x3;
  ideal i = s1, s2, s3;
  ideal j = std(i);
  degree(j);
  // Hilbert driven elimination (standard)
  ring rhom = 32003, (x,y,z,h), dp;
  ideal i = homog(imap(r,i),h);
  ideal j = std(i);
  intvec iv = hilb(j,1);
  ring rlex = 32003, (x,y,z,h), lp;
  ideal i = fetch(rhom,i);
  ideal j = std(i,iv);
  j = subst(j,h,1);
  j[1];
  // Hilbert driven elimination (ideal is quasihomogeneous)
  intvec w=10,1,1;
  ring whom = 32003, (x,y,z), wp(w);
  ideal i = fetch(r,i);
  ideal j = std(i);
  intvec iw = hilb(j,1);
  ring wlex = 32003, (x,y,z), lp;
  ideal i = fetch(whom,i);
  ideal j = std(i,iw,w);
  j[1];
@c example
@end example
@end table
@c ref
See
@ref{ideal};
@ref{ring};
@ref{option};
@ref{facstd};
@ref{mstd};
@ref{stdfglm};
@ref{stdhilb}.
@c ref

@c ---------------------------------------
@node stdfglm, stdhilb, std, Functions
@subsection stdfglm
@cindex stdfglm
@c lib standard.lib:stdfglm lib_fun lib_ex

@c ---------------------------------------
@node stdhilb, subst, stdfglm, Functions
@subsection stdhilb
@cindex stdhilb
@c lib standard.lib:stdhilb lib_fun lib_ex

@c ---------------------------------------
@node subst, system, stdhilb, Functions
@subsection subst
@cindex subst
@table @code
@item @strong{Syntax:}
@code{subst (} poly_expression@code{,} ring_variable@code{,} term @code{)}
@*@code{subst (} vector_expression@code{,} ring_variable@code{,} term @code{)}
@*@code{subst (} ideal_expression@code{,} ring_variable@code{,} term @code{)}
@*@code{subst (} module_expression@code{,} ring_variable@code{,} term @code{)}
@item @strong{Type:}
poly, vector, ideal or module (the same as the first argument)
@item @strong{Purpose:}
substitutes a ring variable by a term (a polynomial of length <=1).
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  poly f=x2+y2+z2+x+y+z;
  subst(f,x,3/2);
  int a=1;
  subst(f,y,a);
  subst(f,y,z);
@c example
@end example
@end table
@menu
* poly::
* vector::
* ideal::
* module::
@end menu
@iftex
See @ref{poly}; @ref{vector};
@ref{ideal}; @ref{module}.
@end iftex
@c ---------------------------------------
@node  system, syz, subst, Functions
@subsection system
@cindex system
@table @code
@item @strong{Syntax:}
@code{system (} expression_list @code{)}
@sp 1
the first expression must be of type string and selects the desired function.
@item @strong{Type:}
depends on the desired function, may be none
@item @strong{Purpose:}
interface to internal data and the operating system.
@*Not all functions work on every platform.
@item @strong{Functions:}
@table @code
@item @code{system("sh"},string_expression @code{)}
shell escape, returns the return code of the shell
@item @code{system("pid")}
returns the process number (for creating unique names)
@item @code{system("getenv",}string_expression@code{)}
returns shell environment variable given as the second argument
@item @code{system("tty")}
resets the terminal
@item @code{system("version")}
returns the version number of  @sc{Singular} (type int)
@item @code{system("contributors")}
returns names of people who contributed to the Singular kernel
@item @code{system("random"},int_expression @code{)}
resets the random generator to the given value and return it (type int)
@item @code{system("random")}
returns the seed of the random generator (type int)
@item @code{system("gen")}
returns the generating element of the multiplicative
group of Z/p\@{0@} (as int) where p is the characteristic of the
basering
@item @code{system("nblocks" [, ring])}
returns the number of blocks of @code{ring}, or the number of parameters
of the current basering, if no second argument is given.
@item @code{system("Singular")}
returns the absolute (path) name of the running @sc{Singular} (type string)
@item @code{system("long_option_name")}
returns the value of the (command-line)
option @code{"long_option_name"}; for on/off options, the return value is of type
int and either 1 or 0; for all other options, the return type is string.
@end table
@item @strong{Example for UNIX:}
@example
// a listing of the current directory:
system("sh","ls");
// execute a shell, return to SINGULAR with exit:
system("sh","sh");
string unique_name="/tmp/xx"+string(system("pid"));
unique_name;
@expansion{} /tmp/xx4711
system("getenv","PATH");
@expansion{} /bin:/usr/bin:/usr/local/bin
system("Singular");
@expansion{} /usr/local/bin/Singular
// report minimal display time
system("--min-time");
@expansion{} 0.5
@end example
@item @strong{Example for MSDOS:}
@example
// a listing of the current directory:
system("sh","dir");
// execute a shell, return to SINGULAR with exit:
system("sh","command");
string unique_name="/tmp/xx"+string(system("pid"));
unique_name;
@expansion{} /tmp/xx0
@end example
@end table
@c @menu
@c @end menu
@iftex
@c See @ref{}; @ref{}; @ref{}; @ref{}; @ref{}.
@end iftex
@c -------------------------------------------------
@node syz, trace, system, Functions
@subsection syz
@cindex syz
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e. the module of relations of the given generators)
of the ideal resp. module.
@item @strong{Example:}
@example
@c example
  ring R=0,(x,y),(c,dp);
  ideal i=x,y;
  syz(i);
@c example
@end example
@end table
@menu
* ideal::
* lres::
* module::
* mres::
* nres::
* res::
* sres::
@end menu
@iftex
See @ref{ideal}; @ref{lres}; @ref{module}; @ref{mres}; @ref{nres};
@ref{res}; @ref{sres}.
@end iftex
@c ---------------------------------------
@node trace, transpose, syz, Functions
@subsection trace
@cindex trace
@table @code
@item @strong{Syntax:}
@code{trace (} intmat_expression @code{)}
@*@code{trace (} matrix_expression @code{)}
@item @strong{Type:}
int resp. poly
@item @strong{Purpose:}
returns the trace of an intmat resp a matrix.
@item @strong{Example:}
@example
@c example
  intmat m[2][2]=1,2,3,4;
  print(m);
  trace(m);
@c example
@end example
@end table
@menu
* intmat::
* matrix::
@end menu
@iftex
See
@ref{intmat}; @ref{matrix}.
@end iftex
@c ---------------------------------------
@node transpose, type, trace, Functions
@subsection transpose
@cindex transpose
@table @code
@item @strong{Syntax:}
@code{transpose (} intmat_expression @code{)}
@*@code{transpose (} matrix_expression @code{)}
@*@code{transpose (} module_expression @code{)}
@item @strong{Type:}
same type as the argument
@item @strong{Purpose:}
transposes a matrix.
@item @strong{Example:}
@example
@c example
  ring R=0,x,dp;
  matrix m[2][3]=1,2,3,4,5,6;
  print(m);
  print(transpose(m));
@c example
@end example
@end table
@c ref
See @ref{intmat};
@ref{matrix};
@ref{module}.
@c ref
@c ---------------------------------------
@node type, typeof, transpose, Functions
@subsection type
@cindex type
@table @code
@item @strong{Syntax:}
@code{type} (name) @code{;}
@item @strong{Type:}
none
@item @strong{Purpose:}
lists the [name, level, type and] value of a variable. To display the
value of an expression, it is sufficient to type @code{expression;}.
@item @strong{Example:}
@example
@c example
  int i=3;
  i;
  type i;
@c example
@end example
@end table
@menu
* listvar::
* print::
* Data types::
@end menu
@iftex
See @ref{listvar}; @ref{print}; @ref{Data types}.
@end iftex
@c ---------------------------------------
@node typeof, var, type, Functions
@subsection typeof
@cindex typeof
@table @code
@item @strong{Syntax:}
@code{typeof (} expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the type of an expression as string.

Returns the type of the first list element if the expression is an
expression list.

Possible types are:
@code{"ideal"},
@code{"int"},
@code{"intmat"},
@code{"intvec"},
@code{"list"},
@code{"map"},
@code{"matrix"},
@code{"module"},
@code{"number"},
@code{"none"},
@code{"poly"},
@code{"proc"},
@code{"qring"},
@code{"resolution"},
@code{"ring"},
@code{"string"},
@code{"vector"}.

For internal use only are the types
@code{"package"},
@code{"?unknown type?"}.
@item @strong{Example:}
@example
@c example
  int i = 9;
  i;
  typeof(_);
  print(i);
  typeof(_);
  type i;
  typeof(_);
  string s = typeof(i);
  s;
  typeof(s);
  proc p() {  "hello"; return();}
  p();
  typeof(_);
@c example
@end example
@end table
@menu
* Data types::
@end menu
@iftex
See @ref{Data types}.
@end iftex
@c ---------------------------------------
@node var, varstr, typeof, Functions
@subsection var
@cindex var
@table @code
@item @strong{Syntax:}
@code{var (} int_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
returns the n-th ring variable for a given integer n.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  var(2);
@c example
@end example
@end table
@menu
* ring::
* int::
* nvars::
* varstr::
@end menu
@iftex
See @ref{ring}; @ref{int}; @ref{nvars}; @ref{varstr}.
@end iftex
@c ---------------------------------------
@node varstr, vdim, var, Functions
@subsection varstr
@cindex varstr
@table @code
@item @strong{Syntax:}
@code{varstr (} ring_name @code{)}
@*@code{varstr (} int_expression @code{)}
@*@code{varstr (} ring_name@code{,} int_expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the list of the names of the ring variables as a string
@*or the name of the n-th ring variable for a given integer n.
@*@code{varstr(n)} is equivalent to @code{varstr(basering,n)}.
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y,z),dp;
  varstr(r);
  varstr(r,1);
  varstr(2);
@c example
@end example
@end table
@menu
* ring::
* int::
* var::
* nvars::
* ordstr::
* charstr::
* parstr::
@end menu
@iftex
See @ref{ring}; @ref{int}; @ref{nvars}; @ref{var};
@ref{ordstr};
@ref{charstr};
@ref{parstr}.
@end iftex
@c ---------------------------------------
@node vdim, wedge, varstr, Functions
@subsection vdim
@cindex vdim
@table @code
@item @strong{Syntax:}
@code{vdim (} ideal_expression @code{)}
@*@code{vdim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the vector space dimension of the ring (resp. free module)
modulo the ideal (resp. module)
generated by the initial terms of the given generators.
If the generators are  a standard basis,
this is the same as the vector space dimension of the ring (resp.
free module) modulo the ideal (resp. module).
@*If the ideal resp.@: module is not zero-dimensional, -1 is returned
@item @strong{Example:}
@example
@c example
  ring r=0,(x,y),ds;
  ideal i=x2+y2,x2-y2;
  ideal j=std(i);
  vdim(j);
@c example
@end example
@end table
@menu
* ideal::
* std::
* dim::
* degree::
* mult::
* kbase::
@end menu
@iftex
See @ref{ideal}; @ref{std}; @ref{dim}; @ref{degree}; @ref{mult}; @ref{kbase}.
@end iftex
@c ---------------------------------------
@node wedge, weight, vdim, Functions
@subsection wedge
@cindex wedge
@table @code
@item @strong{Syntax:}
@code{wedge (} matrix_expression@code{,} int_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the n-th exterior power of matrix for a given integer n.
@item @strong{Example:}
@example
@c example
  ring r;
  matrix m[2][3] = x,y,y,z,z,x;
  print(m);
  print(wedge(m,2));
@c example
@end example
@end table
@menu
* matrix::
* minor::
* int::
@end menu
@iftex
See @ref{matrix}; @ref{minor}; @ref{int}.
@end iftex
@c ---------------------------------------
@node weight, write, wedge, Functions
@subsection weight
@cindex weight
@table @code
@item @strong{Syntax:}
@code{weight (} ideal_expression @code{)}
@*@code{weight (} module_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
computes an "optimal" weight vector for an ideal resp. module which may be used as
weight vector for the variables in order to speed up the standard basis
algorithm.   If the input is weighted homogeneous, a weight vector for
which the input is weighted homogeneous is found.
@item @strong{Example:}
@example
@c example
  ring h1=32003,(t,x,y,z),dp;
  ideal i=
  9x8+y7t3z4+5x4y2t2+2xy2z3t2,
  9y8+7xy6t+2x5y4t2+2x2yz3t2,
  9z8+3x2y3z2t4;
  intvec e=weight(i);
  e;
  ring r=32003,(a,b,c,d),wp(e);
  map f=h1,a,b,c,d;
  ideal i0=std(f(i));
@c example
@end example
@end table
@menu
* ideal::
* intvec::
* qhweight::
@end menu
@iftex
See @ref{ideal}; @ref{intvec}; @ref{qhweight}.
@end iftex
@c ---------------------------------------
@node  write,  , weight, Functions
@subsection write
@cindex write
@table @code
@item @strong{Syntax:}
@code{write (} link_expression@code{,} expression_list @code{);}
@*for DBM links:
@*@code{write(} link@code{,} string_expression@code{,} string_expression @code{);}
@*@code{write(} link@code{,} string_expression @code{);}
@item @strong{Type:}
none
@item @strong{Purpose:}
writes data to a link.
@*If the link is of type @code{ASCII}, all expressions are converted to
strings  (and separated by a newline character) before they are
written. As a consequence, only such values which can be converted to a
string can be written to an  @code{ASCII} link.
@*For MP links,
ring-dependent expressions are written together with a ring
description. To prevent an evaluation of the expression before it is
written, the @code{quote} command (possibly together with @code{eval})
can be used. A @code{write} blocks (i.e. does not return to the prompt),
as long as a MPtcp link is not ready for writing.
@*For DBM links, @code{write} with three arguments inserts the first
string as key and the second string as value into the dbm data
base.
@*Called with two arguments it deletes the entry with the key
specified by the string from the data base.
@item @strong{Example:}
@example
//write the lines with the values of the variables f and i
//then the value of m+a into the file "outfile"
write(":w outfile",f,i,m+a);
string filename=":a outfile";
//now append the string "that was f,i,m+a" (without the quotes)
// at the end of the file "outfile"
write(filename,"that was f,i,m+a");
// saving and retrieving data:
ring r=32003,(x,y,z),dp;
ideal i=x+y,z3+22y;
write(":w save_i",i);// this writes x+y,z3+22y to the file save_i

ring r=32003,(x,y,z),dp;
string s=read("save_i");  //creates the string x+y,z3+22y
execute "ideal k="+s+";"; // this defines an ideal k which
                          // is equal to i.
@end example
@end table
@c ref
See
@ref{read};
@ref{link};
@ref{Data types};
@ref{quote};
@ref{eval};
@ref{dump}.
@c ref


@c ---------------------------------------
@node Control structures, System variables, Functions, Functions and system variables
@section Control structures
@cindex Control structures
@cindex block
@ifinfo
@*List of all supported control structures.
@end ifinfo
@menu
* break::
* continue::
* else::
* export::
* for::
* if::
* keepring::
* quit::
* return::
* while::
* ~::
@ifset namespaces
* exportto::
* importfrom::
* load::
* unload::
@end ifset
@end menu

A sequence of commands surrounded by curly brackets (@code{@{} and
@code{@}}) is a so called block. Blocks are used in @sc{Singular} in
order to define procedures and to collect commands belonging to
@code{if}, @code{else}, @code{for} and @code{while} statements and to the
@code{example} part in libraries. Even if
the sequence of statements consists of only a single command it has to be
surrounded by curly brackets!
Variables which are defined inside a block
are not local to that block. Note that there is no ending semicolon at
the end of the block.
@table @code
@item @strong{Example:}
@example
if ( i>j )
@{
  // This is the block
  int temp;
  i=temp;
  i=j;
  j=temp;
  kill temp;
@}
@end example
@end table

@c ---------------------------------------
@node break, continue, Control structures, Control structures
@subsection break
@cindex break
@table @code
@item @strong{Syntax:}
@code{break;}
@item @strong{Purpose:}
leaves the innermost @code{for}- or @code{while}-block.
@item @strong{Example:}
@example
while (1)
@{
  @dots{}
  if ( @dots{} )
  @{
    break; // leave the while block
  @}
@}
@end example
@end table
@c ref
See @ref{Control structures};
@ref{for};
@ref{while}.
@c ref
@c ---------------------------------------
@node continue, else, break, Control structures
@subsection continue
@cindex continue
@table @code
@item @strong{Syntax:}
@code{continue;}
@item @strong{Purpose:}
skips the rest of this loop und jumps to the beginning of the
block. This command is only valid inside a @code{for} or a @code{while}
construct.
@item @strong{Note:}
Unlike the C-construct it @strong{does not execute the increment statement}.
The command @code{continue} is mainly for internal use.
@item @strong{Example:}
@example
for (int i = 1 ; i<=10; i=i+1)
@{
   @dots{}
   if (i==3) @{ i=8;continue; @}
     // skip the rest if i is 3 and
     // continue with the next i: 8
   i;
@}
@expansion{} 1
@expansion{} 2
@expansion{} 8
@expansion{} 9
@expansion{} 10
@end example
@end table
@c ref
See @ref{Control structures}; @ref{for}; @ref{while}.
@c ref
@c ---------------------------------------
@node else, export, continue, Control structures
@subsection else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} true_block @code{else} false_block
@item @strong{Purpose:}
executes false_block if the boolean_expression of the @code{if} statement
is false. This command is only valid in combination with an @code{if}
command.
@item @strong{Example:}
@example
int i=3;
if (i > 5)
@{
  "i is bigger than 5";
@}
else
@{
  "i is smaller than 6";
@}
@expansion{} i is smaller than 6
@end example
@end table
@c ref
See @ref{if}; @ref{boolean expressions}; @ref{Control structures}.
@c ref
@c ---------------------------------------
@ifset namespaces
@node export, exportto, else, Control structures
@end ifset
@ifclear namespaces
@node export, for, else, Control structures
@end ifclear
@subsection export
@cindex export
@table @code
@item @strong{Syntax:}
@code{export} name @code{;}
@*@code{export} list_of_names @code{;}
@item @strong{Purpose:}
converts a local variable of a procedure to a global one.
@ifset namespaces
@item @strong{Note:} obsoleted by @code{exportto}.
@end ifset
@end table

@ifset namespaces
@c ref
See @ref{exportto}; @ref{keepring}.
@c ref
@end ifset
@ifclear namespaces
@c ref
See @ref{keepring}.
@c ref
@end ifclear
@c ---------------------------------------
@ifset namespaces
@c ---------------------------------------
@node exportto, importfrom, export, Control structures
@subsection exportto
@cindex exportto
@table @code
@item @strong{Syntax:}
@code{exportto(} package_name @code{, }name @code{);}
@*@code{exportto(} package_name @code{,} list_of_names @code{);}
@item @strong{Purpose:}
converts a local variable of a procedure to a global one.
package_name can be @code{Current}, @code{Up}, @code{Top} or any other
identifier of type package.

@item @strong{Note:} Objects defined in a ring are not automatically exported
when exporting the ring, (use @code{keepring} instead).
@item @strong{Example:}
@example
proc p1
@{
  int i,j;
  exportto(Current,i);
  intmat m;
  listvar();
  exportto(Top,m);
@}
p1();
@expansion{} // m                    [1]  intmat 1 x 1
@expansion{} // j                    [1]  int 0
@expansion{} // i                    [0]  int 0
listvar();
@expansion{} // m                    [0]  intmat 1 x 1
@expansion{} // i                    [0]  int 0
@end example
@end table
@c ref
See @ref{keepring}.
@c ref
@c ---------------------------------------
@node importfrom, load, exportto, Control structures
@subsection importfrom
@cindex importfrom
@table @code
@item @strong{Syntax:}
@code{importfrom(}@code{);}
@end table

@c ref
See @ref{exportto}.
@c ref
@c ---------------------------------------
@node load, unload, importfrom, Control structures
@subsection load
@cindex load
@table @code
@item @strong{Syntax:}
@code{load(} string_expression @code{);}
@*@code{load(}string_expression@code{,"with");}
@item @strong{Type:}
none
@item @strong{Purpose:}
@c reads a library of procedures or functions from a file. If the given
@c filename does not start with  @kbd{~}, @kbd{.} or @kbd{/}, the following
@c directories are searched for (in that order): the current directory, the
@c directories given in the environment variable @code{SINGULARPATH}, some
@c default directories relative to the location of the @sc{Singular}
@c executable program, and finally some default absolute directories. You
@c can view the search path which @sc{Singular} uses to locate its
@c libraries, by starting up @sc{Singular} with the option @code{-v}, or by
@c issuing the command @code{system("with");"}.
reads a library of procedures from a file. If the given filename does
not start with @kbd{.} or @kbd{/}, the following directories are
searched for (in that order): the current directory, the directories given in
the environment variable @code{SINGULARPATH}, some default directories
relative to the location of the @sc{Singular} executable program, and
finally some default absolute directories. You can view the search path
which @sc{Singular} uses to locate its libraries, by starting up
@sc{Singular} with the option @code{-v}, or by issuing the command
@code{system("with");"}.

Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
library @code{standard.lib} is automatically loaded at start-up time.
@end table

All loaded libraries are displayed by the @code{listvar(package);}
command:
@example
@c example
  option(loadLib);   // show loading of libraries;
                     // standard.lib is loaded
  listvar(package);
                     // the names of the procedures of inout.lib
  load("inout.lib"); // are now known to Singular
  listvar(package);
@c example
@end example

Each time a library @ref{Singular library} / dynamic module @ref{dynamic
module} is loaded, the corresponding namespace is created, if it does
not already exist.

The name of this namespace corresponding to a Singular library is
derived from the name of the library file. The first letter is
capitalized and everything to right of the left-most dot is
dropped.
For a dynamic module the packagename is hard-coded in the binary file.

@sc{Singular} also supports autoloading of packages.
To use this features, just specify the identifier by its full name:

@example
@c example error
  listvar(package);
  Inout::version;     // full name of a variable in the package Inout
  listvar(package);   // the package Inout has been autoloaded
@c example
@end example

For autoloading the base of the filename is generated by converting the
packagename to lowercase letters. The search is done in the standard
@sc{Singular} search path, first looking for a file of this name, and then
appending to the base @code{.lib}, @code{.so}, @code{.sl} (in this order).


An identifier of type @code{package} is created and all procedures are
stored in that package.
Before loading the type of the file is checking. For an Singular
library, the package is set as filename until the first '.' in the name
with an uppercase first letter. If the library to load is an binary file
with procedures written in an higher language (e.g. C, C++, ...) the
package name s hard-code in the library.


The second argument @code{"with"} will automatically export all none
static procedures to the toplevel.


Only the names of the procedures in the library are loaded, the body of
the procedures is read during the first call of this procedure. This minimizes
memory consumption by unused procedures.  When @sc{Singular} is started
with the @code{-q} or @code{--quiet} option, no message about the
loading of a library is displayed.  More exactly, option @code{-q} (and
likewise @code{--quiet}) unsets option @code{loadLib} to inhibit
monitoring of library loading (@pxref{option}).

Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
library @code{standard.lib} is automatically loaded at start-up time.

@example
@c example
  option(loadLib); // show loading of libraries; standard.lib is loaded
                   // the names of the procedures of inout.lib
  load("inout.lib"); // are now known to Singular
  listvar();
@c example
@end example
@c ref
See
@ref{Command line options};
@ref{Procedures and libraries};
@ref{SINGULAR libraries};
@ref{proc};
@ref{standard_lib};
@ref{package};
@ref{string};
@ref{system}.
@ref{LIB};
@ref{exportto};
@ref{importfrom};
@ref{Namespaces};
@ref{dynamic module}
@c ref

@c ---------------------------------------
@node unload, for, load, Control structures
@subsection unload
@cindex unload
@table @code
@item @strong{Syntax:}
@code{unload(}@code{);}
@end table
@c ---------------------------------------
@end ifset
@c ---------------------------------------
@ifset namespaces
@node for, if, unload, Control structures
@end ifset
@ifclear namespaces
@node for, if, export, Control structures
@end ifclear
@subsection for
@cindex for
@table @code
@item @strong{Syntax:}
@code{for (} init_commands@code{;}
boolean_expression@code{;}
iterate_commands@code{)} block
@item @strong{Purpose:}
repetitive, conditional execution of a command block.
@*The command init_command is executed first. Then boolean_expression is
evaluated. If its value is TRUE the block is executed, otherwise the @code{for}
statement is complete. After each execution of the block, the command
iterate_command is executed and boolean_expression is evaluated.
@*The command @code{break;} leaves the innermost @code{for} construct.
@item @strong{Example:}
@example
// sum of 1 to 10:
int s=0;
for (int i=1; i<=10; i=i+1)
@{
   s=s+i;
@}
s;
@expansion{} 55
@end example
@end table
@c ref
See @ref{Control structures}; @ref{boolean expressions}; @ref{while}; @ref{if};
@ref{break}; @ref{continue}.
@c ref
@c ---------------------------------------
@node if, keepring, for, Control structures
@subsection if
@cindex if
@cindex else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} true_block
@*@code{if (} boolean_expression @code{)} true_block @code{else} false_block
@item @strong{Purpose:}
executes true_block if the boolean condition is true. If the @code{if}
statement is followed by an @code{else} statement and the boolean
condition is false, then false_block is executed.
@item @strong{Example:}
@example
int i = 9;
matrix m [i][i];
if (i > 5 and typeof(m) == "matrix")
@{
  m[i][i] = i;
@}
@end example
@end table
@c ref
See @ref{else}; @ref{break}; @ref{Control structures};
@ref{boolean expressions}.
@c ref
@c ---------------------------------------
@node keepring, quit, if, Control structures
@subsection keepring
@cindex keepring
@table @code
@item @strong{Syntax:}
@code{keepring} name @code{;}
@item @strong{Purpose:}
moves the specified ring to the next (upper) level. This command can only
be used inside of procedures and it should be the last command before the
@code{return} statement. There it provides the possibility to keep
a ring which is local to the procedure (and its objects) accessible after
the procedure ended without making the ring global.
@item @strong{Example:}
@example
proc P1
@{
  ring r=0,x,dp;
  keepring r;
@}
proc P2
@{
  "inside P2: " + nameof(basering);
  P1();
  "inside P2, after call of P1: " + nameof(basering);
@}
ring r1= 0,y,dp;
P2();
@expansion{} inside P2: r1
@expansion{} inside P2, after call of P1: r
"at top level: " + nameof(basering);
@expansion{} at top level: r1
@end example
@end table
@c ---------------------------------------
@node quit, return, keepring, Control structures
@subsection quit
@cindex quit
@cindex exit
@table @code
@item @strong{Syntax:}
@code{quit;}
@item @strong{Purpose:}
quits @sc{Singular},
works also from inside a procedure. The commands @code{quit} and
@code{exit} are synonymous.
@item @strong{Example:}
  quit;
@end table
@c ---------------------------------------
@node return, while, quit, Control structures
@subsection return
@cindex return
@table @code
@item @strong{Syntax:}
@code{return (} expression_list @code{);}
@*@code{return ();}
@item @strong{Type:}
any
@item @strong{Purpose:}
returns the result(s) of a procedure.
@*Can only be used inside a procedure.
@item @strong{Example:}
@example
proc p2
@{
  int i,j;
  for(i=1;i<=10;i++)
  @{
    j=j+i;
  @}
  return(j);
@}
// can also return an expression list, i.e., more than value
proc tworeturn ()
@{ return (1,2); @}
int i,j = tworeturn();
// return type may even depend on the input
proc type_return (int i)
@{
  if (i > 0) @{return (i);@}
  else @{return (list(i));@}
@}
// then we need def type (or list) to collect value
def t1 = type_return(1);
def t2 = type_return(-1);
@end example
@end table
@c ref
See
@ref{Data types};
@ref{proc}.
@c ref
@c ---------------------------------------
@node while, ~ , return, Control structures
@subsection while
@cindex while
@table @code
@item @strong{Syntax:}
@code{while (}boolean_expression@code{)} block
@item @strong{Purpose:}
repetitive, conditional execution of block.
@*The command @code{break} leaves the innermost @code{while}
construct.
@item @strong{Example:}
@example
int i = 9;
while (i>0)
@{
   // @dots{} // do something for i=9, 8, ..., 1
   i = i - 1;
@}
while (1)
@{
   // @dots{}   // do something forever
   if (i == -5) // but leave the loop if i is -5
   @{
     break;
   @}
@}
@end example
@end table
@c ref
See @ref{Control structures}; @ref{boolean expressions}; @ref{break}.
@c ref

@c ---------------------------------------
@node ~, , while, Control structures
@subsection ~ (breakpoint)
@cindex ~
@cindex breakpoint
@table @code
@item @strong{Syntax:}
@code{~;}
@item @strong{Purpose:}
sets a breakpoint. Whenever @sc{Singular} reaches the command @code{~;}
in a sequence of commands it prompts for input. The user may now input
lines of @sc{Singular} commands. The line length can not exceed 80
characters.
@sc{Singular} proceeds with the execution of the command following @code{~;}
as soon as it receives an empty line.
@item @strong{Example:}
@example
proc t
@{
  int i=2;
  ~;
  return(i+1);
@}
t();
@expansion{} -- break point in t --
@expansion{} -- 0: called    from STDIN --
// here local variables of the procedure can be accessed
i;
@expansion{} 2
@expansion{} -- break point in t --

@expansion{} 3
@end example
@end table
@c ref
See @ref{Break points}.
@c ref

@c ---------------------------------------
@node System variables,  , Control structures, Functions and system variables
@section System variables
@cindex System variables
@ifinfo
@*List of all system variables.
@end ifinfo
@menu
* degBound::
* echo::
* minpoly::
* multBound::
* noether::
* printlevel::
* short::
* timer::
* TRACE var::
* rtimer::
* voice::
@end menu
@c ---------------------------------------
@c @node alternating, degBound, System variables, System variables
@c @subsection alternating
@c @cindex alternating
@c @table @code
@c @item @strong{Syntax:}
@c @code{alternating =} int_expression@code{;}
@c @*int_variable @code{= alternating;}
@c @item @strong{Purpose:}
@c describes the position of the first alternating variable in the current
@c basering, thus creating the tensor
@c product of a polynomial ring with an exterior algebra.
@c @*Remark: Setting @code{alternating=1;} defines the exterior algebra.
@c @item @strong{Note:}
@c These algebras are only available in those versions of
@c @sc{Singular} which are compiled with the SRING option.
@c The SRING version is
@c significantly slower for usual (commutative) ring operations.
@c @item @strong{Example:}
@c @example
@c   // define the exterior algebra in 3 variables x, y, z
@c   ring r=0,(x,y,z),dp;
@c   alternating=1;
@c   y*x;
@c   @expansion{} -1*xy
@c @end example
@c @end table
@c @menu
@c * int expressions::
@c * ring::
@c @end menu
@c @iftex
@c See @ref{ring}; @ref{int expressions}.
@c @end iftex
@c @c -----------------------------------------------------
@node degBound, echo, System variables, System variables
@subsection degBound
@cindex degBound
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
The standard basis computation is stopped if the total
(weighted) degree
exceeds @code{degBound}.
@* @code{degBound} should not be used for a global ordering with inhomogeneous
input.
@*Reset this bound by setting @code{degBound} to 0.
@item @strong{Example:}
@example
degBound = 7;
option();
@expansion{} //options for 'std'-command: degBound
ideal j=std(i);
degBound;
@expansion{} 7
degBound = 0; //resets degree bound to infinity
@end example
@end table
@menu
* deg::
* int::
* option::
@end menu
@iftex
See @ref{deg}; @ref{int}; @ref{option}.
@end iftex
@c -----------------------------------------------------
@node echo, minpoly, degBound, System variables
@subsection echo
@cindex echo
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
input is echoed if @code{echo} >= @code{voice}.
@*echo is a local setting for a procedure and defaulted to 0.
@*echo does not affect the output of commands.
@item @strong{Example:}
@c this example cannot be a computed one - echo interferes with -e
@example
echo = 1;
int i = echo;
@expansion{} int i = echo;
@end example
@end table
@menu
* int::
* voice::
@end menu
@iftex
See @ref{int}; ref{voice}.
@end iftex
@c -----------------------------------------------------
@node minpoly, multBound, echo, System variables
@subsection minpoly
@cindex minpoly
@table @code
@item @strong{Type:}
number
@item @strong{Purpose:}
describes the coefficient field of the current basering as
an algebraic extension with the minimal polynomial equal to @code{minpoly}.
Setting the @code{minpoly} should be the first command after
defining the ring.
@item @strong{Note:}
The minimal polynomial has to be specified in the syntax of a polynomial.
Its variable is not one of the ring variables, but the algebraic element
which is being adjoined to the field.
Algebraic extension are in @sc{singular} only possible over the rational
numbers or Z/p, p prime number.
@c @*@strong{Warning:}
@*@sc{Singular} does not check whether the given
polynomial is irreducible! It can be checked in advance with the
function @code{factorize} @ref{factorize}.
@item @strong{Example:}
@example
@c example
  //(Q[i]/(i^2+1))[x,y,z]:
  ring Cxyz=(0,i),(x,y,z),dp;
  minpoly=i^2+1;
  i2;
@c example
@end example
@end table
@menu
* factorize::
* ring::
@end menu
@iftex
See @ref{ring}.
@end iftex
@c -----------------------------------------------------
@node multBound, noether, minpoly, System variables
@subsection multBound
@cindex multBound
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
The standard basis computation is stopped if the ideal is
zero-dimensional in a ring with local ordering
and its multiplicity (@code{mult}) is lower than @code{multBound}.
@*Reset this bound by setting @code{multBound} to 0
@item @strong{Example:}
@example
multBound = 20;
option();
@expansion{}    //options for 'std'-command: multBound
ideal j=std(i);
multBound;
@expansion{} 20
multBound = 0;  //disables multBound
@end example
@end table
@menu
* int::
* mult::
* option::
@end menu
@iftex
See @ref{int}; @ref{mult}; @ref{option}.
@end iftex
@c -----------------------------------------------------
@node noether, printlevel, multBound, System variables
@subsection noether
@cindex noether
@table @code
@item @strong{Type:}
poly
@item @strong{Purpose:}
The standard basis computation in local rings
cuts off  all monomials above
(in the sense of the monomial ordering)
the monomial @code{noether} during the computation.
@*Reset @code{noether} by setting @code{noether} to 0
@item @strong{Example:}
@example
@c example
  ring R=32003,(x,y,z),ds;
  ideal i=x2+y^12,y13;
  std(i);
  noether = x^11;
  std(i);
  noether = 0; //disables noether
@c example
@end example
@end table
@menu
* poly::
* degBound::
* std::
@end menu
@iftex
See @ref{poly}; @ref{std}.
@end iftex
@c -----------------------------------------------------
@node printlevel, short, noether, System variables
@subsection printlevel
@cindex printlevel
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
sets the debug level for dbprint.
If @code{printlevel} >= @code{voice} @code{dbprint} is equivalent to
@code{print}, otherwise nothing is printed.
@item @strong{Note:}
@xref{Guidelines for writing a library}, for an example how this is used
for the display of comments while procedures are executed.
@item @strong{Example:}
@example
@c example
  voice;
  printlevel=0;
  dbprint(1);
  printlevel=voice;
  dbprint(1);
@c example
@end example
@end table
@menu
* int::
* dbprint::
* voice::
@end menu
@iftex
See @ref{int}; @ref{dbprint}; @ref{voice}.
@end iftex
@c -----------------------------------------------------
@node short, timer, printlevel, System variables
@subsection short
@cindex short
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
the output of monomials is done in the short manner,
if @code{short} is non-zero. A C-like notion is used, if short is zero.
Both notations may be used as input.
@*The default depends on the names of the ring variables
(0 if there are names of variables longer than 1 character, 1 otherwise). Every
change of the basering sets @code{short} to the proper default value for
that ring and overwrites the previous setting.
@item @strong{Example:}
@example
@c example
  ring r=23,x,dp;
  int save=short;
  short = 1;
  2x2,x2;
  short = 0;
  2x2,x2;
  short=save;//resets short to the previous value
@c example
@end example
@end table
@c -----------------------------------------------------
@node timer, TRACE var, short, System variables
@subsection timer
@cindex timer
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
@enumerate
@item
the CPU time (i.e, user and system time) used for each command is
printed if timer >0 , if this
time is bigger than a (customizable) minimal time and
if @code{printlevel+1 >= voice} (which is by default true on the
@sc{Singular} top level, but not true while procedures are executed).

@item
yields the used CPU time since the start-up of @sc{Singular} in a
(customizable) resolution.
@end enumerate

The default setting of @code{timer} is 0, the default minimal time is
0.5 seconds, and the default timer resolution is 1 (i.e., default unit
of time is one second). The minimal time and timer resolution
can be set using the command line options @code{--min-time} and
@code{--ticks-per-sec} and can be checked using
@code{system("--min-time")} and @code{system("--ticks-per-sec")}.

How to use @code{timer} in order to measure the time for a sequence of
commands, see example below.

@item @strong{Note for Windows95/98:}
The value of the @code{timer} can not be used (resp. trusted) when
@sc{Singular} is run under Windows95/98 (this is due to the shortcomings 
of the Windows95/98 operating system). Use @ref{rtimer}, instead.

@item @strong{Example:}
@example
@c example
  timer = 1; // The time of each command is printed
  int t=timer; // initialize t by timer
  ring r=0,(x,y,z),dp;
  poly p=(x+2y+3z+4xy+5xz+6yz)^20;
  // timer as int_expression:
  t = timer - t;
  t;  // yields the time in ticks-per-sec (default 1)
      // since t was initialized by timer
  execute "int tps=" + system("--ticks-per-sec");
  t/tps; // yields the time in seconds
@c example
@end example
@end table
@c ref
See
@ref{Command line options};
@ref{printlevel};
@ref{rtimer};
@ref{system};
@ref{voice}.
@c ref
@c ---------------------------------------
@node TRACE var, rtimer, timer, System variables
@subsection TRACE
@cindex TRACE

@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
sets level of debugging.
@table @asis
@item @code{TRACE=1}
messages about entering and leaving of procedures are displayed.
@item @code{TRACE=3}
messages about entering and leaving of procedures together with
line numbers are displayed.
@item @code{TRACE=4}
each line is echoed and the interpretation of commands
in this line is suspended until the user presses @code{RETURN}.
@end table
@*@code{TRACE} is defaulted to 0.
@*@code{TRACE} does not affect the output of commands.
@item @strong{Example:}
@example
@c example
  TRACE = 1;
  LIB "general.lib";
  sum(1..100);
@c example
@end example
@end table
@menu
* int::
@end menu
@iftex
See @ref{int}.
@end iftex
@c ---------------------------------------
@node rtimer, voice, TRACE var, System variables
@subsection rtimer
@cindex timer
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
identical to @code{timer} (@pxref{timer}), except that real times (i.e.,
wall-clock) times are reported, instead of CPU times. This can be
trusted on all operating systems (including Windows95/98).

@end table
@c ---------------------------------------
@node voice,, rtimer, System variables
@subsection voice
@cindex voice

@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
shows the nesting level of procedures.
@item @strong{Note:}
@xref{Guidelines for writing a library}, for an example how this is used
for the display of comments while procedures are executed.
@item @strong{Example:}
@example
@c example
  voice;
@c example
proc p
@{
  voice;
@}
@expansion{} 2
@end example
@end table
@menu
* dbprint::
* listvar::
* printlevel::
@end menu
@iftex
See @ref{dbprint}; @ref{listvar}; @ref{printlevel}.
@end iftex
@c ---------------------------------------
