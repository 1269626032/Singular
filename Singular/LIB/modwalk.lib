///////////////////////////////////////////////////////////////////////////////
version="version modwalk.lib 4.0.0.0 Jun_2013 ";
category = "Commutative Algebra";
info="
LIBRARY:  modwalk.lib      Groebner basis convertion

AUTHORS:  S. Oberfranz    oberfran@mathematik.uni-kl.de

OVERVIEW:

  A library for converting Groebner bases of an ideal in the polynomial
  ring over the rational numbers using modular methods. The procedures are
  inspired by the following paper:
  Elizabeth A. Arnold: Modular algorithms for computing Groebner bases.
  Journal of Symbolic Computation 35, 403-419 (2003).

PROCEDURES:

modWalk(I,#);                   standard basis conversion of I by Groebner Walk using modular methods
modrWalk(I,radius,pertdeg,#);   standard basis conversion of I by Random Walk using modular methods
modfWalk(I,#);                  standard basis conversion of I by Fractal Walk using modular methods
modfrWalk(I,radius,#);          standard basis conversion of I by Random Fractal Walk using modular methods
";

LIB "rwalk.lib";
LIB "grwalk.lib";
LIB "modular.lib";

proc modWalk(ideal I, list #)
"USAGE:   modWalk(I, [, v, w]); I ideal, v intvec, w intvec
RETURN:   a standard basis of I
NOTE:     The procedure computes a standard basis of I (over the rational
          numbers) by using modular methods.
SEE ALSO: modular
EXAMPLE:  example modWalk; shows an example"
{
    /* read optional parameter */
    if (size(#) > 0) {
        if (size(#) == 1) {
            intvec w = #[1];
        }
        if (size(#) == 2) {
            intvec v = #[1];
            intvec w = #[2];
        }
        if (size(#) > 2 || typeof(#[1]) != "intvec") {
            ERROR("wrong optional parameter");
        }
    }

    /* save options */
    intvec opt = option(get);
    option(redSB);

    /* call modular() */
    if (size(#) > 0) {
        I = modular("gwalk", list(I,#));
    }
    else {
        I = modular("gwalk", list(I));
    }

    /* return the result */
    attrib(I, "isSB", 1);
    option(set, opt);
    return(I);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R1 = 0, (x,y,z,t), dp;
    ideal I = 3x3+x2+1, 11y5+y3+2, 5z4+z2+4;
    I = std(I);
    ring R2 = 0, (x,y,z,t), lp;
    ideal I = fetch(R1, I);
    ideal J = modWalk(I);
    J;
}

proc modrWalk(ideal I, int radius, int pertdeg, list #)
"USAGE:   modrWalk(I, radius, pertdeg[, v, w]);
          I ideal, radius int, pertdeg int, v intvec, w intvec
RETURN:   a standard basis of I
NOTE:     The procedure computes a standard basis of I (over the rational
          numbers) by using modular methods.
SEE ALSO: modular
EXAMPLE:  example modrWalk; shows an example"
{
    /* read optional parameter */
    if (size(#) > 0) {
        if (size(#) == 1) {
            intvec w = #[1];
        }
        if (size(#) == 2) {
            intvec v = #[1];
            intvec w = #[2];
        }
        if (size(#) > 2 || typeof(#[1]) != "intvec") {
            ERROR("wrong optional parameter");
        }
    }

    /* save options */
    intvec opt = option(get);
    option(redSB);

    /* call modular() */
    if (size(#) > 0) {
        I = modular("rwalk", list(I,radius,pertdeg,#));
    }
    else {
        I = modular("rwalk", list(I,radius,pertdeg));
    }

    /* return the result */
    attrib(I, "isSB", 1);
    option(set, opt);
    return(I);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R1 = 0, (x,y,z,t), dp;
    ideal I = 3x3+x2+1, 11y5+y3+2, 5z4+z2+4;
    I = std(I);
    ring R2 = 0, (x,y,z,t), lp;
    ideal I = fetch(R1, I);
    int radius = 2;
    int pertdeg = 3;
    ideal J = modrWalk(I,radius,pertdeg);
    J;
}

proc modfWalk(ideal I, list #)
"USAGE:   modfWalk(I, [, v, w]); I ideal, v intvec, w intvec
RETURN:   a standard basis of I
NOTE:     The procedure computes a standard basis of I (over the rational
          numbers) by using modular methods.
SEE ALSO: modular
EXAMPLE:  example modfWalk; shows an example"
{
    /* read optional parameter */
    if (size(#) > 0) {
        if (size(#) == 1) {
            intvec w = #[1];
        }
        if (size(#) == 2) {
            intvec v = #[1];
            intvec w = #[2];
        }
        if (size(#) > 2 || typeof(#[1]) != "intvec") {
            ERROR("wrong optional parameter");
        }
    }

    /* save options */
    intvec opt = option(get);
    option(redSB);

    /* call modular() */
    if (size(#) > 0) {
        I = modular("fwalk", list(I,#));
    }
    else {
        I = modular("fwalk", list(I));
    }

    /* return the result */
    attrib(I, "isSB", 1);
    option(set, opt);
    return(I);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R1 = 0, (x,y,z,t), dp;
    ideal I = 3x3+x2+1, 11y5+y3+2, 5z4+z2+4;
    I = std(I);
    ring R2 = 0, (x,y,z,t), lp;
    ideal I = fetch(R1, I);
    ideal J = modfWalk(I);
    J;
}

proc modfrWalk(ideal I, int radius, list #)
"USAGE:   modfrWalk(I, radius [, v, w]); I ideal, radius int, v intvec, w intvec
RETURN:   a standard basis of I
NOTE:     The procedure computes a standard basis of I (over the rational
          numbers) by using modular methods.
SEE ALSO: modular
EXAMPLE:  example modfrWalk; shows an example"
{
    /* read optional parameter */
    if (size(#) > 0) {
        if (size(#) == 1) {
            intvec w = #[1];
        }
        if (size(#) == 2) {
            intvec v = #[1];
            intvec w = #[2];
        }
        if (size(#) > 2 || typeof(#[1]) != "intvec") {
            ERROR("wrong optional parameter");
        }
    }

    /* save options */
    intvec opt = option(get);
    option(redSB);

    /* call modular() */
    if (size(#) > 0) {
        I = modular("frandwalk", list(I,radius,#));
    }
    else {
        I = modular("frandwalk", list(I,radius));
    }

    /* return the result */
    attrib(I, "isSB", 1);
    option(set, opt);
    return(I);
}
example
{
    "EXAMPLE:";
    echo = 2;
    ring R1 = 0, (x,y,z,t), dp;
    ideal I = 3x3+x2+1, 11y5+y3+2, 5z4+z2+4;
    I = std(I);
    ring R2 = 0, (x,y,z,t), lp;
    ideal I = fetch(R1, I);
    int radius = 2;
    ideal J = modfrWalk(I,radius);
    J;
}