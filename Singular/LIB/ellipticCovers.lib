///////////////////////////////////////////////////////////////////////////////
version="$Id$";
category="Commutative Algebra";
info="
LIBRARY:  ellipticCovers.lib    Gromov Witten numbers of elliptic curves

AUTHORS:  J. Boehm, boehm @ mathematik.uni-kl.de
          A. Buchholz, buchholz @ math.uni-sb.de
          H. Markwig   hannah @ math.uni-sb.de

OVERVIEW:

KEYWORDS:

TYPES:

PROCEDURES:

";


LIB "parallel.lib";


proc mod_init()
{
newstruct("graph","list vertices, list edges");
newstruct("Net","list rows");

system("install","graph","print",printGraph,1);
system("install","Net","print",printNet,1);
system("install","Net","+",catNet,2);

}


proc max(int n, int m){
if (n>m){return(n);}
return(m);}


proc catNet(Net N, Net M)
{
list L;
list LN=N.rows;
list LM=M.rows;
int widthN=size(LN[1]);
int widthM=size(LM[1]);
int nm=max(size(LN),size(LM));
for (int j=1; j<=nm; j++)
{
    if (j>size(LN)){LN[j]=emptyString(widthN);}
    if (j>size(LM)){LM[j]=emptyString(widthM);}
    L[j]=LN[j]+LM[j];
}
Net NM;
NM.rows=L;
return(NM);}


proc netList(list L1)
{
  Net N=net("[");
  for (int j=1; j<=size(L1)-1; j++)
  {
     N=N+net(L1[j])+net(", ");
  }
  N=N+net(L1[size(L1)])+net("]");
  return(N);
}

proc printNet(Net N)
{
list L = N.rows;
for (int j=1; j<=size(L); j++)
{
   print(L[j]);
}
}

proc net(def M){
  if (typeof(M)=="list"){
    return(netList(M));
  }
  Net N;
  list L;
  L[1]=string(M);
  N.rows=L;
return(N);}



proc printGraph(graph G)
{
  print(netList(G.edges));
  print("Graph with "+string(size(G.vertices))+" vertices and "+string(size(G.edges))+" edges")
}



proc makeGraph(list v, list e)
{
  graph G;
  G.vertices = v;
  G.edges = e;
  return(G);
}


proc propagator(def xy, def d) 
{
  if ((typeof(xy)=="list")||(typeof(d)=="int")) {
    number x = xy[1];
    number y = xy[2];
    if (d<0) {ERROR("expected non-negative degree");}
    if (d==0) {return(x^2*y^2/(x^2-y^2)^2);}
    number p=0;
    for (int j=1; j<=d; j++){
       if (d%j==0){p=p+(j*x^(4*j)+j*y^(4*j))/(x*y)^(2*j);}
    }
    return(p);
  }
  if ((typeof(xy)=="graph")||(typeof(d)=="list"))  {
    list xl = ringlist(R)[1][2];
    list ed = xy.edges;
    number f=1;
    for (int j=1; j<=size(ed); j++){
       execute("number xx1 = "+xl[ed[j][1]]);
       execute("number xx2 = "+xl[ed[j][2]]);
       f=f*propagator(list(xx1,xx2),d[j]);
       kill xx1;
       kill xx2;
    }
    return(f);
  }
  if ((typeof(xy)=="graph")||(typeof(d)=="int"))  {
  }
ERROR("wrong input type");}

proc computeConstant(number f,number xx)
{
  int tst=0;
  number ff=f;
  int k;
  int j;
  poly de;
  while (tst==0){
     ff=f*xx^k;
     for (j=1; j<=k; j++){
        ff=diff(ff,xx)/j;
     }
  de = subst(denominator(ff),xx,0);
  if (de!=0){
     poly nu = subst(numerator(ff),xx,0);
     return(number(nu/de));
  }
  k=k+1;
  }
ERROR("error in computeConstant");}

proc evaluateIntegral(number P, list xL)
{
  number p = P;
  for(int j=1; j<=size(xL); j++){
     p=computeConstant(p,xL[j]);
  }
return(p);}


proc permute (list N)
{
   int i,j,k;
   list L,L1;
   if (size(N)==1){
     return(list(N));
   } else {
     k=1;
     for (i=1; i<=size(N); i++){
       L=permute(delete(N,i));
       for (j=1; j<=size(L); j++){
          L1[k]=L[j]+list(N[i]);
          k=k+1;
       }
     }
   }
return(L1);}

//permute(list(x1,x2,x3,x4));


proc partitions(int n, int a){
ring R = 2,(x(1..n)),dp;
ideal I = maxideal(a);
list L;
for (int j=1;j<=size(I);j++){
  L[j]=leadexp(I[j]);
}
return(L);}


proc gromovWitten(def P,list #)
{
  if (typeof(P)=="number") {
  list xl = ringlist(R)[1][2];
  int j;
  for(j=1; j<=size(xl); j++){
     execute("number n= "+xl[j]);
     xl[j]=n;
     kill n;
  }
  list pxl = permute(xl);
  number p = 0;
  for(j=1; j<=size(pxl); j++){
     p=p+evaluateIntegral(P,pxl[j]);
  }
  return(p);
  }
  if (typeof(P)=="graph"){
     int d =#[1];
     number s =0;
     number p;
     list pararg;
     list re;
     list pa = partitions(size(P.edges),d);
     int ti;
     for (int j=1; j<=size(pa); j++) {
       ti=timer;
       //pararg[j]=list(propagator(G,pa[j]));
       re[j]=gromovWitten(propagator(G,pa[j]));
       ti=timer-ti;
       print(string(j)+" / "+string(size(pa))+"    "+string(pa[j])+"     "+string(re[j])+"     "+string(ti));
     }
     //list re = parallelWaitAll("gromovWitten", pararg, list(list(list(2))));
     return(re);
  }
}

proc sum(list L){
  number s;
  for(int j=1; j<=size(L); j++){
     s=s+L[j];
  }
return(s);}



