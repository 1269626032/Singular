ring ESSring = create_ring(s3, "("+ varstr(basering)+")", "("+ ordstr(basering) +")");
    execute(minPolyStr);
    // basering has changed to ESSring

    ideal qIdeal = fetch(old_ring, qIdeal);
    if(qIdeal != 0)
    {
      def r_base = basering;
      kill ESSring;
      qring ESSring = std(qIdeal);
    }
    kill qIdeal;

    ideal SSS;
    for (int ii=1;ii<=nvars(basering);ii++)
    {
      SSS[ii+no_b]=var(ii);
    }
    map phi=myRing,SSS;   // b(i) variables are mapped to zero

    ideal ES=phi(J);
    ideal ES_all_triv=phi(Jtriv);
    kill phi;

    if (defined(p_F)<=0)
    {
      poly p_F=fetch(old_ring,p_F);
      export(p_F);
    }
    export(ES);
    export(ES_all_triv);
    setring old_ring;
    dbprint(i_print+2,"
// 'esStratum' created a list M of a ring and an integer.
// To access the ideal defining the equisingularity stratum, type:
        def ESSring = M[1]; setring ESSring;  ES; ");

    option(set,ov);
    return(list(ESSring,0));
  }
  else
  {
    // no new ring definition necessary
    ideal SSS;
    for (int ii=1;ii<=nvars(basering);ii++)
    {
      SSS[ii+no_b]=var(ii);
    }
    map phi=myRing,SSS;  // b(i) variables are mapped to zero

    ideal ES=phi(J);
    ideal ES_all_triv=phi(Jtriv);
    kill phi;

    setring old_ring;
    dbprint(i_print,"// output of 'esStratum' is a list consisting of:
//    _[1][1] = ideal defining the equisingularity stratum
//    _[1][2] = ideal defining the part of the equisingularity stratum
//              where all equimultiple sections are trivial
//    _[2] = 0");

    option(set,ov);
    return(list(list(ES,ES_all_triv),0));
  }

}

////////////////////////////////////////////////////////////////////////////////

proc tau_es (poly f,list #)
"USAGE:   tau_es(f); f poly
ASSUME:  f is a reduced bivariate polynomial, the basering has precisely
         two variables, is local and no qring.
RETURN:  int, the codimension of the mu-const stratum in the semi-universal
         deformation base.
NOTE:    printlevel>=1 displays additional information.
         When called with any additional parameter, the computation of the
         Milnor number is avoided (no check for NND).
SEE ALSO: esIdeal, tjurina, invariants
EXAMPLE: example tau_es; shows an example.
"
{
  int i,j,k,s;
  int slope_x, slope_y, upper;
  int i_print = printlevel - voice + 3;
  string MinPolyStr;

  // some checks first
  if ( nvars(basering)<>2 )
  {
    print("// basering has not the correct number (two) of variables !");
    print("// computation stopped");
    return(0);
  }
  if ( mult(std(1+var(1)+var(2))) <> 0)
  {
    print("// basering is not local !");
    print("// computation stopped");
    return(0);
  }

  if (mult(std(f))<=1)
  {
    // f is rigid
    return(0);
  }

  if ( deg(squarefree(f))!=deg(f) )
  {
    print("// input polynomial was not reduced");
    print("// try    squarefree(f);   first");
    return(0);
  }

  def old_ring=basering;
  ring @myRing = create_ring(ringlist(basering)[1], "("+varstr(basering)+")", "ds", "no_minpoly");
  poly f=imap(old_ring,f);

  ideal Jacobi_Id = jacob(f);

  // check for A_k singularity
  // ----------------------------------------
  if (mult(std(f))==2)
  {
    dbprint(i_print-1,"// ");
    dbprint(i_print-1,"// polynomial defined A_k singularity");
    dbprint(i_print-1,"// ");
    return( vdim(std(Jacobi_Id)) );
  }

  // check for D_k singularity
  // ----------------------------------------
  if (mult(std(f))==3 and size(factorize(jet(f,3))[1])>=3)
  {
    dbprint(i_print,"// ");
    dbprint(i_print,"// polynomial defined D_k singularity");
    dbprint(i_print,"// ");
    ideal ES_Id = f, jacob(f);
    return( vdim(std(Jacobi_Id)));
  }


  if (size(#)==0)
  {
    // check if Newton polygon non-degenerate
    // ----------------------------------------
    Jacobi_Id=std(Jacobi_Id);
    int mu = vdim(Jacobi_Id);
    poly f_tilde=f+var(1)^mu+var(2)^mu;  //to obtain convenient Newton-polygon

    list NP=newtonpoly(f_tilde);
    dbprint(i_print-1,"// Newton polygon:");
    dbprint(i_print-1,NP);
    dbprint(i_print-1,"");

    if(is_NND(f,mu,NP))          // f is Newton non-degenerate
    {
      upper=NP[1][2];
      ideal ES_Id= x^k*y^upper;
      dbprint(i_print-1,"polynomial is Newton non-degenerate");
      dbprint(i_print-1,"");
      k=0;
      for (i=1;i<=size(NP)-1;i++)
      {
        slope_x=NP[i+1][1]-NP[i][1];
        slope_y=NP[i][2]-NP[i+1][2];
        for (k=NP[i][1]+1; k<=NP[i+1][1]; k++)
        {
          while ( slope_x*upper + slope_y*k >=
                  slope_x*NP[i][2] + slope_y*NP[i][1])
          {
            upper=upper-1;
          }
          upper=upper+1;
          ES_Id=ES_Id, x^k*y^upper;
        }
      }
      ES_Id=std(ES_Id);
      dbprint(i_print-2,"ideal of monomials above Newton bd. is generated by:");
      dbprint(i_print-2,ES_Id);
      ideal ESfix_Id = ES_Id, f, maxideal(1)*jacob(f);
      ES_Id = ES_Id, Jacobi_Id;
      ES_Id = std(ES_Id);
      dbprint(i_print-1,"// ");
      dbprint(i_print-1,"// Equisingularity ideal is computed!");
      dbprint(i_print-1,"");
      return(vdim(ES_Id));
    }
    else
    {
      dbprint(i_print-1,"polynomial is Newton degenerate !");
      dbprint(i_print-1,"");
    }
  }

  // for Newton degenerate polynomials, we compute the HN expansion, and
  // count the number of free points .....

  dbprint(i_print-1,"// ");
  dbprint(i_print-1,"// Compute HN expansion");
  dbprint(i_print-1,"// ---------------------");
  i=printlevel;
  printlevel=printlevel-5;
  if (2*size(coeffs(f,x))<size(coeffs(f,y)))
  {
    f=swapXY(f);
  }
  list LLL=hnexpansion(f);
  if (size(LLL)==0) { // empty list returned by hnexpansion
    setring old_ring;
    ERROR("Unable to compute HN expansion !");
  }
  else
  {
    if (typeof(LLL[1])=="ring") {
      def HNering = LLL[1];
      setring HNering;
      def @L=hne;
    }
    else {
      def @L=LLL;
    }
  }
  def HNEring=basering;

  printlevel=i;
  dbprint(i_print-1,"// finished");
  dbprint(i_print-1,"// ");

  list M=multsequence(@L);
  M=control_Matrix(M);     // this returns the 4 control matrices
  intmat Mult=M[1];

  list L1=inf_Tangents(@L,nrows(M[1]));
  matrix B=L1[1];

  // determine sum_i m_i(m_i+1)/2 (over inf. near points)
  int conditions=0;
  for (i=1;i<=nrows(Mult);i++)
  {
    for (j=1;j<=ncols(Mult);j++)
    {
      conditions=conditions+(Mult[i,j]*(Mult[i,j]+1) div 2);
    }
  }
  int freePts=no_freePoints(M[1],B);
  int taues=conditions-freePts-2;

  setring old_ring;
  return(taues);
}
example
{
   "EXAMPLE:"; echo=2;
   ring r=32003,(x,y),ds;
   poly f=(x4-y4)^2-x10;
   tau_es(f);
}


////////////////////////////////////////////////////////////////////////////////

proc esIdeal (poly f,list #)
"USAGE:   esIdeal(f[,any]]); f poly
ASSUME:  f is a reduced bivariate polynomial, the basering has precisely
         two variables, is local and no qring, and the characteristic of
         the ground field does not divide mult(f).
RETURN:  if called with only one parameter: list of two ideals,
@format
          _[1]:  equisingularity ideal of f (in sense of Wahl),
          _[2]:  ideal of equisingularity with fixed position of the
                 singularity;
@end format
         if called with more than one parameter: list of three ideals,
@format
          _[1]:  equisingularity ideal of f (in sense of Wahl)
          _[2]:  ideal of equisingularity with fixed position of the
                 singularity;
          _[3]:  ideal of all g such that the deformation defined by f+eg
                 (e^2=0) is isomorphic to an equisingular deformation
                 of V(f) with all equimultiple sections being trivial.
@end format
NOTE:    if some of the above condition is not satisfied then return
         value is list(0,0).
SEE ALSO: tau_es, esStratum
KEYWORDS: equisingularity ideal
EXAMPLE: example esIdeal; shows examples.
"
{

  int typ;
  if (size(#)>0) { typ=1; }   // I^s is also computed
  int i,k,s;
  int slope_x, slope_y, upper;
  int i_print = printlevel - voice + 3;
  string MinPolyStr;

  // some checks first
  if ( nvars(basering)<>2 )
  {
    print("// basering has not the correct number (two) of variables !");
    print("// computation stopped");
    return(list(0,0));
  }
  if ( mult(std(1+var(1)+var(2))) <> 0)
  {
    print("// basering is not local !");
    print("// computation stopped");
    return(list(0,0));
  }

  if (mult(std(f))<=1)
  {
    // f is rigid
    if (typ==0)
    {
      return(list(ideal(1),ideal(1)));
    }
    else
    {
      return(list(ideal(1),ideal(1),ideal(1)));
    }
  }

  if ( deg(squarefree(f))!=deg(f) )
  {
    print("// input polynomial was not squarefree");
    print("// try    squarefree(f);   first");
    return(list(0,0));
  }

  if (char(basering)<>0)
  {
    if (mult(std(f)) mod char(basering)==0)
    {
      print("// characteristic of ground field divides "
            + "multiplicity of polynomial !");
      print("// computation stopped");
      return(list(0,0));
    }
  }

  // check for A_k singularity
  // ----------------------------------------
  if (mult(std(f))==2)
  {
    dbprint(i_print,"// ");
    dbprint(i_print,"// polynomial defined A_k singularity");
    dbprint(i_print,"// ");
    ideal ES_Id = f, jacob(f);
    ES_Id = interred(ES_Id);
    ideal ESfix_Id = f, maxideal(1)*jacob(f);
    ESfix_Id= interred(ESfix_Id);
    if (typ==0) // only for computation of I^es and I^es_fix
    {
      return( list(ES_Id,ESfix_Id) );
    }
    else
    {
      return( list(ES_Id,ESfix_Id,ES_Id) );
    }
  }

  // check for D_k singularity
  // ----------------------------------------
  if (mult(std(f))==3 and size(factorize(jet(f,3))[1])>=3)
  {
    dbprint(i_print,"// ");
    dbprint(i_print,"// polynomial defined D_k singularity");
    dbprint(i_print,"// ");
    ideal ES_Id = f, jacob(f);
    ES_Id = interred(ES_Id);
    ideal ESfix_Id = f, maxideal(1)*jacob(f);
    ESfix_Id= interred(ESfix_Id);
    if (typ==0) // only for computation of I^es and I^es_fix
    {
      return( list(ES_Id,ESfix_Id) );
    }
    else
    {
      return( list(ES_Id,ESfix_Id,ES_Id) );
    }
  }

  // check if Newton polygon non-degenerate
  // ----------------------------------------
  int mu = milnor(f);
  poly f_tilde=f+var(1)^mu+var(2)^mu;  //to obtain a convenient Newton-polygon

  list NP=newtonpoly(f_tilde);
  dbprint(i_print-1,"// Newton polygon:");
  dbprint(i_print-1,NP);
  dbprint(i_print-1,"");

  if(is_NND(f,mu,NP))          // f is Newton non-degenerate
  {
    upper=NP[1][2];
    ideal ES_Id= x^k*y^upper;
    dbprint(i_print,"polynomial is Newton non-degenerate");
    dbprint(i_print,"");
    k=0;
    for (i=1;i<=size(NP)-1;i++)
    {
      slope_x=NP[i+1][1]-NP[i][1];
      slope_y=NP[i][2]-NP[i+1][2];
      for (k=NP[i][1]+1; k<=NP[i+1][1]; k++)
      {
        while ( slope_x*upper + slope_y*k >=
                slope_x*NP[i][2] + slope_y*NP[i][1])
        {
          upper=upper-1;
        }
        upper=upper+1;
        ES_Id=ES_Id, x^k*y^upper;
      }
    }
    ES_Id=std(ES_Id);
    dbprint(i_print-1,"ideal of monomials above Newton bd. is generated by:");
    dbprint(i_print-1,ES_Id);
    ideal ESfix_Id = ES_Id, f, maxideal(1)*jacob(f);
    ES_Id = ES_Id, f, jacob(f);
    dbprint(i_print,"// ");
    dbprint(i_print,"// equisingularity ideal is computed!");
    if (typ==0)
    {
      return(list(ES_Id,ESfix_Id));
    }
    else
    {
      return(list(ES_Id,ESfix_Id,ES_Id));
    }
  }
  else
  {
    dbprint(i_print,"polynomial is Newton degenerate !");
    dbprint(i_print,"");
  }

  def old_ring=basering;

  dbprint(i_print,"// ");
  dbprint(i_print,"// versal deformation with triv. section");
  dbprint(i_print,"// =====================================");
  dbprint(i_print,"// ");

  ideal JJ=maxideal(1)*jacob(f);
  ideal kbase_versal=kbase(std(JJ));
  s=size(kbase_versal);
  string ring_versal="ring @Px = ("+charstr(basering)+"),(t(1.."+string(s)+"),"
                        +varstr(basering)+"),(ds("+string(s)+"),"
                        +ordstr(basering)+");";
  MinPolyStr = string(minpoly);

  execute(ring_versal);
  if (MinPolyStr<>"0")
  {
    MinPolyStr = "minpoly="+MinPolyStr;
    execute(MinPolyStr);
  }
  // basering has changed to @Px

  poly F=imap(old_ring,f);
  ideal kbase_versal=imap(old_ring,kbase_versal);
  for (i=1; i<=s; i++)
  {
    F=F+var(i)*kbase_versal[i];
  }
  dbprint(i_print-1,F);
  dbprint(i_print-1,"");


  ideal ES_Id,ES_Id_all_triv;
  poly Ftriv=F;

  dbprint(i_print,"// ");
  dbprint(i_print,"// Compute equisingularity Stratum over Spec(C[t]/t^2)");
  dbprint(i_print,"// ===================================================");
  dbprint(i_print,"// ");
  list M=esStratum(F,2);
  dbprint(i_print,"// finished");
  dbprint(i_print,"// ");

  if (M[2]==1) // error occurred during esStratum computation
  {
    print("Some error has occurred during the computation");
    return(list(0,0));
  }

  if ( typeof(M[1])=="list" )
  {
    int defpars = nvars(basering)-2;
    poly Fred,Ftrivred;
    poly g;
    F=reduce(F,std(M[1][1]));
    Ftriv=reduce(Ftriv,std(M[1][2]));

    for (i=1; i<=defpars; i++)
    {
      Fred=reduce(F,std(var(i)));
      Ftrivred=reduce(Ftriv,std(var(i)));

      g=subst(F-Fred,var(i),1);
      ES_Id=ES_Id, g;
      F=Fred;

      g=subst(Ftriv-Ftrivred,var(i),1);
      ES_Id_all_triv=ES_Id_all_triv, g;
      Ftriv=Ftrivred;
    }

    setring old_ring;
    // back to original ring

    ideal ES_Id = imap(@Px,ES_Id);
    ES_Id = interred(ES_Id);

    ideal ES_Id_all_triv = imap(@Px,ES_Id_all_triv);
    ES_Id_all_triv = interred(ES_Id_all_triv);

    ideal ESfix_Id = ES_Id, f, maxideal(1)*jacob(f);
    ES_Id = ES_Id, f, jacob(f);
    ES_Id_all_triv = ES_Id_all_triv, f, jacob(f);

    if (typ==0)
    {
      return(list(ES_Id,ESfix_Id));
    }
    else
    {
      return(list(ES_Id,ESfix_Id,ES_Id_all_triv));
    }
  }
  else
  {
    def AuxRing=M[1];

    dbprint(i_print,"// ");
    dbprint(i_print,"// change ring to ESSring");

    setring AuxRing;  // contains p_F, ES

    int defpars = nvars(basering)-2;
    poly Fred,Fredtriv;
    poly g;
    ideal ES_Id,ES_Id_all_triv;

    poly p_Ftriv=p_F;

    p_F=reduce(p_F,std(ES));
    p_Ftriv=reduce(p_Ftriv,std(ES_all_triv));
    for (i=1; i<=defpars; i++)
    {
      Fred=reduce(p_F,std(var(i)));
      Fredtriv=reduce(p_Ftriv,std(var(i)));

      g=subst(p_F-Fred,var(i),1);
      ES_Id=ES_Id, g;
      p_F=Fred;

      g=subst(p_Ftriv-Fredtriv,var(i),1);
      ES_Id_all_triv=ES_Id_all_triv, g;
      p_Ftriv=Fredtriv;

    }

    dbprint(i_print,"// ");
    dbprint(i_print,"// back to the original ring");

    setring old_ring;
    // back to original ring

    ideal ES_Id = imap(AuxRing,ES_Id);
    ES_Id = interred(ES_Id);

    ideal ES_Id_all_triv = imap(AuxRing,ES_Id_all_triv);
    ES_Id_all_triv = interred(ES_Id_all_triv);

    kill @Px;
    kill AuxRing;

    ideal ESfix_Id = ES_Id, f, maxideal(1)*jacob(f);
    ES_Id = ES_Id, f, jacob(f);
    ES_Id_all_triv = ES_Id_all_triv, f, jacob(f);
    dbprint(i_print,"// ");
    dbprint(i_print,"// equisingularity ideal is computed!");
    if (typ==0)
    {
      return(list(ES_Id,ESfix_Id));
    }
    else
    {
      return(list(ES_Id,ESfix_Id,ES_Id_all_triv));
    }
  }
}
example
{
  "EXAMPLE:"; echo=2;
  ring r=0,(x,y),ds;
  poly f=x7+y7+(x-y)^2*x2y2;
  list K=esIdeal(f);
  option(redSB);
  // Wahl's equisingularity ideal:
  std(K[1]);

  ring rr=0,(x,y),ds;
  poly f=x4+4x3y+6x2y2+4xy3+y4+2x2y15+4xy16+2y17+xy23+y24+y30+y31;
  list K=esIdeal(f);
  vdim(std(K[1]));
  // the latter should be equal to:
  tau_es(f);
}

///////////////////////////////////////////////////////////////////////////////

proc esStratum (poly p_F, list #)
"USAGE:   esStratum(F[,m,L]); F poly, m int, L list
ASSUME:  F defines a deformation of a reduced bivariate polynomial f
         and the characteristic of the basering does not divide mult(f). @*
         If nv is the number of variables of the basering, then the first
         nv-2 variables are the deformation parameters. @*
         If the basering is a qring, ideal(basering) must only depend
         on the deformation parameters.
COMPUTE: equations for the stratum of equisingular deformations with
         fixed (trivial) section.
RETURN:  list l: either consisting of a list and an integer, where
@format
  l[1][1]=ideal defining the equisingularity stratum
  l[1][2]=ideal defining the part of the equisingularity stratum where all
          equimultiple sections through the non-nodes of the reduced total
          transform are trivial sections
  l[2]=1 if some error has occurred,  l[2]=0 otherwise;
@end format
or consisting of a ring and an integer, where
@format
  l[1]=ESSring is a ring extension of basering containing the ideal ES
        (describing the ES-stratum), the ideal ES_all_triv (describing the
        part with trival equimultiple sections) and the polynomial p_F=F,
  l[2]=1 if some error has occurred,  l[2]=0 otherwise.
@end format
NOTE:    L is supposed to be the output of hnexpansion (with the given ordering
         of the variables appearing in f). @*
         If m is given, the ES Stratum over A/maxideal(m) is computed. @*
         This procedure uses @code{execute} or calls a procedure using
         @code{execute}.
         printlevel>=2 displays additional information.
SEE ALSO: esIdeal, isEquising
KEYWORDS: equisingularity stratum
EXAMPLE: example esStratum; shows examples.
"
{
  list l=esComputation (0,p_F,#);
  return(l);
}
example
{
   "EXAMPLE:"; echo=2;
   int p=printlevel;
   printlevel=1;
   ring r = 0,(a,b,c,d,e,f,g,x,y),ds;
   poly F = (x2+2xy+y2+x5)+ax+by+cx2+dxy+ey2+fx3+gx4;
   list M = esStratum(F);
   M[1][1];

   printlevel=3;     // displays additional information
   esStratum(F,2)  ; // ES-stratum over Q[a,b,c,d,e,f,g] / <a,b,c,d,e,f,g>^2

   ideal I = f-fa,e+b;
   qring q = std(I);
   poly F = imap(r,F);
   esStratum(F);
   printlevel=p;
}

///////////////////////////////////////////////////////////////////////////////

proc isEquising (poly p_F, list #)
"USAGE:   isEquising(F[,m,L]); F poly, m int, L list
ASSUME:  F defines a deformation of a reduced bivariate polynomial f
         and the characteristic of the basering does not divide mult(f). @*
         If nv is the number of variables of the basering, then the first
         nv-2 variables are the deformation parameters. @*
         If the basering is a qring, ideal(basering) must only depend
         on the deformation parameters.
COMPUTE: tests if the given family is equisingular along the trivial
         section.
RETURN:  int: 1 if the family is equisingular, 0 otherwise.
NOTE:    L is supposed to be the output of hnexpansion (with the given ordering
         of the variables appearing in f). @*
         If m is given, the family is considered over A/maxideal(m). @*
         This procedure uses @code{execute} or calls a procedure using
         @code{execute}.
         printlevel>=2 displays additional information.
EXAMPLE: example isEquising; shows examples.
"
{
  int check=esComputation (1,p_F,#);
  return(check);
}
example
{
   "EXAMPLE:"; echo=2;
   ring r = 0,(a,b,x,y),ds;
   poly F = (x2+2xy+y2+x5)+ay3+bx5;
   isEquising(F);
   ideal I = ideal(a);
   qring q = std(I);
   poly F = imap(r,F);
   isEquising(F);

   ring rr=0,(A,B,C,x,y),ls;
   poly f=x7+y7+(x-y)^2*x2y2;
   poly F=f+A*y*diff(f,x)+B*x*diff(f,x);
   isEquising(F);
   isEquising(F,2);    // computation over  Q[a,b] / <a,b>^2
}



/*  Examples:

LIB "equising.lib";
ring r = 0,(x,y),ds;
poly p1 = y^2+x^3;
poly p2 = p1^2+x5y;
poly p3 = p2^2+x^10*p1;
poly p=p3^2+x^20*p2;
p;
list L=versal(p);
def Px=L[1];
setring Px;
poly F=Fs[1,1];
int t=timer;
list M=esStratum(F);
timer-t;  //-> 3

LIB "equising.lib";
option(prot);
printlevel=2;
ring r=0,(x,y),ds;
poly f=(x-yx+y2)^2-(y+x)^31;
list L=versal(f);
def Px=L[1];
setring Px;
poly F=Fs[1,1];
int t=timer;
list M=esStratum(F);
timer-t;  //-> 233

LIB "equising.lib";
printlevel=2;
option(prot);
timer=1;
ring r=0,(x,y),ls;
poly f=(x4-y4)^2-x10;
list L=versal(f);
def Px=L[1];
setring Px;
poly F=Fs[1,1];
int t=timer;
list M=esStratum(F,3);
timer-t;  //-> 8

LIB "equising.lib";
printlevel=2;
timer=1;
ring rr=0,(x,y),ls;
poly f=x7+y7+(x-y)^2*x2y2;
list K=esIdeal(f);
// tau_es
vdim(std(K[1])); //-> 22
// tau_es_fix
vdim(std(K[2])); //-> 24

LIB "equising.lib";
printlevel=2;
timer=1;
ring rr=0,(x,y),ls;
poly f=x7+y7+(x-y)^2*x2y2+x2y4; // Newton non-deg.
list K=esIdeal(f);
// tau_es
vdim(std(K[1])); //-> 21
// tau_es_fix
vdim(std(K[2])); //-> 23

LIB "equising.lib";
ring r=0,(w,v),ds;
poly f=w2-v199;
list L=hnexpansion(f);
list LL=versal(f);
def Px=LL[1];
setring Px;
list L=imap(r,L);
poly F=Fs[1,1];
list M=esStratum(F,2,L);

LIB "equising.lib";
printlevel=2;
timer=1;
ring rr=0,(A,B,C,x,y),ls;
poly f=x7+y7+(x-y)^2*x2y2;
poly F=f+A*y*diff(f,x)+B*x*diff(f,x)+C*diff(f,y);
list M=esStratum(F,6);
std(M[1][1]);  // standard basis of equisingularity ideal

LIB "equising.lib";
printlevel=2;
timer=1;
ring rr=0,(x,y),ls;
poly f=x20+y7+(x-y)^2*x2y2+x2y4; // Newton non-degenerate
list K=esIdeal(f);
K;

ring rr=0,(x,y),ls;
poly f=x6y-3x4y4-x4y5+3x2y7-x4y6+2x2y8-y10+2x2y9-y11+x2y10-y12-y13;
list K=esIdeal(f);
list L=versal(f);
def Px=L[1];
setring Px;
poly F=Fs[1,1];
list M=esStratum(F,2);

LIB "equising.lib";
ring R=0,(A,B,C,D,x,y),ds;
poly f=x6y-3x4y4-x4y5+3x2y7-x4y6+2x2y8-y10+2x2y9-y11+x2y10-y12-y13;
poly F=f+Ax9+Bx7y2+Cx9y+Dx8y2;
list M=esStratum(F,2);

LIB "equising.lib";
printlevel=2;
ring rr=0,(x,y),ls;
poly f=x6y-3x4y4-x4y5+3x2y7-x4y6+2x2y8-y10+2x2y9-y11+x2y10-y12-y13;
list K=esIdeal(f);
vdim(std(K[1]));  //-> 51
tau_es(f);        //-> 51

printlevel=3;
f=f*(y-x2)*(y2-x3)*(x-y5);
int t=timer;
list L=esIdeal(f);
vdim(std(L[1]));  //-> 99
timer-t;   //-> 42
t=timer;
tau_es(f);        //-> 99
timer-t;   //-> 23

LIB "equising.lib";
printlevel=3;
ring rr=0,(x,y),ds;
poly f=x4+4x3y+6x2y2+4xy3+y4+2x2y15+4xy16+2y17+xy23+y24+y30+y31;
list K=esIdeal(f);
vdim(std(K[1]));  //-> 68
tau_es(f);        //-> 68

list L=versal(f);
def Px=L[1];
setring Px;
poly F=Fs[1,1];
list M=esStratum(F);
timer-t;          //-> 0

*/
