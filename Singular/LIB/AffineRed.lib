////////////////////////////////////////////////////////////////////
version="$Id$";
category="Algebraic Geometry";
// summary description of the library
info="
LIBRARY:   AffineRed.lib  A library for Singular which constructs [J,m]-Marked Schemes via affine reduction

AUTHOR:    Michela Ceria, email: michela.ceria@unito.it

SEE ALSO:  JMBTest.lib, JMSConst.lib

KEYWORDS:  J-marked schemes, Borel ideals

OVERVIEW:
The library performs the [J,m]-marked scheme computation,
as described in [BCR]. In this case, the given ideals are
no more required to be homogeneous.


The algorithm works correctly only if the ordering of
 the base ring is rp.

REFERENCES:
[BCR] Cristina Bertone, Francesca Cioffi,
Margherita Roggero,  A division algorithm in an affine
 framework for flat families covering Hilbert schemes @*
[BCLR] Cristina Bertone, Francesca Cioffi,Paolo Lella,
Margherita Roggero, Upgraded methods for the effective
computation of marked schemes on a strongly stable ideal,
Journal of Symbolic Computation
(2012), http://dx.doi.org/10.1016/j.jsc.2012.07.006 @*


PROCEDURES:
AffMarkedScheme(ideal, int,r)   given a strongly stable
 ideal J and an integer m it computes the equations of
the associated [J,m]-marked scheme
";
LIB "JMSConst.lib";
LIB "central.lib";
////////////////////////////////////////////////////////////////////
proc OrdinaBorel(ideal Borid,r)
"USAGE:   OrdinaBorel(Borid,r); Borid ideal, r ring
RETURN:   list: R
NOTE:     Input must be the monomial basis of a strongly
 stable monomial ideal.
EXAMPLE:  example OrdinaBorel; shows an example"
{
 Borid=sort(Borid,"dp(nvars(r)),C")[1];
//arrange terms by degree
//Divide in lists according to the degree of the involved terms
print(Borid);
print(size(Borid));
print(Borid[size(Borid)]);
int d=deg(Borid[1]);
int D=deg(Borid[size(Borid)]);
//we have D lists contained in L
list L;
//construct the lists
int i;
for(i=d;i<=D;i++)
   {
    L[i]=list();//as many lists as the possible degrees
   }
for(i=1;i<=size(Borid);i++)
   {
    L[deg(Borid[i])][size(  L[deg(Borid[i])] )+1]=Borid[i];
   }
list R=L,d,D;
return(R);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
OrdinaBorel(Borid,r);
}
/////////////////////////////////////////////////////////////////////
proc FindEmZero(list L, int m,int d,r)
"USAGE:   FindEmZero(L,m,d,r); L list, m int , d int, r ring
RETURN:   int: m0
NOTE:     Input is constituted by the list containing a
 strongly stable ideal arranged by degree, the given
 integer m, the minimal degree of generators d and the
 base ring r.
EXAMPLE:  example FindEmZero; shows an example"
{
int m0=-1;//optimized level emzero:  default -1
//From m+1 to 1
int j;
int Inizio=Min(list(m+1, size(L)));
for(j=Inizio;j>=d;j--)//I search till I reach the minimal degree
   {
    if(Cerca(L[j],r)==1)
      {
       m0=j-1;//Found: I break here
       break;
      }
   }
return(m0);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=z^2,yz,y^4;
 ideal I=std(Borid);//I is the standard basis of Borid
 list R=OrdinaBorel(I,r);//This way I get L,d,D
 int d=R[2];   //Minimal degree for the elements in Borid
 int D=R[3]; //Maximal degree for the elements in Borid
 int n=nvars(r); //number of variables in the ring
 int m0=FindEmZero(R[1], 5, d,r);//Optimized level
m0;
}
////////////////////////////////////////////////////////////////////
proc Cerca(list M, r)
"USAGE:   Cerca(M, r); M list, r ring
RETURN:   int: m0
NOTE:     Input is constituted by a list containing
 terms and the procedure looks for multiples of var(1)
EXAMPLE:  example Cerca; shows an example"
{
int flag=0;//inizialmente non trovo
//identifichiamo la variabile minima.
poly min=var(1); //di cui cerco multipli
int i;
for(i=1;i<=size(M); i++)
   {
    if(M[i]/min!=0)
      {
      flag=1;
      break;
      }
   }
return(flag);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
list H=yz^2,x^3;
Cerca(H,r);
}
////////////////////////////////////////////////////////////////////
proc ContaParametri(ideal Borid,list L, int m0, int  mind, int D)
"USAGE:    ContaParametri(Borid, L, m0, mind, D); Borid ideal, L list, m0 int, mind int, D int
RETURN:   list: Risu
NOTE:     The procedure counts the number of new
 parameters to be added.
EXAMPLE:  example ContaParametri; shows an example"
{
list Risu;//collects the final results
int qc;//Number of parameters
int mmax=Max(list(m0,D)); //maximal degree for the escalier
int i;
list Spartizioni;
ideal SottoS;
int g;
list N=poly(1);//Contains the Groebner escalier
int appoggio;
int i;
if(m0<=0)
 {
   print("m0 negative or zero");
  for(i=1;i<=mmax;i++)
      {
       SottoS=kbase(Borid,i);
              if(size(SottoS)!=0){
           N=N+list(SottoS[1..size(SottoS)]);  }
       print(N);
       if(i>=mind)
            {
              print("Degree corresponds");
              if(size(L[i])!=0)
              {
               print("Nonempty list");
               Spartizioni[i]=size(N);
               print(Spartizioni);
               qc=qc+size(L[i])*size(N);
              }
            }
      }
 }
else
 {
  print("positive m0");
  if(mind<=m0)
     {
      print("m0 in the middle");
      for(i=1;i<=m0;i++)
         {
           SottoS=kbase(Borid,i);
       if(size(SottoS)!=0){
           N=N+list(SottoS[1..size(SottoS)]);  }
           print(N);
           if(i>=mind)
             {
               g=g+size(L[i]);
             }
         }
       qc=size(N)*g;
       Spartizioni[1]=size(N);
       print("lesser or equal to m0");
       print(Spartizioni);
         for(i=m0+1;i<=mmax;i++)
             {
             SottoS=kbase(Borid,i);
       if(size(SottoS)!=0){
           N=N+list(SottoS[1..size(SottoS)]);  }
             print(N);
               if(size(L[i])!=0)
                 {
                   print("positive and nonempty list");
                   Spartizioni[i]=size(N);
                   print(Spartizioni);
                   qc=qc+size(L[i])*size(N);
                 }
            }
     }
  else
     {
      for(i=1;i<=mmax;i++)
      {
       SottoS=kbase(Borid,i);
       if(size(SottoS)!=0){
           N=N+list(SottoS[1..size(SottoS)]);  }
       print(N);
       if(i>=mind)
            {
              if(size(L[i])!=0)
              {
               Spartizioni[i]=size(N);
               qc=qc+size(L[i])*size(N);
              }
            }
      }
     }
 }
Risu=N,qc,Spartizioni;
return(Risu);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
  ideal Borid=y^2*z,y*z^2,z^3,y^5;
  ideal I=std(Borid);
   list R=OrdinaBorel(I,r);
   int d=R[2];
   int D=R[3];
   int n=nvars(r);
   int m=6;
   int m0=FindEmZero(R[1], m, d,r);
   list Risu=ContaParametri(I,R[1], m0,d,D);
}
////////////////////////////////////////////////////////////////////
proc ListaJMP(ideal Borid, list Risu, int m0)
"USAGE:  ListaJMP(Borid, Risu, m0); Borid ideal, Risu list, m0 int
RETURN:   list: G
NOTE:     The procedure constructs the list of jmp
 we use to reduce
EXAMPLE:  example ListaJMP; shows an example"
{
list G; //collects the results, ordered w.r.t. lex
int i;
int j;
jmp p;
int d;
poly coda;
int arrivo=0;
for(j=1;j<=size(Borid);j++)
   {
    d=deg(Borid[j]);
    coda=0;
     if(d<=m0)
       {
        for(i=1;i<=Risu[3][1];i++)
           {
            coda=coda+Risu[1][i]*c(arrivo+1);
            arrivo++;
           }
       }
    else
       {
        for(i=1;i<=Risu[3][d];i++)
           {
            coda=coda+Risu[1][i]*c(arrivo+1);
            arrivo++;
           }
       }
print("POLYNOMIAL:");
    p.h=Borid[j];
print(p.h);
    p.t=-coda;
print(p.t);
G[j]=p;
   }
return(G);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
ideal I=std(Borid);
   list R=OrdinaBorel(I,r);
   int d=R[2];
   int D=R[3];
   int n=nvars(r);
   int m=6;
   int m0=FindEmZero(R[1], m, d,r);
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
}
////////////////////////////////////////////////////////////////////
proc Multipli(Ld,r)//Double-type input!
"USAGE:   Multipli(Ld,r); Ld ideal/list, r ring
RETURN:   ideal: J
NOTE:     Input  Ld can be a list or an ideal
EXAMPLE:  example Multipli; shows an example"
{
ideal J;//Contains the results
int n=nvars(r);
int i;
int j;
for(i=1;i<=size(Ld);i++)
    {
       for(j=1;j<=n;j++)
       {
         J=J+ideal(var(j)*Ld[i]);
       }
    }
return(J);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal I=y^2*z,y*z^2,z^3,y^5;
Multipli(I,r);
}
////////////////////////////////////////////////////////////////////
proc GeneraMultipli(list L, int m, int d)
"USAGE:   Cerca(M, r); M list, r ring
RETURN:   list: R
NOTE:     Input is constituted by a list containing
 terms and the procedure looks for multiples of var(1)
EXAMPLE:  example Cerca; shows an example"
{
list R;//Contains the terms, arranged by degree
int i;
R[d+1]=std(Multipli(L[d],r));
print(R);
for(i=d+2;i<=m;i++)
  {
    R[i]=std(Multipli(R[i-1],r)+Multipli(L[i-1],r));
  }
return(R);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
list L=list(list(x,y));
GeneraMultipli(L,1,1);
}
////////////////////////////////////////////////////////////////////
proc Aff(ideal Borid)
"USAGE:  Aff(Borid); Borid ideal
RETURN:   ideal: Borid
NOTE:     The procedure dehomogenizes the input ideal
EXAMPLE:  example Aff; shows an example"
{
int i;
for(i=1;i<=size(Borid);i++)
    {
     Borid[i]=subst(Borid[i],var(1),1);
    }
return(Borid);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal I=x*y^2*z,y*z^2,z^3,y^5;
Aff(I);
}
////////////////////////////////////////////////////////////////////
proc Low(poly g, int t,r)
"USAGE:   Low(poly g, int t,r); g poly, t int, r ring
RETURN:   list: Risu
NOTE:     The procedure splits a polynomial in two parts,
 according to he degrees of the terms inside.
EXAMPLE:  example Low; shows an example"
{
poly m=product(variablesStandard());
matrix A=coef(g,m);
int i;
poly alto;
list Risu;//Contains the two parts of g
for(i=1;i<=ncols(A);i++)
   {
    if(deg(A[1,i])>t)
      {
        alto=alto+A[1,i]*A[2,i];
      }
    else{break;}
   }
Risu=alto,g-alto;
return(Risu);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
poly p=x^2+x*y*z-x;
Low(p,2,r);
}
////////////////////////////////////////////////////////////////////
proc  EqSottosc(ideal Borid, int reg)
"USAGE:   EqSottosc(Borid, reg); Borid ideal, reg int
RETURN:   int: 0/1
NOTE:     It checks whether the Escalier in degree=reg is empty or not
EXAMPLE:  example EqSottosc; shows an example"
{
  if(size(kbase(Borid, reg))==0)
    {return(1);}
 else{return(0);}
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 LIB"all.lib";
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
 int Reg=regIdeal(Borid);
Reg;
EqSottosc(Borid,Reg);
ideal Borid2=x,y,z;
 int Reg=regIdeal(Borid2);
Reg;
EqSottosc(Borid2,Reg);
}
////////////////////////////////////////////////////////////////////
proc RidMonomi(int m0,list G,ideal Borid,list L,r,int d)
"USAGE:  RidMonomi(m0,G,Borid,L,r,d); m0 int, G list, Borid ideal, L list, r ring, d int
RETURN:   list: Equazioni
NOTE:     It performs reduction of monomials as in
 [BCR, thm4.23, condition 2].
EXAMPLE:  example RidMonomi; shows an example"
{
list Equazioni;//contiene le equazioni dello schema
list B=GeneraMultipli(L, m0, d);
list LE;
//then reduce terms
int i; //counter on degrees
int j;//counter on B[i]
poly ridotto;
poly pezzo;
for(i=d+1;i<=m0;i++)
    {
     for(j=1;j<=size(B[i]);j++)
        {
           ridotto=MainRedMon(B[i][j], G, Borid,L,r);
           pezzo=Low(ridotto, m0,r)[2];
           poly m=product(variablesStandard());
           matrix C=coef(pezzo,m);
           LE=C[2,1..ncols(C)];
           Equazioni=Equazioni+LE;
        }
    }
return(Equazioni);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
ideal I=std(Borid);
   list R=OrdinaBorel(I,r);
   int d=R[2];
   int D=R[3];
   int n=nvars(r);
   int m=6;
   int m0=FindEmZero(R[1], m, d,r);
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
RidMonomi(m0,G,I,L,r,d);
}
////////////////////////////////////////////////////////////////////
proc MainRedMon(poly p, list G, ideal Borid,list L,r)
"USAGE:   MainRedMon(p, G, Borid,L,r); p poly, G list, Borid ideal, L list, r ring
RETURN:   poly: q
NOTE:     the procedure computes the reduction of a
 single polynomial.
EXAMPLE:  example MainRedMon; shows an example"
{
list Risultati=p,0;
while(Risultati[1]!=0)
     {
      Risultati=Riduttore(Risultati, G, Borid, L);
     }
poly q=Risultati[2]; //definitively reduced polynomial
return(q);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
ideal I=std(Borid);
   list R=OrdinaBorel(I,r);
   int d=R[2];
   int D=R[3];
   int n=nvars(r);
   int m0=FindEmZero(R[1], m, d,r);//optimized level
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
list B=GeneraMultipli(L, m0, d);
MainRedMon(B[4][1], G, I,L,r);
}
////////////////////////////////////////////////////////////////////
proc RidPolinomi(list G,ideal Borid,list L,r)
"USAGE:   RidPolinomi(G,Borid,L,r); G list, Borid ideal, L list, r ring
RETURN:   list: Coeff
NOTE:     The procedure runs reduction of the polynomials
 as described in [BCR, thm4.23, condition 1].
EXAMPLE:  example RidPolinomi; shows an example
"
{
list Coeff;//contains the coefficients of the resulting polynomial
int i;
int j;
int min;//minimal variable's index
jmp g;//jmp of G under consideration
poly gp;
int d;
for(i=1;i<=size(G);i++)
   {
    g=G[i];
    d=deg(g.h);
    gp=g.h+g.t;
    min=MinVar(g.h,r);//minimal variable
    for(j=min+1;j<=nvars(r);j++)
       {
         gp=var(j)*gp;
         Coeff=Coeff+MainRed(gp, G, Borid,L,r);
       }
   }
return(Coeff);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
list Equazioni;
  ideal I=std(Borid);
   list R=OrdinaBorel(I,r);
   int d=R[2];
   int D=R[3];
   int n=nvars(r);
   int m=6;
   int m0=FindEmZero(R[1], m, d,r);
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
Equazioni=RidPolinomi(G,I,L,r);
Equazioni;
}
////////////////////////////////////////////////////////////////////
proc MinVar(poly p,r)
"USAGE:  MinVar(p,r); p poly, r ring
RETURN:   int: min
NOTE:     The input p has to be a monomial.
 The procedure computes the minimal variable
 occurring in the monomial p.
EXAMPLE:  example MinVar; shows an example"
{
int min;
int n=nvars(r);
int i;
for(i=1;i<=n;i++)
   {
     if(p/var(i)!=0)
       {
         min=i;
         break;
       }
   }
return(min);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 poly p=x*y*z;
MinVar(p,r);
poly q=z^2*y;
MinVar(q,r);
}
////////////////////////////////////////////////////////////////////
proc Riduttore(list R, list G, ideal Borid,list L)
"USAGE:   Riduttore(R, G, Borid,L); R list, G list, Borid ideal, L list.
RETURN:   list: Risultati
NOTE:     Procedure performing reduction as
 substitution head/tail
EXAMPLE:  example Riduttore; shows an example"
{
attrib(Borid,"isSB",1);
poly p=R[1];
poly ap=R[2];//already reduced parts
poly lt=lead(p);// leading monomial
poly lc=leadcoef(lt);// leading coefficient
poly rid=reduce(lt, Borid);
poly pezzor; //reduced part to substitute
if(rid==0)
   {
    print(lt);
     print("In Borid: launch reduction");
    print("Here reduce");
    pezzor=Riduzione(lt/lc,G,Borid);
    p=p-lt-lc*pezzor;//pezzor=x^\eta*tail(f_\alpha)
   }
else
   {
    print("Not in Borid!");
    ap=ap+lt;
    p=p-lt;
   }
list Risultati=p,ap;
return(Risultati);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
ideal I=std(Borid);
list R=OrdinaBorel(I,r);
   int d=R[2]; //minimal degree in Borid
   int D=R[3]; //maximal degree in Borid
   int n=nvars(r); //number of variables in the base ring
   int m0=FindEmZero(R[1], m, d,r);//optimized level
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
list Risultati=x^3+z^3,0;
Riduttore(Risultati, G, I, L);
}
///////////////////////////////////////////////////////////////////////
proc Riduzione(poly p, list G, ideal Borid)
"USAGE:   Cerca(M, r); M list, r ring
RETURN:   int: m0
NOTE:     Input is constituted by a list containing
 terms and the procedure looks for multiples of var(1)
EXAMPLE:  example Cerca; shows an example"
{
poly pezzor;
poly stel;
poly resto;
int i;
for(i=size(Borid);i>=1;i--)
   {
       resto=p/Borid[i];
    if(resto!=0)
       {
         stel=Borid[i];
         break;
       }
   }
jmp pr=G[i];
pezzor=resto*pr.t;
return(pezzor);
}
example
{ "EXAMPLE:"; echo = 1;
  ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
list Equazioni;
  ideal I=std(Borid);
   list R=OrdinaBorel(I,r);
   int d=R[2];
   int D=R[3];
   int n=nvars(r);
   int m=6;
   int m0=FindEmZero(R[1], m, d,r);
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
Riduzione(z^4,G,ideal(y^2*z,y*z^2,z^3,y^5));
}
////////////////////////////////////////////////////////////////////
proc MainRed(poly p, list G, ideal Borid,list L,r)
"USAGE:   Cerca(M, r); M list, r ring
RETURN:   int: m0
NOTE:     Input is constituted by a list containing
 terms and the procedure looks for multiples of var(1)
EXAMPLE:  example Cerca; shows an example"
{
list Risultati=p,0;
while(Risultati[1]!=0)
     {
      Risultati=Riduttore(Risultati, G, Borid, L);
     }
poly q=Risultati[2]; //the reduced polynomial
poly m=product(variablesStandard());
matrix C=coef(q,m);
list L=C[2,1..ncols(C)];
return(L);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
  ideal I=std(Borid);
   list R=OrdinaBorel(I,r);
   int d=R[2];
   int D=R[3];
   int n=nvars(r);
   int m0=FindEmZero(R[1], m, d,r);//optimized level
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
list Risultati=x^3+z^3;
MainRed(z^5, G, ideal(y^2*z,y*z^2,z^3,y^5),L,r);
}
////////////////////////////////////////////////////////////////////
proc AffMarkedScheme(ideal Borid, int m,r)
"USAGE:   AffMarkedScheme(Borid, m,r); Borid ideal, m int, r ring
RETURN:   list: Equazioni
NOTE:     The main procedure: given a strongly
 stable monomial ideal it performs as described in
 [BCR] in order to find the equations of the marked scheme.
EXAMPLE:  example AffMarkedScheme; shows an example"
{
list Equazioni;// Equations of the scheme
if(BorelCheck(Borid,r)&& size(Borid)>1)
 {
   //Since Borid is strongly stable we prepare all the needed data
   ideal I=std(Borid);//We need Borid to be a standard basis, ordered w.r.t. lex
   list R=OrdinaBorel(I,r);
   int d=R[2];   //minimal degree in Borid
   int D=R[3]; //maximal degree in Borid
   int n=nvars(r); //number of variables in the base ring
   int m0=FindEmZero(R[1], m, d,r);//optimized level
   list Risu=ContaParametri(I,R[1], m0,d,D);
int i;
list L=ringlist(r);
list L2;
L2[1]=L[1];
L2[2]=list();
for(i=Risu[2];i>=1;i--)
    {
     L2[2][i]="c("+string(i)+")";
    }
L2[3]=list(list("rp",Risu[2]));
L2[4]=L[4];
L[1]=L2;
if(defined(K)){kill K;}
def K=ring(L);
export K;
setring(K);
def I=imap(r,I);
def R=imap(r,R);
def Risu=imap(r,Risu);
list L=R[1];
list G= ListaJMP(I,Risu,m0);
Equazioni=RidPolinomi(G,I,L,r);
keepring K;
if(m0==D-1 && EqSottosc(I,D))
  {
    //nothing more to do
    print("The equations are(1):");
    print(Equations);
  }
else
  {
//reduction of terms
    Equazioni=Equazioni+ RidMonomi(m0,G,I,L,r,d);
//Stop here
    print("The equations are(2):");
    print(Equations);
  }
 }
else
 {
   print("The given ideal is not strongly stable");
   print("Or alternatively it is a singleton");
   print("Try again!");
 }
return(Equazioni);
}
example
{ "EXAMPLE:"; echo = 1;
 ring r=0, (x,y,z),rp;
 ideal Borid=y^2*z,y*z^2,z^3,y^5;
 AffMarkedScheme(Borid, 6,r);
}
////////////////////////////////////////////////////////////////////
