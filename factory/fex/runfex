#! /home/schmidt/bin/bash
# $Id: runfex,v 1.6 1998-03-11 16:11:28 schmidt Exp $

#{{{ docu
#
# runfex - run factory example collection.
#
#}}}

set -o nounset
set -o noglob

#{{{ global constants
#{{{ docu
#
# - global constants.
#
# ExecName: used to prefix error messages.  Used by warn().
# XXColWidth: default width for data columns.  Used by main() and
#   example().
# EvalAlg: algorithm to read run/collection data from.  Used by
#   main().
#
#}}}
readonly ExecName="$0"

typeset	-ir TBColWidth=80
typeset	-ir ROColWidth=80

readonly EvalAlg="feval"
#}}}

#{{{ global variables
#{{{ docu
#
# - global variables.
#
# runOptions, collectionOptions, runEnvironment,
# collectionEnvironment: options and environment for the
#   examples.  Used by runAlgorithm().
# runConfiguration: which configurations' executables to use.
#   Used by runAlgorithm().
# collectionROOptions: options to print run overview.  Use by
#   main().
# runTBOptions, collectionTBOptions: options to print XX tables.
#   Used by example().
# debugMode: do not execute anything, just print what we would
#   have executed.  Used by main(), example(), and
#   runAlgorithm().
#
# The run* variables and debugMode are set in the main program,
# the rest of the collection* variables in collection().
#
#}}}
runOptions=""
runEnvironment=""
runTBOptions=""
runConfiguration="opt"

collectionOptions=""
collectionEnvironment=""
collectionTBOptions=""
collectionROOptions=""

debugMode=""
#}}}

#
# - functions.
#

#{{{ warn ()
#{{{ docu
#
# warn() - print arguments to stderr prefixed $ExecName.
#
# Global variables used:
#   ExecName
#
#}}}
warn()
{
    echo "$ExecName:" "${@-}" >&2
}
#}}}

#{{{ runAlgorithm ()
#{{{ docu
#
# runAlgorithm() - run algorithm with the correct options.
#
# $1: algorithm to run
# $2: output options
# rest: arguments to algorithm
#
# Global variables used:
#   runOptions, runEnvironment, runConfiguration,
#   collectionOptions, collectionEnvironment,
#   exampleOptions, exampleEnvironment,
#   debugMode
#
#}}}
runAlgorithm()
{
    typeset \
	algorithmName="$1" \
	outputOptions="$2" \
	algorithmOptions="$collectionOptions${exampleOptions-}$runOptions" \
	algorithmEnvironment="$collectionEnvironment${exampleEnvironment-}$runEnvironment"
    shift 2

    # reset factory environemnt to exclude external influences
    FTEST_ENV=""
    FTEST_CIRCLE=""
    FTEST_ALARM=""

    if [ -n "$debugMode" ]; then
	echo "calling $algorithmName.$runConfiguration" $algorithmOptions "$outputOptions" "$algorithmEnvironment" "$@"
    else
	"$algorithmName.$runConfiguration" $algorithmOptions "$outputOptions" "$algorithmEnvironment" "$@"
    fi
}
#}}}

#{{{ printData ()
#{{{ docu
#
# printData() - print example/run table.
#
# $1: options how to print data
# $2: default width to print data
# $3: name of example/collection
# $4: note on example/collection
#
# Global variables used:
#   alg* algorithm information,
#
#}}}
printData()
{
    typeset \
	options="$1" \
	name="$3" \
	note="$4" \
	colWidth

    colWidth="${options//[a-z]/}"
    colWidth="${colWidth:-$2}"
    options="${options//[0-9]/}"

    typeset -i i=0 n=0

    while [ -n "$options" ]; do
	case "$options" in
	    (*h*)
		# do some pretty printing
		if [ ${#name} -lt 7 ]; then
		    echo "$name:		$note."
		elif  [ ${#name} -lt 15 ]; then
		    echo "$name:	$note."
		else
		    echo "$name: $note."
		fi
		 options="${options//h/}" ;;
	    (*p*) echo "$algChar"
		 options="${options//p/}" ;;
	    (*s*) echo "$algSwitch"
		 options="${options//s/}" ;;
	    (*v*) echo "$algVars"
		 options="${options//v/}" ;;
	    (*n*) echo "$algCircle"
		 options="${options//n/}" ;;
	    (*g*) echo "$algSeed"
		 options="${options//g/}" ;;
	    (*f*) echo "$algVers"
		 options="${options//f/}" ;;
	    (*t*) echo "$algTime"
		 options="${options//t/}" ;;
	    (*c*) echo "$algCheck"
		 options="${options//c/}" ;;
	    (*r*)
		n=${#algResult[@]}
		i=0
		while [ $i -lt $n ]; do
		    echo "${algResult[i]}" | fold -s -w$colWidth
		    i=i+1
		done
		options="${options//r/}" ;;
	    (*)   warn "unknown output type specifier '$options' in table specification"
		 options="" ;;
	esac
    done
}
#}}}

#{{{ collection ()
#{{{ docu
#
# collection() - set up collection data.
#
# All we do is setting the collection* variables (except
# collectionName) from commandline.
# We do not set collectionNote and collectionXXOptions if they
# are already set but reset collectionOptions and
# collectionEnvironment on each run to allow for multiple calls
# to collection() in one example collection file (though this is
# bad style).
#
# Global variables used: none
#
#}}}
collection()
{
    collectionOptions=""
    collectionEnvironment=""

    # read collection name
    if [ "$#" = "0" ]; then
	warn "no collection name specified"
	exit 1
    fi
    collectionName="$1"
    shift

    #{{{ read options and environment
    # read options
    typeset opt
    while getopts "n:a:c:t:r:" opt; do
	case "$opt" in
	    (n)	collectionNote="${collectionNote:-$OPTARG}" ;;
	    (a)	collectionOptions="$collectionOptions -a$OPTARG" ;;
	    (c)	collectionOptions="$collectionOptions -c$OPTARG" ;;
	    (t)	collectionTBOptions="${collectionTBOptions:-$OPTARG}" ;;
	    (r)	collectionROOptions="${collectionROOptions:-$OPTARG}" ;;
	    (?)	warn "bad collection option"; exit 1 ;;
	esac
    done
    # shift options and reset OPTIND
    typeset -i optind
    optind=OPTIND-1
    shift $optind
    OPTIND=1

    # read environment
    while [ "${1-}" != "${1+${1#/}}" ]; do
	collectionEnvironment="$collectionEnvironment $1"
	shift
    done
    #}}}
}
#}}}

#{{{ defineSkip ()
#{{{ docu
#
# defineSkip() - define function skipExample().
#
#}}}
defineSkip()
{
    typeset regExp=""
    typeset notRegExp=""
    typeset rawArg arg

    for rawArg; do
	# check for leading ^
	arg="${rawArg#^}"
	if [ "$rawArg" = "$arg" ]; then
	    regExp="$regExp|$arg"
	else
	    notRegExp="$notRegExp|$arg"
	fi
	shift
    done
    regExp="${regExp#|}"
    notRegExp="${notRegExp#|}"

    if [ -z "$regExp" -a -z "$notRegExp" ]; then
	eval "
skipExample()
{
    return 1
}
"
    elif [ -n "$regExp" -a -z "$notRegExp" ]; then
	eval "
skipExample()
{
    case \"\$1\" in
	($regExp) return 1 ;;
	(*) return 0 ;;
    esac
}
"
    elif [ -z "$regExp" -a -n "$notRegExp" ]; then
	eval "
skipExample()
{
    case \"\$1\" in
	($notRegExp) return 0 ;;
	(*) return 1 ;;
    esac
}
"
    else
	eval "
skipExample()
{
    case \"\$1\" in
	($notRegExp) return 0 ;;
	($regExp) return 1 ;;
	(*) return 0 ;;
    esac
}
"
    fi
}
#}}}

#{{{ example ()
#{{{ docu
#
# example() - run an example.
#
# Global variables used:
#   debugMode,
#   runTBOptions,
#   collectionTBOptions,
#   TBColWidth
#
#}}}
example()
{
    typeset exampleName="" \
	    exampleNote="" \
	    exampleOptions="" \
	    exampleEnvironment="" \
	    exampleTBOptions=""

    typeset algorithm="" \
	    algorithmTBOptions=""

    #{{{ read example name and skip it if necessary
    if [ "$#" = "0" ]; then
	warn "no example name specified"
	exit 1
    fi
    exampleName="$1"
    shift

    if skipExample "$exampleName"; then
	if [ -n "$debugMode" ]; then
	    echo "skipping $exampleName"
	fi
	return
    else
	warn "running $exampleName"
    fi
    #}}}
    
    #{{{ read options and environment
    # read options
    typeset opt
    while getopts "n:a:c:t:x:" opt; do
	case "$opt" in
	    (n)	exampleNote="$OPTARG" ;;
	    (a)	exampleOptions="$exampleOptions -a$OPTARG" ;;
	    (c)	exampleOptions="$exampleOptions -c$OPTARG" ;;
	    (t)	exampleTBOptions="$OPTARG" ;;
	    (?)	warn "bad example option"; exit 1 ;;
	esac
    done
    # shift options and reset OPTIND
    typeset -i optind
    optind=OPTIND-1
    shift $optind
    OPTIND=1

    # read environment
    while [ "${1-}" != "${1+${1#/}}" ]; do
	exampleEnvironment="$exampleEnvironment $1"
	shift
    done
    #}}}

    #{{{ read rest of arguments
    if [ "$#" = "0" ]; then
	warn "no example specified"
	exit 1
    fi
    algorithm="$1"
    shift
    #}}}

    # check for debug mode
    if [ -n "$debugMode" ]; then
	runAlgorithm "$algorithm" -oa "$@"
	return
    fi

    # collect output options
    algorithmTBOptions="${runTBOptions:-${exampleTBOptions:-$collectionTBOptions}}"

    #{{{ read and print data
    typeset algChar \
	    algSwitch \
	    algVars \
	    algCircle \
	    algSeed \
	    algVers \
	    algTime \
	    algCheck
    
    typeset -a algResult

    typeset -i j=0

    # read data
    runAlgorithm "$algorithm" -oa "$@" \
	| {
	read algChar
	read algSwitch
	read algVars
	read algCircle
	read algSeed
	read algVers
	read algTime
	read algCheck

	# preprocess output and store result in the arrays
	while read line; do
	    algResult[j]="$line"
	    j=j+1
	done

	# print table
	printData "$algorithmTBOptions" "$TBColWidth" "$exampleName" "$exampleNote"
    }
    #}}}
}
#}}}

#{{{ main program
#{{{ docu
#
# - main program.
#
# runROOptions: options for RO table.  Read from commandline.
# rawCollectionName: collection name with full path
#
# Global variables used:
#   collectionROOptions,
#   debugMode,
#   ROColWidth, EvalAlg
#
#}}}
typeset runROOptions=""
typeset rawCollectionName=""

#{{{ read options and environment
# read options
typeset opt
while getopts "a:c:C:t:r:d" opt; do
    case "$opt" in
	(a)  runOptions="$runOptions -a$OPTARG" ;;
	(c)  runOptions="$runOptions -c$OPTARG" ;;
	(C)  runConfiguration="$OPTARG" ;;
	(t)  runTBOptions="$OPTARG" ;;
	(r)  runROOptions="$OPTARG" ;;
	(d)  debugMode="1" ;;
	(?)  warn "bad run option"; exit 1 ;;
    esac
done
# shift options and reset OPTIND
typeset -i optind
optind=OPTIND-1
shift $optind
OPTIND=1

# read environment
while [ "${1-}" != "${1+${1#/}}" ]; do
    runEnvironment="$runEnvironment $1"
    shift
done
#}}}

# process rest of arguments
if [ "$#" = "0" ]; then
    warn "no collection name specified"
    exit 1
fi
rawCollectionName="${1%.fex}"
shift

defineSkip "$@"

# before going on, check for existence of collection
if [ ! -f "$rawCollectionName.fex" ]; then
    warn "collection $rawCollectionName.fex not found"
    exit 1
fi

# execute collection
. "$rawCollectionName.fex"

if [ -z "$debugMode" ]; then
    typeset algChar
    typeset algSwitch
    typeset algVars
    typeset algCircle
    typeset algSeed
    typeset algVers

    # read data
    runAlgorithm "$EvalAlg" -oe \
	| {
	read algChar
	read algSwitch
	read algVars
	read algCircle
	read algSeed
	read algVers

	# print data
	typeset options="${runROOptions:-$collectionROOptions}"
	# remove some options
	options="${options//tcrd/}"

	printData "$options" "$ROColWidth" "$collectionName" "$collectionNote"
    }
fi
#}}}
